#!/usr/bin/env python

# example basictreeview.py

import threading
import gobject
import pygtk
pygtk.require('2.0')
import gtk
import gtk.gdk
import time

from connector import connector

from cycle_time import _rt_to_dt, is_valid
import os, re, sys

# TO DO:
# 1/ see http://eccentric.cx/misc/pygtk/pygtkfaq.html#13.4
#    How do I get changes in my TreeModel to show up in my TreeView?

pns_host  = 'oliverh-33191VL'
groupname = 'oliverh^userguide'

def compare_dicts( one, two ):
    for key,value in two.iteritems():
        try:
            if one[ key ] == value:
                return True
            else:
                return False
        except KeyError:
            return False

class MyThread(threading.Thread):
    def __init__(self, liststore, headings ):
        super(MyThread, self).__init__()

        self.liststore = liststore
        self.state_summary = {}
        self.headings = headings

        self.summary = connector( pns_host, groupname, 'state_summary' ).get()

        self.quit = False

        self.waiting_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-waiting-glow.xpm" )
        self.submitted_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-submitted-glow.xpm" )
        self.running_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-running-glow.xpm" )
        self.failed_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-failed-glow.xpm" )
        self.finished_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-finished.xpm" )
        self.empty_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-empty.xpm" )

    def update_summary(self):
        #print "Updating Summary"
        try:
            [glbl, states] = self.summary.get_state_summary()
        except Exception,x:
            print x
            return False

        # TO DO: FOR NOW UPDATE GUI EVERY TIME

        #if not compare_dicts( states, self.state_summary ):
        self.state_summary = states
        return True
        #    return True
        #else:
        #    return False

    def update_gui( self ):
        #print "Updating View"
        self.liststore.clear()

        tasks = {}
        for id in self.state_summary:
            name, ctime = id.split( '%' )
            if ctime not in tasks:
                tasks[ ctime ] = [ name ]
            else:
                tasks[ ctime ].append( name )
 
        # flat (a liststore would do)
        ctimes = tasks.keys()
        ctimes.sort()

        for ctime in ctimes:

            tasks_at_ctime = tasks[ ctime ]

            state_list = [ ]

            for name in self.headings:
                if name == 'cycle':
                    state_list.append( '<span color="#05f"><b>' + ctime + '</b></span>' )
                elif name in tasks_at_ctime:
                    state = self.state_summary[ name + '%' + ctime ][ 'state' ] 
                    if state == 'waiting':
                        state_list.append( self.waiting_led )
                    elif state == 'submitted':
                        state_list.append( self.submitted_led )
                    elif state == 'running':
                        state_list.append( self.running_led )
                    elif state == 'finished':
                        state_list.append( self.finished_led )
                    elif state == 'failed':
                        state_list.append( self.failed_led )
                else:
                    state_list.append( self.empty_led )

            self.liststore.append( state_list )
        
        return False

        # expanding treeview
        #members = {}
        #for id in self.state_summary:
        #   name, ctime = id.split( '%' )
        #   if ctime not in members:
        #       members[ ctime ] = [ id ]
        #   else:
        #        members[ ctime ].append( id )
        #
        #for ctime in members:
        #    piter = self.treestore.append(None, [ctime, 'foo','running','bar'])
        #    for id in members[ ctime ]:
        #        name, junk = id.split( '%' )
        #        state = self.state_summary[ id ][ 'state' ]
        #        message = self.state_summary[ id ][ 'latest_message' ]
        #        self.treestore.append( piter, [ ctime, name, state, message ])
        #
        #return False

    def run(self):
        glbl = None
        states = {}
        while not self.quit:
            if self.update_summary():
                gobject.idle_add(self.update_gui )
            time.sleep(1)
        else:
            print "BYE"

class BasicTreeViewExample:

    # visibility determined by state matching active toggle buttons
    def visible_cb(self, model, iter, data):
        # set visible if model value NOT in filter_states

        # TO DO: WHY IS STATE SOMETIMES NONE?
        #state = model.get_value(iter, 2) 
        #if state:
        #    p = re.compile( r'<.*?>')
        #    state = re.sub( r'<.*?>', '', state )

        return state not in data

    #def check_buttons(self, tb):
        #del self.filter_states[:]
        #for b in self.bbox.get_children():
        #    if not b.get_active():
        #        self.filter_states.append(b.get_label())
        #self.modelfilter.refilter()
        #return


    # close the window and quit
    def delete_event(self, widget, event, data=None):
        gtk.main_quit()
        self.t.quit = True
        return False

    def __init__(self):
        # Create a new window
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)

        self.window.set_title("cylc view <" + groupname + ">" )

        self.window.set_size_request(600, 300)

        self.window.connect("delete_event", self.delete_event)

        # allow filtering out of 'finished' and 'waiting'
        #self.all_states = [ 'waiting', 'submitted', 'running', 'finished', 'failed' ]
        # initially filter out only 'finished' tasks
        #self.filter_states = [ 'finished' ]

        ss = connector( pns_host, groupname, 'state_summary' ).get()
        self.task_list = ss.get_config( 'task_list' )
        self.task_list.sort()
        headings = [ 'cycle' ] + self.task_list

        foo = [ str ] * len( headings ) 
        
        # create a liststore with one string column to use as the model
        self.liststore = gtk.ListStore( str, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf, 
                gtk.gdk.Pixbuf) 

        self.treeview = gtk.TreeView( self.liststore )
        self.treeview.modify_base( gtk.STATE_NORMAL, gtk.gdk.color_parse('#000000'))

        # create the TreeViewColumn to display the data
        foo = []
        for n in range( len( headings )) :
            foo.append( headings[ n ] )
            # add columns to treeview
            if headings[ n ] == 'cycle':
                cell = gtk.CellRendererText()
                tvc = gtk.TreeViewColumn( headings[n], cell, markup=n )
            else:
                cell = gtk.CellRendererPixbuf()
                tvc = gtk.TreeViewColumn( headings[n], cell, pixbuf = n )

            self.treeview.append_column(tvc)
            #tvc.set_sort_column_id(n)
            # add the cells to the columns
            #tvc.pack_start(cell, True)

            # set the cell attributes to the appropriate liststore column

        # make it searchable
        #self.treeview.set_search_column(2)
        # Allow sorting on the column
        # Allow drag and drop reordering of rows
        #self.treeview.set_reorderable(True)
        
        #self.treeview.expand_all()

        self.vbox = gtk.VBox()
        self.hbox = gtk.HBox()

        self.scrolledwindow = gtk.ScrolledWindow()
        self.scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

        self.bbox = gtk.HButtonBox()

        #self.label = gtk.Label('Task State Filters')

        #self.hbox.pack_start( self.label, True )
        self.hbox.pack_start( self.bbox, False )

        self.vbox.pack_start(self.scrolledwindow)

        self.vbox.pack_start(self.hbox, False)
        # create toggle buttons to select filtering based on
        # bug state and set buttons active

        #for st in self.all_states:
        #    b = gtk.ToggleButton( st )
        #    self.bbox.pack_start(b)
        #    if st == 'finished':
        #        b.set_active(False)
        #    else:
        #        b.set_active(True)
        #    b.connect('toggled', self.check_buttons)

        self.scrolledwindow.add( self.treeview )
        self.window.add(self.vbox)

        self.window.show_all()

        self.t = MyThread( self.liststore, headings )
        self.t.start()

if __name__ == "__main__":

    imagedir = os.environ[ 'CYLC_DIR' ] + '/images'
    gobject.threads_init()
    tvexample = BasicTreeViewExample()
    gtk.main()

