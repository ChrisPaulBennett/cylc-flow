
DOCUMENTATION OF METASCHEDULING FOR THE TOPNET - NZLAM SYSTEM.

TopNet runs hourly (by reference time) and is dependent on (1)
streamflow at the same reference time, and (2) the most recent available
12-hourly nzlam output.  "most recent available" depends on how far ahead
of the nzlam we allow topnet to run.  In catchup, this should be at most
12 hours because there is no reason not to use the most recent possible
nzlam data. In real time we've chosen 24 hours because timeliness of 
real time forecasts, given new streamflow data, overrides nzlam
recentness to some extent. 

CATCHUP, WITH NZLAM:

There is no gap between nzlam cycles in catchup but topnet and
streamflow still run much faster than nzlam, so topnet will quickly run
out as far ahead of nzlam as it's "fuzzy prerequisite" limits allow
(min:max by ref time). => we need to impose a max 12 hour fuzzy
prerequisite in this case (if we used a 24 hour max, topnet would just
run exactly 24 hours ahead of nzlam instead of 12, which is worse use of
foreast data for only 12 reference-time hours of system time gain).

CATCHUP, WITH OPER2TEST NZLAM

Nzlam effectively runs instantly (the nzlam data has already been
generated), so topnet won't run more than one nzlam cycle (12 hours)
ahead of the nzlam. => we don't need to (but could) impose a max
12 hour fuzzy preqrequisite in this case.

REAL TIME

Nzlam and oper2test are effectively the same slow beast here - one
generates the data, the other waits on it being generated, and very slow
relative to topnet. TopNet will therefore want to keep pace with
streamflow (15 min past the hour) except when constrained by its fuzzy
nzlam prerequisite. => we need to impose a max 24 hour fuzzy
prerequisite in this case (as above).

HOW TO DETECT CATCHUP VS REAL TIME

The three tasks involved here are: nzlam, topnet, streamflow. nzlam and
topnet don't know about real time, but streamflow does: if caught up, it
has to wait until 15 min past the hour of its reference time before
requesting new streamflow observations. So, topnet's fuzzy prerequisite
limits (12 or 24 hours) should ideally be determined by the streamflow
task of the same reference time (i.e. the one that satisfies its
streamflow prerequisite). But, topnet(T) is created without regard for
whether or not streamflow(T) exists yet (although it almost certainly
would exist first because streamflow(T-1) necessarily finishes before
topnet(T-1)) so a new topnet should use the most recent streamflow's
catchup status (most recent by reference time, not creation time, in
case streamflow tasks are created in parallel, or out of order at start
up). 


FUZZY PREREQUISITES

Topnet runs hourly using cotemporal stream flow data AND met forecast data
from *the most recent nzlam run*. This variable nzlam dependence requires
*fuzzy prerequisites*. In addition, we allow topnet to run out to 12 or 24
hours ahead of the nzlam (depending on catchup mode) to make best use of the
important incoming streamflow data.
 

TOPNET VISUALISATION

Site-specific vis is done for every run, but areal only when new
nzlam input is first used.  Topnet tasks detect a change in nzlam input 
by comparing their satisfying prerequisite's nzlam time with that held
in a topnet class variable. Topnet_vis tasks detect the change by 
comparing their own nzlam time class variable with topnet's.
Only the latest value is needed, not a list, because:
   + topnet is sequential
   + topnet_vis is dependent on topnet, so instance could potentially
     overlap but must necessarily start in the right order.


TOPNET AND TOPNET VISUALISATION 'NZLAM TIME' IN THE STATE DUMP FILE

nzlam_time is held as a class variable (not an instance variable) in the
topnet and topnet_vis classes: it represents the latest nzlam time used by all
current topnet instances. Therefore, if there are multiple instances of 
topnet, say, in the state dump file, they will all have the same nzlam_time
value (i.e. do not assume that the nzlam_time assocated with a finished topnet
task is the nzlam_time actually used by that topnet task when it ran.


HOW TO GET TOPNET OVER A 24 HOUR NZLAM FORECAST GAP, IN CATCHUP MODE

If the topnet nzlam file does not exist due to operational problems, the
oper_interface task will hang because when it can't find the file it 
waits on a yet-to-be generated operational file (which in this case will never
be generated). The waiting TopNet will not use the previous oper_interface
(from before the gap) because in catchup mode TopNet is only allowed to get up
to 12 hours ahead of NZLAM. So:

1) use 'remote-control -ck oper_interface%YYYYMMDDHH' to abdicate-and-kill the
two tasks that will hang in the forecast gap. 

2) use 'remote-control -cs' to shut down the controller

3) change CATCHUP_MODE_CUTOFF to 47 in taskdef/topnet.py (this sets TopNet's
fuzzy prerequisite to allow up to 48 hours ahead of the NZLAM) and reconfigure
the system with 'configure-system system-def/ecoconnect/topnet-test'

4/ set a stop time (in user_config.py) past the NZLAM forecast gap and restart
the controller ('sequenz -r'). The first topnet in the gap should now run off
the pre-gap oper_interface. 

6/ when the system stops past the gap, restore CATCHUP_MODE_CUTOFF to 11, 
reconfigure the system (as for 3), and restart again ('sequence -r').

NOTE: in case of a forecast gap in real time (when TopNet is 'caught up') it
should be sufficient to just abdicate-and-kill the hung oper_interface tasks
(because in this case TopNet is allowed to get 48 hours ahead already). In
fact, if running in 'unconstrained' mode, the post-gap oper_interface tasks
will already have started and TopNet should automatically carry on at that
point.  However, the hung (but already abdicated) oper_interfaces tasks will
still have to be killed using 'remote-control -ck oper_interface%YYYYMMDDHH'.
