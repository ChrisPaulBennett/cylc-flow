To Do

* use hasattr to check that required attributes have been defined in the 
  highest level class definition?

* all sys.exit(1) calls should be routed through a clean shutdown, so
  that Pyro nameserver group entries can be deleted automatically.

* define abdication of "sequential" tasks by a message, which can
  default to "task finished". This would allow new forecasts to 
  start as soon as their predecessors have written out the "model
  background state". 

* only topnet-test tasks have been updated for the change that adds
  abdication status to the state dump file.

* go through all 'requisite' class methods, get rid of those that
  aren't used, and make sure the remaining ones are sensibly named

* rationalize CRITICAL and "failed" message processing? Should the
  former always imply the latter? Currently critical status affects
  logging, but a task is only considered failed if a "failed"
  message is received.

* allow remote-control to set a proper stop time (as opposed to an
  instant shutdown).

* document the default O(n) brokered dependency negotation algorithm.

* non-O(n^2) will_get_satisfaction() for use with broker method 

* THE SYSTEM SHOULD NOT DELETE ANY SPENT TASKS AFTER A TASK HAS FAILED,
  to prevent deletion of prerequisites of the failed task that will be
  needed again at restart, after fixing the problem. This won't cause a
  massive overpopulation problem as the failed task will soon hold up
  the whole system anyway, because of the runahead limit.

* possible problem with non-broker (interaction) method: if more than
  one fuzzy satisfying postrequisite, do we end up with the most recent?

* just before a task runs, try to re-satisfy fuzzy prerequisites in case
  a more up-to-date satisfier has shown up while the task was waiting
  for other prerequisites to be satisfied ... OR (better?!) don't try to
  satisfy fuzzy prerequistes until after all non-fuzzy ones have been
  satsified. 

* streamflow 'caughtup' indicator does not need to specify the
  reference time that catchup was achieved even though streamflow
  catches up long before nzlam, because the indicator is only used to
  determine how far ahead of nzlam we allow topnet to get (? I need 
  to think about this).

* in dummy mode, the dummy clock time should be written to the state
  dump file so that the clock doesn't reset to the configured start time
  (plus any configured offset) on a restart.

* retrofit proper exception handling (current use is sporadic).

* allow multiple outputs at the same time.

* state dump information should be a dict, like config, to allow
  arbitrary additional information to be added by new task classes.
