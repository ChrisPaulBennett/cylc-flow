To Do

* DOCUMENT: system shutdown for practice, while real tasks complete:
  restart with them FINISHED!

* forecast tasks can not be 'quick death' because they depend on a
  previous instance. However, they could die as soon as their successor
  is satisfied. 

* put monitor pyro connection in the same "connector" framework.

* DOCUMENT: OPS-style tasks -if others only depend on "completion", then
  failure won't delay downstream tasks. However, cylc still does not
  delete them automatically because the failed task should still be seen
  by the system operator - and this will eventually stall the system at
  max runahead.

* DOCUMENT: cotemporal mates of failed tasks are not deleted
  automatically because they record the state of system tasks that may
  be required to satisfy the failed task's prerequisites when it is
  reset after fixing the problem. Otherwise the sysop can use 
  'cylc reset --ready'

* Consider the effect of "# uncomment for earliest NON-FAILED" (x2) in
  manager.py - and test with dummy mode failout tasks.  For failed F in
  userguide example system, it allows some intermediate finished cycles
  to be deleted, but this does not affect the delay due to max runahead.

* consider task proc loop invocation - could we separate summary update
  vs task processing (e.g. when a task fails we have to run pointlessly
  (?) through the loop in order to update the summary immediately for
  monitoring.

* warn about consequences of deleting a task: system may move on so that
  a reinserted task will not get its prerequisites satisfied.

* Add NIWA Copyright to all files.

* task generator should look for mispelled variables, e.g. $(CYLCE_TIME)

* is taskdef CYCLES sorted for order?

* combine file-move with userguide-2, add SCS suite to the examples
  (with real mode).

* DO NOT DEFAULT TO LOCAL HOST FOR PYRO NAMESERVER HOST NAME - this will
  preclude automatic discovery of remote nameservers.

* optionally allow a pyro request handling (or main loop?) timeout.
  (this is not needed now that the stalling problem is solved?)

* check that ALL input, including that from remote insertion etc., is 
  validated for type (e.g. ID must be name%YYYYMMDDHH) before being
  passed into the program.

* catch deliberate exits in manager, in order cleanly shutdown pyro

* allow task shortnames for control and question commands.

* 'raise SystemExit(message)' everywhere instead of sys.exit(1)?
  print error messages to stderr: print >> sys.stderr, 'message'

* remote background tasks will fail if CYLC_NS_HOST is 'localhost'
  (which is only correct on the local machine)

* consider implementing "either or" and "self destruct"
  prerequisites (Phil's idea) - this would allow automated
  control-system initiated response to failed tasks.  EXAMPLE: if a
  weather forecast fails, run a backup forecast configured with a
  shorter timestep; if the original forecast succeeds, the backup can
  self destruct. The forecast post-processing task(s) would trigger off
  either the original or the backup forecast.

* check that task output times do not exceed the registered run time

* allow cylc task proxies to kill their real external tasks at shutdown
  (and otherwise)?

* improved exception handling and retry and/or alert in case in message 
  script and dummy tasks?

* use exception handling as in manager.insert() to prevent remote
  control operations that throw an exception (e.g. due to mis-formatted 
  user input) from bringing the system down.

* when there are multiple finished tasks that can satisfy a new task's
  restart prerequisites, the one that actually satisfies the new task
  will be an essentially random choice (the first one that comes along). 
  This is OK because the only thing that matters is that at least one
  task can satisfy the restart dependency, then the new task calls the
  prerequisite satisfied. However, we could get tasks to record the ID
  of the satisfier task as well, for each prerequisite, and also to
  choose the latest task as satisfier if more than one can do it.

* python script for easy viewing of configured log files without having
  to know their location?

* the task-generator script should check that the user-defined task
  names do not clash with parent class or attribute names.

* user config for restricted start time (e.g. 06 UTC only)

* when remote killing all waiting tasks at a ref time, check that (a)
  the system has moved on passed that time, and (b) none of the waiting
  tasks are contact tasks whose time has not come up yet.

* tasks with conditional outputs may have trouble with the "keep one
  finished task of each kind" procedure in kill_spent_tasks(). best to
  have multiple tasks instead? 

* detect when taskdef files are newer than task_classes file, and warn
  that use of configure-system may be required.

* use the custom clock everywhere (it knows about dummy mode).

* clean up the clock class with respect to dummy vs real time, and move
  it into task manager?

* retrofit proper exception handling throughout (current use is sporadic).

* task.quick_death should default to False? (as for the task 
  def key that maps to it, %COTEMPORAL_DEPENDANTS_ONLY).

====================================
FUZZY PREREQUISITES (only for infrequent 'advanced' usage - e.g. hourly
TopNet in EcoConnect)

* allow mixed fuzzy and non-fuzzy prerequisites (currently have to 
  set identical fuzzy bounds to simulate the non-fuzzy case; see
  topnet.py).

* FUZZY MATCHING CURRENTLY ASSUMES AT MOST ONE COMPATIBLE OLDER FINISHED
  VERSION OF THE UPSTREAM TASK IS PRESENT, otherwise the match occurs
  with the first one found, whichever it is. This can fail if a system
  problem puts a hold on spent task deletion! E.g.: topnet and oper
  interface go on ahead when topnet_vis has failed (unlikely to happen
  though!)

* just before a task runs, try to re-satisfy fuzzy prerequisites in case
  a more up-to-date satisfier has shown up while the task was waiting
  for other prerequisites to be satisfied ... OR (better?!) don't try to
  satisfy fuzzy prerequistes until after all non-fuzzy ones have been
  satsified. 
