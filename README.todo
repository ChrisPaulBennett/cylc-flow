To Do

* use exception handling as in task_manager.insert() to prevent remote
  control operations that throw an exception (e.g. due to mis-formatted 
  user input) from bringing the system down.

* when there are multiple finished tasks that can satisfy a new task's
  restart prerequisites, the one that actually satisfies the new task
  will be an essentially random choice (the first one that comes along). 
  This is OK because the only thing that matters is that at least one
  task can satisfy the restart dependency, then the new task calls the
  prerequisite satisfied. However, we could get tasks to record the ID
  of the satisfier task as well, for each prerequisite, and also to
  choose the latest task as satisfier if more than one can do it.

* exception handling in task-message script: retry and/or alert in case
  of failure to contact the control system

* python script for easy viewing of configured log files without having
  to know their location.

* the task-generator script should check that the user-defined task
  names do not clash with parent class or attribute names.

* user config for restricted start time (e.g. 06 UTC only) and other
  system-specific restrictions?

* remote setting of 'ready' state for artificially tied tasks (nztide)
  whose artificial tie has failed but whose real prerequisites are known
  to be satisfied

* when remote killing all waiting tasks at a ref time, check that (a)
  the system has moved on passed that time, and (b) none of the waiting
  tasks are contact tasks whose time has not come up yet.

* tasks with conditional outputs may have trouble with the "keep one
  finished task of each kind" procedure in kill_spent_tasks(). best to
  have multiple tasks instead? 

* allow mixed fuzzy and non-fuzzy prerequisites (currently have to 
  set identical fuzzy bounds to simulate the non-fuzzy case; see
  topnet.py).

* FUZZY MATCHING CURRENTLY ASSUMES AT MOST ONE COMPATIBLE OLDER FINISHED
  VERSION OF THE UPSTREAM TASK IS PRESENT, otherwise the match occurs
  with the first one found, whichever it is. This can fail if a system
  problem puts a hold on spent task deletion! E.g.: topnet and oper
  interface go on ahead when topnet_vis has failed (unlikely to happen
  though!)

* just before a task runs, try to re-satisfy fuzzy prerequisites in case
  a more up-to-date satisfier has shown up while the task was waiting
  for other prerequisites to be satisfied ... OR (better?!) don't try to
  satisfy fuzzy prerequistes until after all non-fuzzy ones have been
  satsified. 

* a task should be allowed to declare multiple outputs at the same time
  (currently this is detected as an error condition)

* detect when taskdef files are newer than task_classes file, and warn
  that use of configure-system may be required.

* use the custom clock everywhere (it knows about dummy mode).

* clean up the clock class with respect to dummy vs real time, and move
  it into task manager?

* retrofit proper exception handling (current use is sporadic).

* user_config is imported in task_classes.py to get start_time. It may
  be better to pass this in at task initialisation?

* task.quick_death should default to False? (as for the task 
  def key that maps to it, %COTEMPORAL_DEPENDANTS_ONLY).

* forecast tasks can no longer be 'quick death' because they depend on
  previous instance. Cylon should check for this. However, they could
  die as soon as their successor is satisfied. 
