To Do

* allow auto-generated 'restart' outputs?

* tasks with conditional outputs may have trouble with the "keep one
  finished task of each kind" procedure in kill_spent_tasks(). best to
  have multiple tasks instead? 

* detect receipt of 'finished' message when not all outputs have been
  completed.

* use a special remote request handling call in the main prog. 

* forecast tasks can no longer be 'quick death' because they depend on
  previous instance. However, they could die as soon as their successor
  is satisfied. 

* oneoff tasks need special treatment in manager.kill_spent_tasks() if 
  they do not have quick_death = True.

* allow mixed fuzzy and non-fuzzy prerequisites (currently have to 
  set identical fuzzy bounds to simulate the non-fuzzy case; see
  topnet.py).

* the same user can't currently run multiple cyclon instances in dummy
  mode, because the 'pkill dummy-task.py' on shutdown will kill all of
  his dummy tasks.

* a task should be allowed to declare multiple outputs at the same time
  (currently this is detected as an error condition)

* detect when taskdef files are newer than task_classes file, and warn
  that use of configure-system may be required.

* STATE DUMP INFORMATION SHOULD BE A DICT, LIKE CONFIG, TO ALLOW
  arbitrary additional information to be added by new task classes.
  
* does 'caught up' detection work properly for prerequisiteless parallel
  contact tasks?

* all sys.exit(1) calls should be routed through a clean shutdown, so
  that Pyro nameserver group entries can be deleted automatically.

* just before a task runs, try to re-satisfy fuzzy prerequisites in case
  a more up-to-date satisfier has shown up while the task was waiting
  for other prerequisites to be satisfied ... OR (better?!) don't try to
  satisfy fuzzy prerequistes until after all non-fuzzy ones have been
  satsified. 

* streamflow 'caughtup' indicator does not need to specify the
  reference time that catchup was achieved even though streamflow
  catches up long before nzlam, because the indicator is only used to
  determine how far ahead of nzlam we allow topnet to get (? I need 
  to think about this).

* use the custom clock everywhere (it knows about dummy mode).

* in dummy mode, the dummy clock time should be written to the state
  dump file so that the clock doesn't reset to the configured start time
  (plus any configured offset) on a restart.

* retrofit proper exception handling (current use is sporadic).

* task.quick_death should default to False, as for the task 
  def key that maps to it (%COTEMPORAL_DEPENDANTS_ONLY).

* user_config is imported in task_classes.py to get start_time. It may
  be better to pass this in at task initialisation?
