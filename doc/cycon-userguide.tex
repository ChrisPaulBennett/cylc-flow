%\documentclass[11pt,a4paper]{report}
\documentclass[11pt,a4paper]{article}

\usepackage{listings}
\usepackage{amsmath}

\lstset{language=Python}

\title{How To Use cycon}
\author{Hilary Oliver, NIWA}

\begin{document}

\maketitle
\tableofcontents

\section{Overview}

cycon is a metascheduling controller for systems of interdependent
tasks, where a {\em task} is defined to be a group of one or more
processes treated as a unit for scheduling purposes, and invoked via a
single top level script or executable.  It can do task-completion based
metascheduling (i.e. a task triggers off \texbf{completion} one or more
upstream tasks) {\em without any modification of the existing tasks}:
the only requirement is a simple \textbf{task definition file} that
describes each task. However, if some tasks have long execution times
and several significant internal outputs (i.e. prior to task
completion), you can have cycon trigger downstream tasks off internal
outputs with minor modification of external tasks to get completion of
internal outputs reported back to cycon. 

Section \ref{config} below describes how to configure cycon in order to
control a new system.  Section \ref{usage} describes how to run cycon
once cycon has been configured.

\label{config}
\section{Task Definition Files}

A {\em Task Definition File} defines the properties of a cycon task:
name, valid run times, prerequisites and postrequisites, the task
control script used to invoke the task, etc.  A cycon utility,
\verb=task_generator.py= parses task definition files and auto-generates
Python code that defines the objects that represent each task within
cycon.

\subsection{Typical Example}

Most tasks have only cotemporal (same reference time) upstream and
downstream dependencies (recall that every task is implicitly dependent
on the previous instance of its own class, in cycon). The following
task definition file is sufficient to completely define such a task.
Different postrequisites can be specified depending on reference time. 

\lstset{language=sh, numbers=left}

{\tiny
\noindent
\rule{5cm}{.2mm}
%\begin{lstlisting}
\lstinputlisting{../taskdef/typical.def}
%\end{lstlisting}
}

\subsection{Full Task Definition Template}

\lstset{language=sh, numbers=left}

{\tiny
\noindent
\rule{5cm}{.2mm}
%\begin{lstlisting}
\lstinputlisting{../taskdef/full_template.def}
%\end{lstlisting}
}

\subsection{More Complex Task Behaviour}

\textit{In EcoConnect: only streamflow and topnet}

For tasks that have non-cotemporal upstream dependencies and/or need to  
override task class methods to define new behaviour, the Python task
code must currently be written directly. 

\section{Task Messaging Mechanism}

Each external task must:

\begin{itemize}
\item report (to cycon) when the task has started
\item report when the task has finished
\item report when every other registered task postrequisite has
completed
\end{itemize}

(Technically, the `started' and `finished' messages are just
postrequisites too, but they are special in that every task
must have them).

In addition, tasks can optionally:

\begin{itemize}
\item report any arbitrary unregistered (i.e. non-postrequisite)
messages, for debugging, logging, or progress monitoring purposes.
\end{itemize}

All incoming messages are logged by cycon, but only postrequisite
messages can affect the state of other task objects.

Task messages don't necessarily have to originate from top level task
control scripts. It's a probably a good idea to do this if possible, but
lower level scripts that are invoked as the task runs can communicate
directly with cycon if necessary.

\section{wrapper}

A simple a simple wrapper script invoked by cycon reports task
startup, invokes the task, and reports task completion or failure. 


\label{usage}
\section{Usage}

All user-configurable parameters are set in \verb#config.py#. There is
one commandline option to force a restart from the state dump file
(which may have been edited) instead of the configured start time and
task list:

\lstset{language=sh}

{\small

\noindent
\rule{5cm}{.2mm}
\begin{lstlisting}
ecocontroller [-r]
Options:
    + most inputs should be configured in config.py
    + [-r] restart from the state dump file
\end{lstlisting}
}

\lstset{language=Python}

\subsection{Config File}

{\small
\noindent
\rule{5cm}{.2mm}
\lstinputlisting{../example/config.py}
}



\end{document}
