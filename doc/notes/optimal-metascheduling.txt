OPTIMAL METASCHEDULING

Every task in the system should be submitted at the instant its prerequisites
are satisfied, regardless of reference time or any other consideration, EXCEPT
where this is not desirable. This is desirable for the forecast models (which
have previous instance dependence) and model postprocessing tasks (which don't
have previous instance dependence, but do depend directly or indirectly on
forecast models that do), but it is not desirable for tasks that have no
prerequisites and no previous instance dependence. These are the tasks that
run as soon as they are created (no prerequisites) and then wait on some
external event such as arrival of real time data before reporting completion
(it would be possible for the task proxy object to wait on the known earliest
data arrival time before launching the task, but this would not be desirable
during catchup when all such data is already available). The natural behaviour
of these FREE TASKS is to ALL (up to the system stop time, or otherwise
infinitely many) run at once and thereby swamp the system, so: 

  Free tasks are:
     (1) forced to run in sequence, and 
     (2) not allowed to get more than max_runahead_hours ahead of the oldest
         task in the system at any given time. 

  Together these restrictions prevent (a) multiple instances from running at
  once, and (b) appearance of too many finished instances that have to be kept
  around to satisfy the prerequisites in the rest of the system that will be
  lagging behind.

Sequenz actually applies the max_runahead_hours restriction to all tasks, but
this has the same affect as applying the restriction to just the free tasks
(because the rest of the system depends on the free tasks).  OPTIMAL

====== 

PREVIOUS INSTANCE DEPENDENCE.

Forecast models depend on their previous instance: each forecast generates the
"model background" fields for the next. This is often treated implicitly in
the model itself: if the background file is not used for any other purpose it
may be written and read from some kind of model "running" directory so that
the user does not have to know about it.

In sequenz, this could potentially be handled through explicit prerequisites.
For example, forecast model foo would have a prequisite 
 "file foo-background-YYYYMMDDHH.nc is ready", or 
 "foo finished for YYYYMMDDHH" 
where YYYYMMDDHH is the previous instance reference time.

Instead, however, sequenz makes this kind of dependence implicit in its task
proxy object creation mechanism: For a forecast model foo, instance foo(T2)
should not be created until foo(T1) achieves a "finished" state (i.e. foo(T2)
can't run before foo(T1) is finished, because it doesn't exist before then).

TASKS WITH NO PREVIOUS INSTANCE DEPENDENCE

This includes FREE TASKS (see above) and model postprocessing tasks.

Model post processing tasks don't strictly depend on their previous instance,
but they necessarily depend on upstream cotemporal tasks that do (i.e. the
forecast models). This means that two successive instances of the same post
processing task will not be able to run in parallel, but they can potentially
OVERLAP. This can happen  when the post processing task takes longer to run
than the total time between the previous and current model instances finishing
(i.e. significantly longer than the model itself). If it is not safe to run
multiple instances of the same post processing job at the same time in
the same area, without interference between instances, then the task should be
declared as having previous instance dependence, like a forecast model, which
will force it to run sequentially. 


HANDLING OF PREVIOUS INSTANCE DEPENDENCE IN SEQUENZ: TASK CREATION 

 (1) new forecast model tasks should be created only when their previous
 instance achieves a "finished" state. This forces them to run in sequence.

 (2) other tasks should be created as soon as their previous instance enters
 the "running" state (except for restriction of free tasks, as above) - this
 allows successive instances of these tasks to overlap if the opportunity
 arises (i.e. when dependencies allow).


== an email on the topic, from just prior to achieving optimal metascheduling

From: Hilary Oliver
To: Michael Uddstrom; Colin Tinker; Chris Edsall; Bernard Miville
Date: Monday, May 18, 2009 1:57 PM
Subject: optimal multi-flighting under the new controller?


Hi all,

For optimum multi-flight capability a meta-scheduler should submit every task
to the queue(s) at the instant its prerequisites are satisfied, regardless of
reference time or any other consideration (except for deliberate cobbling of
prerequisiteless tasks - e.g. nztide and any task that goes off to wait on
some external event - to prevent them swamping the system or running too far
ahead).

Forecast models must wait on their previous instances because one forecast
generates the background state for the next.  The new controller, sequenz,
handles this previous-instance dependence implicitly via its task proxy object
creation mechanism: in effect, if T1 and T2 are successive reference times for
task foo, then foo(T2) can't run before foo(T1) finishes because it doesn't
exist before then.

Currently, however, sequenz treats *all* tasks in this way, not just forecast
models.  Thus it is sub-optimal to the extent that system throughput is slowed
by forcing tasks that don't naturally depend on their previous instance to run
sequentially as if they did.  This affects prerequisiteless tasks, which could
potentially run in parallel (albeit cobbled, as above), and it affects some
post processing tasks to a limited extent: successive instances of the same
post processing task can't ever run in parallel (because they depend on
forecast models that do have previous instance dependence) BUT they could
potentially overlap IF the post processing task takes longer to run than the
model run time plus whatever happens between model runs. 

Now, I've realised that with a very small change I can turn sequenz into a
fully optimal meta-scheduler, which in addition to sounding good will have
some impact on system throughput in catchup mode.  The question is, can we
guarantee that all of our post processing tasks can safely overlap if the
opportunity arises?  In other words, can multiple different-reference-time
instances of the same post processing task run at the same time in the same
area without interfering with each other?  (most that I can think of are
entirely reference time dependent, so should be fine, but ... create_images
processes anything it finds doesn't it, not just the one reference time ... if
so, is that strictly necessary?)

Hilary

==
(note that simon wood's task creation scheme, based on satisfaction of special
"primary" prerequisites, would not work for my prerequisiteless tasks).
