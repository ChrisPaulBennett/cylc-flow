
OPTIMAL "MULTIFLIGHT" CAPABILITY (MAXIMUM SYSTEM THROUGHPUT)

This occurs when every task is submitted to the queue(s) as soon as its
prerequisites are satisfied, regardless of reference time or other
considerations, except for deliberate means of preventing prerequisiteless
tasks from swamping the system.

PREVIOUS INSTANCE DEPENDENCE.

Forecast models depend on their previous instance: each forecast generates the
"model background" fields for the next. This is often treated implicitly in
the model itself: if the background file is not used for any other purpose it
may be written and read from some kind of model "running" directory so that
the user does not have to know about it.

In sequenz, this could potentially be handled through explicit prerequisites.
For example, forecast model foo would have a prequisite 
 "file foo-background-YYYYMMDDHH.nc is ready", or 
 "foo finished for YYYYMMDDHH" 
where YYYYMMDDHH is the previous instance reference time.

Instead, however, sequenz makes this kind of dependence implicit in its task
proxy object creation mechanism: For a forecast model foo, instance foo(T2)
should not be created until foo(T1) achieves a "finished" state (i.e. foo(T2)
can't run before foo(T1) is finished, because it doesn't exist before then).

As of May 2009, sequenz actually enforces (or assumes) this previous instance
dependence on all tasks, not just forecast models, which means some tasks that
don't strictly depend on their previous instances are forced to run
sequentially, as if they did. Sequenz is thus sub-optimal to the extent that
this negatively impacts system throughput.

 * forcing tasks with no prerequisites, like nztide, to run sequentially is 
   probably not a bad thing because their maximum throughput behaviour is to
   run infinitely many tasks at once. Even sequentially though, we have to 
   constrain the number of instance allowed to exist at once (including
   "finished" ones), to stop nztide running off far ahead of the main forecast
   models. It would arguably be "more natural" to allow nztide instances to
   run "naturally" in parallel and to constrain the allowable runahead on that
   scheme. 
   
 * Model post processing tasks don't strictly depend on their previous
   instance, but they necessarily depend on upstream cotemporal tasks that do
   (i.e. the forecast models), which means they can't run completely in
   parallel anyway.  However, sequenz will "unfairly" prevent two successive
   instances of a post processing task from *overlapping* when the post
   processing task takes longer to run than the total time between the
   previous and current model instances finishing (i.e. significantly longer
   than the model itself). If it is safe to run multiple instances of the same
   post processing job at the same time, in the same area, without
   interference between instances, then this is a slight impediment to maximum
   system throughput. 

PLANNED MINOR UPGRADE TO ALLOW MAXIMUM SYSTEM THROUGHPUT, WITH CONSTRAINTS.

Vary the task creation scheme according to previous instance dependence:
 (1) forecast models should be created when their previous instance achieves a 
     "finished" state, as above.
 (2) other tasks should be created when their previous instance enters the
     "running" state.

This will immmediately allow successive instances of non-forecast-model tasks
to overlap, should the opportunity arise. It will also prerequisiteless tasks
to run in parallel, so some constraint will be required on task creation
according to the number of tasks of the same type that already exist in the
sytem (this constrains run-ahead too, because tasks aren't killed immediately
after achieving a "finished" state [TO DO: FLESH THIS OUT]).

== an email on the same topic:

From: Hilary Oliver
To: Michael Uddstrom; Colin Tinker; Chris Edsall; Bernard Miville
Date: Monday, May 18, 2009 1:57 PM
Subject: optimal multi-flighting under the new controller?



Hi all,

For optimum multi-flight capability a meta-scheduler should submit every task
to the queue(s) at the instant its prerequisites are satisfied, regardless of
reference time or any other consideration (except for deliberate cobbling of
prerequisiteless tasks - e.g. nztide and any task that goes off to wait on
some external event - to prevent them swamping the system or running too far
ahead).

Forecast models must wait on their previous instances because one forecast
generates the background state for the next.  The new controller, sequenz,
handles this previous-instance dependence implicitly via its task proxy object
creation mechanism: in effect, if T1 and T2 are successive reference times for
task foo, then foo(T2) can't run before foo(T1) finishes because it doesn't
exist before then.

Currently, however, sequenz treats *all* tasks in this way, not just forecast
models.  Thus it is sub-optimal to the extent that system throughput is slowed
by forcing tasks that don't naturally depend on their previous instance to run
sequentially as if they did.  This affects prerequisiteless tasks, which could
potentially run in parallel (albeit cobbled, as above), and it affects some
post processing tasks to a limited extent: successive instances of the same
post processing task can't ever run in parallel (because they depend on
forecast models that do have previous instance dependence) BUT they could
potentially overlap IF the post processing task takes longer to run than the
model run time plus whatever happens between model runs. 

Now, I've realised that with a very small change I can turn sequenz into a
fully optimal meta-scheduler, which in addition to sounding good will have
some impact on system throughput in catchup mode.  The question is, can we
guarantee that all of our post processing tasks can safely overlap if the
opportunity arises?  In other words, can multiple different-reference-time
instances of the same post processing task run at the same time in the same
area without interfering with each other?  (most that I can think of are
entirely reference time dependent, so should be fine, but ... create_images
processes anything it finds doesn't it, not just the one reference time ... if
so, is that strictly necessary?)

Hilary

==
(note: simon's creation scheme, based on arrival of a first
prerequisites, wouldn't work for my prerequisiteless tasks.)

