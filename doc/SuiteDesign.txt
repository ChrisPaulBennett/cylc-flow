________________________________________________________________________
                                              CYLC SUITE DESIGN OVERVIEW

This is a minimal overview of cylc suite definition, and some general
suite design guidelines. For more information, see the cylc userguide.

____________________________________
SUITE DEFINITION DIRECTORY STRUCTURE

.
├── suite.rc                     # Global suite configuration file
│ 
├── taskdef/                     # Task definition files
│   ├── foo.def                  # (may be arranged in sub-directories)
│   └── ...
│ 
├── scripts/                     # Task scripts
│   ├── foo.sh
│   └── ...
│ 
├── doc/                         # Suite documentation
│   ├── SuiteDesign.txt          # (this file)
│   └── ...                      # (anything you like)
│
└── configured/                  # AUTOGENERATED Python modules
    ├── AUTOGENERATED.BY.CYLC
    ├── task_list.py
    ├── task_classes.py
    ├── class_foo.py
    └── ...

> SUITE.RC

The suite.rc file defines a few global settings such as job submission
methods and environment variables made available to all tasks.

> TASKDEF (TASK DEFINITION) FILES

Each task has a corresponding taskdef file that declares its
prerequisites and outputs, task-specific environment variables, the
commandline used to execute the task, and so on.

> TASK SCRIPTS

A taskdef file usually refers to a script that is invoked when the
task's prerequisites are satisfied.  However, simple tasks may be
entirely scripted in the taskdef file (e.g. housekeeping.def), and
multiple tasks with similar functionality can call the same task script
with different input parameters.

Task scripts may reside in the suite definition 'scripts' sub-directory,
in which case they are automatically accessible (you don't need to
supply the full file path) or they may be external.

______________________
SUITE DEPENDENCY GRAPH

A cylc suite is just a collection of individual tasks that interact, via
task proxies inside cylc, to negotiate dependencies at run time by
matching unsatisifed prerequisites with completed outputs. Thus there is
no need for a traditional "top down" suite definition that explicitly
prescribes either execution order or dependencies (triggers). 

However, for those who like a global view of how a suite works, cylc can
generate a nice graphical view of the suite from the dependencies it
resolves at run time (see 'cylc start --graphfile'). 

___________________________________
PROVIDING INPUT PARAMETERS TO TASKS

Cylc tasks can take input from command line arguments and environment
variables specified in taskdef files, or from global environment
variables defined in the suite.rc file.

Generally speaking, input parameters common to several tasks should
be defined once in the suite.rc file, and those specific to a single
task can go in the corresponding taskdef file OR in the suite.rc file.  

Global environment variables can reference other previously defined (in
the suite.rc file) global variables, and task-specific variables can
reference global variables or other previously defined (in the same
taskdef) local variables, because cylc preserves the order of variable
definition.

____________________________________
HANDLING TASK INPUT AND OUTPUT FILES

To run a single task outside of a suite and verify its correctness, the
minimum information required is: what are its prerequisites/inputs and
its outputs. Because cylc is self organising, the ideal is to build a
suite from tasks that are each configured with no more than this
information - in other words unaware of their place in the wider system.
Then in principle tasks could be swapped in and out of, and between,
suites without having to change anything else (except perhaps to ensure
that common inputs and outputs are expressed consistently among tasks).
The fewer explicit connections between tasks, the more flexible and
robust the suite.

But to what extent is this possible when dependencies correspond
(usually) to files that are generated by one task and used by others?

There are several ways of handling connections like this within a suite:

 (1) Have all tasks read and write from a common directory. This may be 
 easily achievable in a small system. 

 (2) Have task B "know" to read its input from A's output directory, or
 have task A know to write its output to B's input directory. This is
 not ideal because at least one of these tasks must have explicit
 knowledge of its place in the suite.
 
 (3) Define middle-man tasks to move files from one task's output
 directory to another's input directory. This is not ideal because
 although the important tasks can be configured generically there are
 now have extra (albeit simple) tasks, and they do require knowledge of
 the wider system. However, this solution may be necessary in some cases.

 (4) THE BEST SOLUTION is probably to have tasks read the paths to
 common files and directories from common environment variables defined
 once in the suite.rc file. Tasks can thus be configured as if to run
 alone and the knowledge of how they interact within the context of the
 suite is confined to the config file. It may not be practical to do
 this throughout some systems (e.g. if tasks run under different owners
 or on different machines) but it is a good ideal to aim for.

____________________
RUNNING SINGLE TASKS

'cylc submit' runs a single suite task exactly as it would run within
the suite, both in terms of job submission method and execution
environment. This can be particularly valuable when building a new
suite or debugging single tasks.

The submit command necessarily assumes that the user has arranged for
the task's input files to be satisfied beforehand.  It is also a good
idea to ensure that all tasks create their own output directories if
necessary, rather than assuming they will exist due to the action of
other suite tasks; this will maximize you ability to run single tasks 
with setting up the filesystem environment manually.

  % mkdir -p $OUTDIR
  % mkdir -p $( dirname $OUTFILE )

  % cylcutil check-vars -c OUTDIR
  % cylcutil check-vars -p OUTFILE
