
#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# WARNING: THIS FILE WAS AUTO-GENERATED BY cylc configure

from daemon import daemon
from asynchronous import asynchronous
from tied import tied
from free import free
from mod_oneoff import oneoff
from mod_sequential import sequential
from mod_contact import contact
from mod_catchup_contact import catchup_contact
from prerequisites_fuzzy import fuzzy_prerequisites
from prerequisites import prerequisites
from outputs import outputs
from cycling_daemon import cycling_daemon
from time import sleep
from task_output_logs import logfiles
import cycle_time
import task_state
import ordered_dict

class coldstart(oneoff, free):
    # AUTO-GENERATED FROM /home/oliverh/cylc/master/suites/ensemble/taskdef/coldstart.def

    name = 'coldstart'
    short_name = 'cld'
    instance_count = 0

    description = []
    description.append("Oneoff coldstart task for the userguide example system. This task")
    description.append("provides the initial restart prerequisites for the forecast models")
    description.append("(during warm cycling, i.e. once the system is running, these are")
    description.append("provided by the previous forecasts).  A real system would likely")
    description.append("have separate cold start tasks for each forecast model, to represent")
    description.append("actual cold start processing: e.g. an initial forecast from a global")
    description.append("model state to provide a background state for a limited-area model,")
    description.append("or a series of runs to \"spin up\" the model to the initial cycle")
    description.append("time. If these processes have been completed previously,")
    description.append("independently of the cylc system, the the coldstart task(s) can be")
    description.append("of the \"tied, dummy\" type, which means they will simply report that")
    description.append("the restart outputs are ready for the first cycle. See the userguide")
    description.append("for alternative ways of starting up a system (%COLDSTART_PREREQUISITES")
    description.append("or manual task reset).")

    owner = None
    external_task = 'coldstart.sh'

    remote_host = None
    job_submit_method = None
    valid_hours = [0,6,12,18]

    def __init__( self, c_time, initial_state, startup = False ):

        # adjust cycle time to next valid for this task
        self.c_time = self.nearest_c_time( c_time )
        self.tag = self.c_time
        self.id = self.name + '%' + self.c_time
        hour = self.c_time[8:10]

        self.prerequisites = prerequisites( self.id )
        self.suicide_prerequisites = prerequisites( self.id )
        self.logfiles = logfiles()

        self.outputs = outputs( self.id )
        self.outputs.add( 'A restart files ready for ' + self.c_time )
        self.outputs.add( 'B restart files ready for ' + self.c_time )
        self.outputs.add( 'C1 restart files ready for ' + self.c_time )
        self.outputs.add( 'C2 restart files ready for ' + self.c_time )
        self.outputs.add( 'C3 restart files ready for ' + self.c_time )
        self.outputs.register()

        if startup:
            # overwrite prerequisites for startup case
            self.prerequisites = prerequisites( self.id )
            self.prerequisites.add( 'startup%'  + self.c_time + ' finished', None )
        self.output_patterns = []

        self.env_vars = ordered_dict.ordered_dict()

        self.commandline = []

        self.directives = {}

        self.extra_scripting = []
        free.__init__( self, initial_state )

