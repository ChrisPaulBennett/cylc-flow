#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# standard Python modules
import re, os, sys, shutil
#import profile
import logging
import datetime
from time import sleep
from optparse import OptionParser

# cycl source modules
import manager
import cycle_time
import dead_letter
import state_summary
import accelerated_clock 
from registration import registrations

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError

def print_banner():
    print "_______________C_Y_L_C___________________"
    print ". Self Organising Dynamic Metascheduler ."
    print ".  (c) Hilary Oliver, NIWA, 2008-2010   ."
    print ".       cylc is pronounced 'silk'       ."
    print "_______________C_Y_L_C___________________"
    print

    items = banner.keys() + startup.keys()

    longest_item = items[0]
    for item in items:
        if len(item) > len(longest_item):
            longest_item = item

    template = re.sub( '.', '.', longest_item )

    for item in banner.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( banner[ item ] )
    for item in startup.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( startup[ item ] )

def locate_pyro_nameserver():
    try:
        nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
    except NamingError:
        raise SystemExit("No Pyro nameserver found on " + pns_host )
    else:
        return nameserver

def create_ns_groupname( nameserver, groupname ):
    try:
        nameserver.createGroup( groupname )

    except NamingError:
        # abort if any existing objects are registered in my group name
        # (this may indicate another instance of cylc is running
        # with the same groupname; must be unique for each instance
        # else the different systems will interfere with each other) 
        print "\nERROR: group '" + groupname + "' is already registered"
        print "in the Pyro nameserver."
        objs = nameserver.list( groupname )
        if len( objs ) == 0:
            print "It currently contains no objects."
        else:
            print "It contains the following registered objects:"
            for obj in objs:
                print '  + ' + obj[0]

        print
        print "If the group is in use by another cylc instance then re-register your"
        print "system under a different name using the 'cylc register' command."
        print 
        print "If the group is being used by a running cylc of yours that you no"
        print "longer need, shut it down using the 'cylc control' command."
        print 
        print "If the group is a relic of an aborted cylc run you can delete it"
        print "manually from the nameserver:"
        print 
        print "pyro-nsc deletegroup " + groupname + "   #<--DO-THIS-!" 
        print
        raise SystemExit( "ABORTING NOW" )

def ns_obj_name( name, groupname ):
    # object name as registered with the Pyro nameserver
    return groupname + '.' + name

usage = """1/ cylc start [options] --at=CYCLE SYSTEM
Usage: 2/ cylc start [options] --restart SYSTEM
Usage: 3/ cylc start [options] --restart-from=FILE SYSTEM

Start up a cylc system registered under the name SYSTEM.
 * The system will start up in a locked state (see 'cylc unlock'). 
 * Use nohup to make the scheduler independent of your terminal log in.
 * See the userguide for documentation of dummy mode and practice mode.

1/ COLD START: each task in the configured task list is instantiated
at the initial cycle time, or at the next cycle valid for the task.  

2,3/ RESTART: tasks in the configured or named state dump file will be
resurrected at startup. Any task recorded as submitted, running, or
failed will be reset to waiting (unless '--practice' or '--no-reset')

Arguments:
   SYSTEM               Registered name of the system to run.""" 

def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( pns_host='localhost', 
            restart=False, dummy_mode=False,
            clock_rate=10, clock_offset=24 )

    parser.add_option( "--at", 
            help="Initial cycle time (YYYYMMDDHH).",
            metavar="CYCLE", action="store", dest="start_time" )
    
    parser.add_option( "--until", 
            help="Shut down after all tasks have PASSED this cycle time.",
            metavar="CYCLE", action="store", dest="stop_time" )

    parser.add_option( "--pause",
            help="Refrain from running tasks AFTER this cycle time.",
            metavar="CYCLE", action="store", dest="pause_time" )

    parser.add_option( "-r", "--restart", 
            help="Restart from the system's configured state dump file",
            action="store_true", dest="restart" )

    parser.add_option( "--restart-from", 
            help="Restart from a named state dump file in the configured "
            "state dump directory, or give the file path.",
            metavar="FILE", action="store", dest="restart_from" )

    parser.add_option( "--no-reset", 
            help="(RESTART) Do no reset failed tasks to the waiting "
            "state at startup. True by default in practice mode.",
            action="store_true", default=False, dest="no_reset" )

    parser.add_option( "--exclude",
            help="Exclude these tasks at startup. Equivalent to "
            "deleting them from the system task list.",
            metavar="Task1,Task2,...", action="store", dest='exclude' )

    parser.add_option( "--include",
            help="Include only these tasks at startup. "
            "Equivalent to deleting all other tasks from the "
            "system task list.",
            metavar="Task1,Task2,...", action="store", dest='include' )

    parser.add_option( "--host",
            help="Pyro nameserver host, defaults to 'localhost'. Use "
            "if not auto-detected (which depends on network config).", 
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "-p", "--practice",
            help="Clone an existing system in dummy mode using new state "
            "and logging directories to avoid corrupting the original. "
            "Failed tasks will not be reset to waiting in the clone.",
            action="store_true", dest="practice_mode" )

    parser.add_option( "-d", "--dummy-mode",
            help="DUMMY MODE: replace system tasks with a program that "
            "masquerades as them and runs on an accelerated clock.",
            action="store_true", dest="dummy_mode" )

    parser.add_option( "--clock-rate", 
            help="(DUMMY MODE) accelerated clock rate: RATE seconds of "
            "real time per simulated hour (defaults to 10).",
            metavar="RATE", action="store", dest="clock_rate" )

    parser.add_option( "--clock-offset", 
            help="(DUMMY MODE) start the accelerated clock at HOURS "
            "prior to the initial cycle time (default 24 hours). "
            "This simulates catch up to real time operation.",
            metavar="HOURS", action="store", dest="clock_offset" )

    parser.add_option( "--fail-out", help=\
            "(DUMMY MODE) get task NAME at cycle time CYCLE to report failure "
            "and then abort. Use this to test failure and recovery scenarios.",
            metavar="NAME%CYCLE", action="store", dest="failout_task_id" )

    return parser

# =====================================================================
# MAIN PROGRAM
# =====================================================================

banner = {}

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

# get system name------------------------------------------------------
name = args[0]
banner[ 'system name' ] = name

# get Pyro nameserver hostname-----------------------------------------
if not options.pns_host:
    # (this won't happen; defaults to localhost)
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host
    banner[ 'Pyro nameserver' ] = pns_host

# get mode of operation------------------------------------------------

if options.dummy_mode and options.practice_mode:
    parser.error( "Choose ONE of dummy or practice mode")

if options.start_time and options.practice_mode:
    parser.error( "You can't do a cold start in practice mode")

dummy_mode = False
practice = False

if options.dummy_mode:
    dummy_mode = True
    banner[ 'mode of operation' ] = 'DUMMY'

elif options.practice_mode:
    dummy_mode = True
    practice = True
    banner[ 'mode of operation' ] = 'PRACTICE DUMMY'

else:
    banner[ 'mode of operation' ] = 'REAL'

# check startup configuration------------------------------------------

startup = {}

startup[ 'start_time'] = None
startup[ 'restart'   ] = False
startup[ 'no_reset'  ] = False

if options.no_reset or options.practice_mode:
    startup[ 'no_reset' ] = True

if options.start_time and ( options.restart or options.restart_from ):
    parser.error( "A start time does not make sense for a restart" )

if not options.start_time and not ( options.restart or options.restart_from ):
    parser.error( 'You must supply a start time or specify a restart' )

if options.start_time:
    startup[ 'start_time' ] = options.start_time
    if not cycle_time.is_valid( options.start_time ):
        parser.error( "invalid cycle time: " + options.start_time )

if options.include and options.exclude:
    parser.error( '--include and --exclude are mutually exclusive' )

if options.exclude:
    exclude = options.exclude.split(',')
else:
    exclude = []
startup[ 'exclude' ] = exclude

if options.include:
    include = options.include.split(',')
else:
    include = []
startup[ 'include' ] = include

# find location of the system task and config modules------------------
reg = registrations()
if reg.is_registered( name ):
    system_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "System " + name + " is not registered!" )

banner[ 'system definition' ] = system_dir

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.
print system_dir
# prepend system scripts to $PATH (prepend in case this is a subsystem!)
# (NOTE this is still somewhat dangerous: if a subsystem task script
# that should be executable but isn't has the same filename as a task in
# the parent system, the parent file will be found and executed).
os.environ['PATH'] = system_dir + '/scripts:' + os.environ['PATH'] 
# prepend add system Python modules to $PYTHONPATH (prepend, as above)
os.environ['PYTHONPATH'] = system_dir + ':' + os.environ['PYTHONPATH']

# provide access to the system source modules for THIS program---------
# prepend to the module search path in case this is a subsystem
sys.path.insert(0, system_dir )

# import system-specific cylc modules now------------------------------ 
from system_config import system_config 
import task     # loads task_classes
import remote_switch # ditto

# load system configuration--------------------------------------------
config = system_config( name )
if options.start_time:
    config.check_start_time( options.start_time )

# find initial state dump file

initial_state_dump = None
configured_state_dump = config.get('state_dump_file')

if options.restart:
    startup[ 'restart' ] = True

    initial_state_dump = configured_state_dump
    if not os.path.exists( initial_state_dump ):
        raise SystemExit( "File not found: " + initial_state_dump )

if options.restart_from:
    startup['restart'] = True

    if os.path.exists( options.restart_from ):
        file = os.path.abspath( options.restart_from )
        print "Restart from state dump: " + file
        initial_state_dump = file

    elif os.path.exists( config.get( 'state_dump_dir' ) + '/' + options.restart_from ):
        file = os.path.abspath( config.get( 'state_dump_dir' ) + '/' + options.restart_from )
        print "Restart from state dump: " + file
        initial_state_dump = file

    else:
        raise SystemExit( "File not found: " + options.restart_from )

if startup[ 'restart' ]:
    startup[ 'initial_state_dump' ] = initial_state_dump

if not practice:
    # back up the configured state dump (i.e. the one that will be used
    # by the system unless in practice mode, but not necessarily the
    # initial one). 

    if os.path.exists( configured_state_dump ):
        backup = configured_state_dump + '.' + datetime.datetime.now().isoformat()
        print "Backing up configured state dump:"
        print "  " + configured_state_dump + " --> " + backup
        try:
            shutil.copyfile( configured_state_dump, backup )
        except:
            raise SystemExit( "ERROR: State dump file copy failed" )

# now create state dump and logging dirs if they don't already exist
# (with modified paths if in practice mode).
config.create_state_dump_dir( practice )
config.create_logging_dir( practice )
config.check_task_groups()
config.job_submit_config()

# LOCATE THE PYRO NAMESERVER-------------------------------------------
nameserver = locate_pyro_nameserver()

# CREATE A UNIQUE NAMESERVER GROUPNAME FOR THIS SYSTEM-----------------
if practice:
    # MODIFY GROUPNAME SO WE CAN RUN NEXT TO THE ORIGINAL SYSTEM.
    groupname = os.environ['USER'] + '_' + name + "_practice"
else:
    groupname = os.environ['USER'] + '_' + name

create_ns_groupname( nameserver, groupname )
banner[ 'Pyro nameserver group' ] = groupname
 
# REQUIRE SINGLE THREADED PYRO (see documentation)
Pyro.config.PYRO_MULTITHREADED = 0
Pyro.core.initServer()

# CREATE A PYRO DAEMON FOR THIS SYSTEM
daemon = Pyro.core.Daemon()
daemon.useNameServer(nameserver)

# system clock for accelerated time in dummy mode
clock = accelerated_clock.clock( 
        int(options.clock_rate),
        int(options.clock_offset),
        dummy_mode ) 

daemon.connect( clock, ns_obj_name( 'clock', groupname ))

# remotely accessible system state summary
system_state = state_summary.state_summary( config, dummy_mode )
daemon.connect( system_state, ns_obj_name( 'state_summary', groupname ))

# dead letter box for remote use
dead_letter_box = dead_letter.letter_box()
daemon.connect( dead_letter_box, ns_obj_name( 'dead_letter_box', groupname))

# load some command line options and dynamic stuff into config
# module, for easy handling.
config.put( 'daemon', daemon )
config.put( 'clock', clock )

# initialize the task manager (and create main logger)
pool = manager.manager( config, groupname, dummy_mode, startup )

if options.stop_time:
    if not cycle_time.is_valid( options.stop_time ):
        parser.error( "invalid cycle time: " + options.stop_time )
    pool.set_stop_time( options.stop_time )

if options.pause_time:
    if not cycle_time.is_valid( options.pause_time ):
        parser.error( "invalid cycle time: " + options.pause_time )
    pool.set_system_hold( options.pause_time )

# load initial task pool after setting stop time, if any
pool.load()

# logger is now created and pimped
log = logging.getLogger( 'main' )

# remote control switch
remote = remote_switch.remote_switch( config, pool, options.failout_task_id )
daemon.connect( remote, ns_obj_name( 'remote', groupname) )

# set global (all tasks) environment variables-------------------------
config.put_env( 'CYLC_MODE', 'scheduler' )
config.put_env( 'CYLC_NS_HOST',  str( pns_host ) )  # may be an IP number
config.put_env( 'CYLC_NS_GROUP',  groupname )
config.put_env( 'CYLC_DIR', os.environ[ 'CYLC_DIR' ] )
config.put_env( 'CYLC_SYSTEM_DIR', system_dir )
config.put_env( 'CYLC_SYSTEM_NAME', name )
if dummy_mode:
    config.put_env( 'CYLC_CLOCK_RATE', str( options.clock_rate ) )
    # communicate failout_task_id to the dummy task program
    if options.failout_task_id:
        print "FAILOUT: " + options.failout_task_id
        config.put_env( 'CYLC_FAILOUT_ID', options.failout_task_id )

# print system information at startup----------------------------------
print_banner()
print
config.dump()
print "\nSTARTING\n"

count = 0
task.state_changed = True

while True: # MAIN LOOP

    # PROCESS ALL TASKS whenever something has changed that might
    # require renegotiation of dependencies, etc.
    #--
    if task.state_changed or \
            remote.process_tasks or \
            pool.waiting_contact_task_ready( clock.get_datetime() ):

        pool.negotiate()

        pool.run_tasks()

        pool.cleanup()

        # spawn after cleanup in case the system had stalled, unspawned
        # at max runahead.
        pool.spawn()

        pool.dump_state()

        system_state.update( pool.tasks, clock, \
                pool.paused(), pool.will_pause_at(), \
                remote.halt, pool.will_stop_at() )

    if pool.all_tasks_finished():
        log.critical( "ALL TASKS FINISHED" )
        break

    if remote.halt_now or remote.halt and pool.no_tasks_running():
        log.critical( "ALL RUNNING TASKS FINISHED" )
        break

    # REMOTE METHOD HANDLING; with no timeout and single- threaded pyro,
    # handleRequests() returns after one or more remote method
    # invocations are processed (these are not just task messages, hence
    # the use of the state_changed variable above).
    #--

    # incoming task messages set this to True
    task.state_changed = False
    remote.process_tasks = False
    # handle all remote calls
    #print "hello ..."
    daemon.handleRequests( timeout = None )
    #print "      ... there"

# END MAIN LOOP

print ""
print "STOPPING"
print ""
print "Shutting down my Pyro daemon"
daemon.shutdown( True )
print "Deleting Pyro nameserver group " + groupname
nameserver.deleteGroup( groupname )
print "Bye!"

# to simulate the effect on monitoring etc. of long task processing time
# (many many tasks...), put this in the task processing loop:
#if count % 50 == 0:
#    # every 50th time, sleep for 30s
#    print 'SLEEPING 30s!'
#    sleep(30)
