#!/usr/bin/env python

import os, re, sys
from optparse import OptionParser
from registration import localdb, unqualify, RegistrationError
from config import config, SuiteConfigError

# NOTE:ABSPATH (see below)
#   rdir = os.path.abspath( rdir )
# On GPFS os.path.abspath() returns the full path with fileset
# prefix which can make filenames (for files stored under the 
# cylc suite directory) too long for hardwired limits in the
# UM, which then core dumps. Manual use of $PWD to absolutize a relative
# path, on GPFS, results in a shorter string ... so I use this for now.

parser = OptionParser( usage = """cylc register [options] [arguments]

Manage cylc suite registrations, which associate a suite name with a
suite definition directory (stored in $HOME/.cylc/registrations). Cylc
commands target a particular suite using its registered name.

Deleting a registration does not delete the suite definition directory!
If you accidentally delete the registration of a running suite, just
reregister it under the same name to regain access to the suite. 

1/ Create a new suite registration (two arguments)
     $ cylc reg SUITE PATH
   where SUITE is GROUP:NAME or NAME (in the 'default' group)
   and PATH is a cylc suite definition location.

2/ Print registered suites (a single argument):
     $ cylc reg [all]        # 'all' is optional
     $ cylc reg GROUP:       # a whole group (NOTE COLON!)
     $ cylc reg GROUP:NAME   # one suite in GROUP
     $ cylc reg NAME         # one suite, 'default' group

3/ Unregister suites:
     $ cylc reg -d,--del all      # 'all' NOT optional
     $ cylc reg -d,--del GROUP:       # as 2/ above
     $ cylc reg -d,--del GROUP:NAME   # ditto
     $ cylc reg -d,--del NAME         # ditto

4/ Clean up any invalid registrations (missing directory or suite.rc)
     $ cylc reg -c,--clean""" )

parser.add_option( "-d", "--del",
        help="Delete registrations.",
        action="store_true", default=False, dest="unregister" )

parser.add_option( "-c", "--clean",
        help="Delete any registrations that are not valid.",
        action="store_true", default=False, dest="clean" )

parser.add_option( "-v", "--verbose",
        help="Turn on verbose output.",
        action="store_true", default=False, dest="verbose" )

( options, args ) = parser.parse_args()

reg = localdb()

if len(args) == 0 and not options.clean and not options.unregister:
    # print all
    args.append( 'all' )

if len(args) == 2:
    # NEW REGISTRATION

    # + cylc register SUITE PATH
    suite = args[0]
    rdir = args[1]
    if not os.path.isdir( rdir ):
        print "Second argument is not a valid directory: " + rdir
        print "Trying reversed arguments..."
        # + cylc register PATH SUITE 
        suite = args[1]
        rdir = args[0]
    if not os.path.isdir( rdir ):
        raise SystemExit( 'ERROR: Suite definition PATH not valid' )

    # remove trailing '/'
    rdir = rdir.rstrip( '/' )
    # remove leading './'
    #rdir = re.sub( '^\.\/', '', rdir )
    rdir = rdir.lstrip('\./')
    # also strip / off name in case of registering same name as dir 
    # whilst sitting one level up from the suite dir itself, using
    # tab completion, and getting the args the wrong way around.
    suite = suite.rstrip( '/' )

    # make registered path absolute # see NOTE:ABSPATH above
    if not re.match( '^/', rdir ):
        rdir = os.path.join( os.environ['PWD'], rdir )

    # get suite title from config file
    try:
        config = config( path=rdir )
    except SuiteConfigError,x:
        raise SystemExit(x)
    else:
        descr = config['title']

    try:
        reg.register( suite, rdir, descr )
    except RegistrationError, x:
        raise SystemExit(x)
    reg.dump_to_file()
    reg.print_reg( suite )
    sys.exit(0)

elif len(args) == 1:
    # + cylc register SUITE                # print
    # + cylc register --unregister SUITE   # delete
    suite = args[0]

    groupfilt = []
    ownerfilt = []
    namefilt = None

    if suite != 'all':
        m = re.match( '^(\w+):$', suite )
        if m:
            # 'group:'
            group = m.groups()[0]
            groupfilt.append( group )
        else:
            filter = unqualify(suite)
            m = re.match( '^(\w+):(\w+)$', filter )
            if m:
                group, name = m.groups()
                groupfilt.append( group )
                namefilt = name
            elif re.match( '^(\w+)$', filter ):
                namefilt = filter
            else:
                raise SystemExit( 'Illegal registration filter: ' + filter )

    # NOTE: for simplicity this uses filtering of all registrations even
    # when actioning a single group or a single name. The registration 
    # module contains more efficient direct access calls for these
    # cases, but it's unlikely to matter: a single user will not have a 
    # massive registration database.
    if options.unregister:
        reg.unregister_multi( ownerfilt=ownerfilt, groupfilt=groupfilt, 
                namefilt=namefilt, verbose=options.verbose )
        reg.dump_to_file()

    else:
        reg.print_multi( ownerfilt=ownerfilt, groupfilt=groupfilt, 
                namefilt=namefilt, verbose=options.verbose )

elif len(args) == 0:
    if options.clean:
        reg.clean_all()
        reg.dump_to_file()

    else:
        parser.error( "Commandline error")
        sys.exit(1)
else:
    parser.error( "Wrong number of arguments" )
