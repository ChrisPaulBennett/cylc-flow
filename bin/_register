#!/usr/bin/env python

# This command used to check the pyro nameserver to make sure a suite
# was not in use before deleting a registration. However, this just
# gives a false sense of security because it won't work if the user
# deliberately or otherwise gives the wrong pyro nameserver host to
# check.

import os, re, sys, socket
from optparse import OptionParser
from registration import registrations

#----------------------------------------
def check_dir( rdir ):
    suiterc = os.path.join( rdir, 'suite.rc' )
    if not os.path.isfile( suiterc ):
        print "ERROR, file not found: " + suiterc
        return False
    else:
        return True

#----------------------------------------

parser = OptionParser( usage = """cylc register [options] [SUITE] [PATH] 

Create and manage cylc suite registrations, which associate a suite name
with a suite definition directory (stored in $HOME/.cylc/registrations).
Cylc commands target a particular suite using its registered name.

1/ Create a new registration:
     $ cylc register SUITE PATH, or 
     $ cylc register PATH SUITE

2/ Print, retrieve or delete an existing registration:
     $ cylc register '[--print] [--get] [--delete] SUITE

3/ List all of your registrations:
     $ cylc register --list

4/ Delete all registrations, or just those that are no longer valid:
     $ cylc register [--wipe] [--check]

A suite's name is available to its tasks as $CYLC_SUITE_NAME. If all
suite I/O directories include the suite name, then multiple instances of
the same suite (not just copies of it) can run at the same time under
different names. The cylc lockserver will allow this if you set:
  SUITE.RC: allow multiple simultaneous suite instances = True

If you accidentally delete the registration of a running suite, just
register it again under the same name. 

Real and dummy mode instances of a suite can be run simultaneously
under different names (but see 'cylc restart --practice-mode' which
automates this without requiring a new registration).

Arguments:
  PATH            Path to a cylc suite definition directory.
  SUITE           Suite name.""" )

parser.add_option( "-g", "--get",
        help="Get the suite definition directory for SUITE.",
        action="store_true", default=False, dest="get" )

parser.add_option( "-p", "--print",
        help="Print the registration of SUITE.",
        action="store_true", default=False, dest="prnt" )

parser.add_option( "-l", "--list",
        help="List all of your suite registrations.",
        action="store_true", default=False, dest="listall" )

parser.add_option( "-u", "--user",
        help="Read another user's suite registrations.", 
        metavar="USER", action="store", default=None, dest="user" )

parser.add_option( "-d", "--delete",
        help="Delete the registration with name SUITE.",
        action="store_true", default=False, dest="delete" )

parser.add_option( "-c", "--check",
        help="Delete any registrations that are not valid.",
        action="store_true", default=False, dest="check" )

parser.add_option( "-w", "--wipe",
        help="Delete all of your suite registrations.",
        action="store_true", default=False, dest="wipe" )

( options, args ) = parser.parse_args()

new_reg = False
prt_reg = False
get_reg = False
del_reg = False
lst_reg = False
chk_reg = False
wpe_reg = False

if len(args) == 2:
    # + cylc register PATH SUITE
    new_reg = True

    arg0 = args[0]
    arg1 = args[1]

    if os.path.isdir( arg0 ) and not re.match( '\/', arg1 ):
        rdir = arg0
        name = arg1
    elif os.path.isdir( arg1 ) and not re.match( '\/', arg0 ): 
        rdir = arg1
        name = arg0
    else:
        raise SystemExit( 'Unable to determine SUITE and PATH from your argument list!' )

    # make registered path absolute
    # rdir = os.path.abspath( rdir )
       # On GPFS os.path.abspath() returns the full path with fileset
       # prefix which can make filenames (for files stored under the 
       # cylc suite directory) too long for hardwired limits in the
       # UKMO executables, which will core dump. Use of $PWD to
       # absolutize a relative path, on GPFS, results in a shorter
       # path string ... so we'll do this the crude way for now:
    if not re.match( '^/', rdir ):
        rdir = os.path.join( os.environ['PWD'], rdir )
    # remove trailing '/'
    rdir = rdir.rstrip( '/' )

    # also strip / off name in case of registering same name as dir 
    # whilst sitting one level up from the suite dir itself, using
    # tab completion, and getting the args the wrong way around.
    name = name.rstrip( '/' )

elif len(args) == 1:
    # + cylc register --print SUITE
    # + cylc register --get SUITE
    # + cylc register --delete SUITE
    name = args[0]
    if options.prnt:
        prt_reg = True
    elif options.get:
        get_reg = True
    elif options.delete:
        del_reg = True
    else:
        parser.error( "Please specify what to do with '" + name + "'" )

elif len(args) == 0:
    # + cylc register --check
    # + cylc register --wipe
    # + cylc register --list
    if options.check:
        chk_reg = True
    elif options.wipe:
        wpe_reg = True
    elif options.listall:
        lst_reg = True
    else:
        parser.print_usage()
        sys.exit(0)
else:
    parser.error( "Wrong number of arguments")

if [ new_reg, prt_reg, get_reg, del_reg, lst_reg, chk_reg, wpe_reg ].count( True ) != 1:
    parser.error( "Choose one option only" )

# load registration file
reg = registrations( options.user )

#---------------------------------------
if new_reg:
    if not check_dir( rdir ):
        sys.exit(1)
    reg.register( name, rdir )
    reg.dump_to_file()
    sys.exit(0)

if options.user:
    if options.user != os.environ[ 'USER' ]:
        if del_reg or chk_reg or wpe_reg:
            parser.error( "You cannot delete, wipe, or check another user's registrations" )

#---------------------------------------
if prt_reg:
    # print the registration and exit
    if reg.is_registered( name ):
        reg.print_reg( name )
        sys.exit(0)
    else:
        print >> sys.stderr, name + " is not registered"
        sys.exit(1)

#---------------------------------------
if get_reg:
    # print the registered suite definition directory and exit
    if reg.is_registered( name ):
        print reg.get( name )
        sys.exit(0)
    else:
        print >> sys.stderr, name + " is not registered"
        sys.exit(1)

#---------------------------------------
if lst_reg:
    # print all registrations and exit
    reg.print_all()
    sys.exit(0)

#----------------------------------------
twatted = []

if chk_reg:
    count = 0
    for name in reg.get_all():
        count += 1
        rdir = reg.get(name)
        if not check_dir( rdir ):
            post = ' ... INVALID'
            twatted.append( name )

        else:
            post = ' ... OK'
        reg.print_reg( name, pre=' [' + str(count) + '] ', post=post )

elif wpe_reg:
    twatted = reg.get_all() 

elif del_reg:
    twatted = [ args[0] ] 

if len(twatted) == 0:
    print "No suites to unregister"
    sys.exit(0)

count = 0
print "Unregistering " + str( len(twatted) ) + " suites:"
for twat in twatted:
    count += 1
    print ' [' + str( count ) + '] ' + twat
    reg.unregister( twat )

# record registration changes
reg.dump_to_file()
