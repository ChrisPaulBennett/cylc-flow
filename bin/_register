#!/usr/bin/env python

import os, re, sys
from optparse import OptionParser
from registration import localdb, unqualify, RegistrationError
from config import config, SuiteConfigError

# NOTE:ABSPATH (see below)
#   rdir = os.path.abspath( rdir )
# On GPFS os.path.abspath() returns the full path with fileset
# prefix which can make filenames (for files stored under the 
# cylc suite directory) too long for hardwired limits in the
# UM, which then core dumps. Manual use of $PWD to absolutize a relative
# path, on GPFS, results in a shorter string ... so I use this for now.

parser = OptionParser( usage = """cylc register [options] [arguments]

Create and cylc suite registrations, which associate a suite name with a
suite definition directory (stored in $HOME/.cylc/registrations). Cylc
commands target a particular suite using its registered name.

NOTE: deleting a suite registration does not delete the suite itself!

1/ Create a new suite registration:
     $ cylc reg SUITE PATH

Arguments:
     SUITE  -  GROUP:NAME or NAME (in the 'default' group)
     PATH   -  A cylc suite definition directory location.

2/ Print registrations:
     $ cylc reg -p                      # print all
     $ cylc reg -p [FILTER options]     # print some

3/ Delete registrations:   
     $ cylc reg -d                      # delete all
     $ cylc reg -d [FILTER options]     # delete some

4/ Clean up invalid registrations: (missing directory or suite.rc):
     $ cylc reg -c,--clean
     
FILTERING: 
  (a) The filter patterns are Regular Expressions, not shell globs, so
the general wildcard is '.*' (match zero or more of anything), NOT '*'.
  (b) For our purposes there is an implicit wildcard at the end of each
pattern ('foo' is the same as 'foo.*'); use the string end marker to
stop this ('foo$' matches only literal 'foo').
  (c) Omission of an item filter is taken to mean "match any of item".
  (d) to single out entries in the default group you have to specify
  the group name explicitly (-g default).

If you accidentally delete the registration of a running suite, just
reregister it under the same name to regain access to the suite.

See also:
    cylc centraldb - view and delete central suite registrations
    cylc export    - export suites to the central suite database
    cylc import    - import suites from the central suite database""" )

parser.add_option( "-p", "--print",
        help="Delete registrations.",
        action="store_true", default=False, dest="rprint" )

parser.add_option( "-d", "--delete",
        help="Delete registrations.",
        action="store_true", default=False, dest="delete" )

parser.add_option( "-g", "--group",
        help="Group filter Regular Expression.",
        metavar="RE", action="store", default=None, dest="groupfilt" )

parser.add_option( "-n", "--name",
        help="Name filter Regular Expression.",
        metavar="RE", action="store", default=None, dest="namefilt" )

parser.add_option( "-c", "--clean",
        help="Delete any registrations that are not valid.",
        action="store_true", default=False, dest="clean" )

parser.add_option( "-v", "--verbose",
        help="Turn on verbose output.",
        action="store_true", default=False, dest="verbose" )

( options, args ) = parser.parse_args()

if len(args) == 2:
    # NEW REGISTRATION: cylc register SUITE PATH
    suite = args[0]
    rdir = args[1]
    if not os.path.isdir( rdir ):
        print "Second argument is not a valid directory: " + rdir
        print "Trying reversed arguments..."
        # + cylc register PATH SUITE 
        suite = args[1]
        rdir = args[0]
    if not os.path.isdir( rdir ):
        raise SystemExit( 'ERROR: Suite definition PATH not valid' )

    # remove trailing '/'
    rdir = rdir.rstrip( '/' )
    # remove leading './'
    rdir = re.sub( '^\.\/', '', rdir )
    # also strip / off name in case of registering same name as dir 
    # whilst sitting one level up from the suite dir itself, using
    # tab completion, and getting the args the wrong way around.
    suite = suite.rstrip( '/' )

    # make registered path absolute # see NOTE:ABSPATH above
    if not re.search( '^/', rdir ):
        rdir = os.path.join( os.environ['PWD'], rdir )

    # get suite title from config file
    try:
        config = config( path=rdir )
    except SuiteConfigError,x:
        raise SystemExit(x)
    else:
        descr = config['title']

    reg = localdb()
    try:
        reg.lock()
    except RegistrationError, x:
        raise SystemExit(x)

    reg.load_from_file()
    try:
        reg.register( suite, rdir, descr )
    except RegistrationError, x:
        raise SystemExit(x)
    reg.unlock()
    reg.dump_to_file()
    sys.exit(0)

if len(args) != 0:
    parser.error( "Commandline error")

if not options.rprint and not options.delete and not options.clean:
    parser.error( "Commandline error")

if options.clean:
    reg = localdb()
    try:
        reg.lock()
    except RegistrationError, x:
        raise SystemExit(x)
    reg.load_from_file()
    if reg.clean_all():
        reg.dump_to_file()
    reg.unlock()
    sys.exit(0)

# check for valid regular expressions:
for filt in options.groupfilt, options.namefilt:
    if filt:
        try:
            re.compile( filt )
        except:
            raise SystemExit( 'Bad expression: ' + filt )

if options.delete:
    reg = localdb()
    try:
        reg.lock()
    except RegistrationError, x:
        raise SystemExit(x)
    reg.load_from_file()
 
    reg.unregister_multi( ownerfilt=None,
            groupfilt=options.groupfilt, namefilt=options.namefilt,
            verbose=options.verbose )
    reg.dump_to_file()
    reg.unlock()

elif options.rprint:
    reg = localdb()
    reg.load_from_file()
    reg.print_multi( ownerfilt=None,
            groupfilt=options.groupfilt, namefilt=options.namefilt,
            verbose=options.verbose )
