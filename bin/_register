#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# This command used to check the pyro nameserver to make sure a suite
# was not in use before deleting a registration. However, this just
# gives a false sense of security because it won't work if the user
# deliberately or otherwise gives the wrong pyro nameserver host to
# check.

import os, sys, socket
from optparse import OptionParser
from registration import registrations

#----------------------------------------
def check_dir( dir ):
    suiterc = os.path.join( dir, 'suite.rc' )
    if not os.path.isfile( suiterc ):
        print "ERROR, file not found: " + suiterc
        return False
    else:
        return True

#----------------------------------------

parser = OptionParser( usage = """cylc register [options] [PATH] [SUITE]

Create and manage cylc suite registrations, which associate a suite name
with a suite definition directory (stored in $HOME/.cylc/registrations).

1/ Create a new registration:
     $ cylc register PATH SUITE

2/ Print, retrieve or delete an existing registration:
     $ cylc register '[--print] [--get] [--delete] SUITE

3/ List all of your registrations:
     $ cylc register --list

4/ Delete all registrations, or just those that are no longer valid:
     $ cylc register [--wipe] [--check]

Registered names are used to target particular suites with cylc
commands. They are also used in logging and state dump directory
paths, allowing multiple suites to run at once without interference.

Real and dummy mode instances of a suite can be run simultaneously
under different names (but see 'cylc restart --practice-mode' which
automates this without requiring a new registration).

The registered name is also exported into the execution environment of
all suite tasks as $CYLC_SUITE_NAME. If all tasks use this in all I/O
paths you can run multiple simultaneous real mode instances of the same
suite under different names (e.g. over different time periods). The cylc
lockserver, via a suite.rc setting, does not allow this. The cylc
userguide example suite can do this, however. 

Deletion of a suite registration does not delete the suite. If you
delete a running suite's registration you will not be able to access it
with cylc commands unless you re-register it under the same name.

Arguments:
  PATH            Path to a cylc suite definition directory.
  SUITE           Suite name.""" )

parser.add_option( "-g", "--get",
        help="Get the suite definition directory for SUITE.",
        action="store_true", default=False, dest="get" )

parser.add_option( "-p", "--print",
        help="Print the registration of SUITE.",
        action="store_true", default=False, dest="prnt" )

parser.add_option( "-l", "--list",
        help="List all of your suite registrations.",
        action="store_true", default=False, dest="listall" )

parser.add_option( "-u", "--user",
        help="Read another user's suite registrations.", 
        metavar="USER", action="store", default=None, dest="user" )

parser.add_option( "-d", "--delete",
        help="Delete the registration with name SUITE.",
        action="store_true", default=False, dest="delete" )

parser.add_option( "-c", "--check",
        help="Delete any registrations that are not valid.",
        action="store_true", default=False, dest="check" )

parser.add_option( "-w", "--wipe",
        help="Delete all of your suite registrations.",
        action="store_true", default=False, dest="wipe" )

( options, args ) = parser.parse_args()

new_reg = False
prt_reg = False
get_reg = False
del_reg = False
lst_reg = False
chk_reg = False
wpe_reg = False

if len(args) == 2:
    # + cylc register PATH SUITE
    new_reg = True

    dir = os.path.abspath( args[0] )
    name = args[1]

elif len(args) == 1:
    # + cylc register --print SUITE
    # + cylc register --get SUITE
    # + cylc register --delete SUITE
    name = args[0]
    if options.prnt:
        prt_reg = True
    elif options.get:
        get_reg = True
    elif options.delete:
        del_reg = True
    else:
        parser.error( "Please specify what to do with '" + name + "'" )

elif len(args) == 0:
    # + cylc register --check
    # + cylc register --wipe
    # + cylc register --list
    if options.check:
        chk_reg = True
    elif options.wipe:
        wpe_reg = True
    elif options.listall:
        lst_reg = True
    else:
        parser.print_usage()
        sys.exit(0)
else:
    parser.error( "Wrong number of arguments")

if [ new_reg, prt_reg, get_reg, del_reg, lst_reg, chk_reg, wpe_reg ].count( True ) != 1:
    parser.error( "Choose one option only" )

# load registration file
reg = registrations( options.user )

#---------------------------------------
if new_reg:
    if not os.path.exists( dir ):
        raise SystemExit( "ERROR, directory not found: " + dir )

    reg.register( name, dir )
    reg.dump_to_file()
    sys.exit(0)

if options.user:
    if options.user != os.environ[ 'USER' ]:
        if del_reg or chk_reg or wpe_reg:
            parser.error( "You cannot delete, wipe, or check another user's registrations" )

#---------------------------------------
if prt_reg:
    # print the registration and exit
    if reg.is_registered( name ):
        reg.print_reg( name )
        sys.exit(0)
    else:
        print >> sys.stderr, name + " is not registered"
        sys.exit(1)

#---------------------------------------
if get_reg:
    # print the registered suite definition directory and exit
    if reg.is_registered( name ):
        print reg.get( name )
        sys.exit(0)
    else:
        print >> sys.stderr, name + " is not registered"
        sys.exit(1)

#---------------------------------------
if lst_reg:
    # print all registrations and exit
    reg.print_all()
    sys.exit(0)

#----------------------------------------
twatted = []

if chk_reg:
    count = 0
    for name in reg.get_all():
        count += 1
        rdir = reg.get(name)
        if not check_dir( rdir ):
            post = ' ... INVALID'
            twatted.append( name )

        else:
            post = ' ... OK'
        reg.print_reg( name, pre=' [' + str(count) + '] ', post=post )

elif wpe_reg:
    twatted = reg.get_all() 

elif del_reg:
    twatted = [ args[0] ] 

if len(twatted) == 0:
    print "No suites to unregister"
    sys.exit(0)

count = 0
print "Unregistering " + str( len(twatted) ) + " suites:"
for twat in twatted:
    count += 1
    print ' [' + str( count ) + '] ' + twat
    reg.unregister( twat )

# record registration changes
reg.dump_to_file()
