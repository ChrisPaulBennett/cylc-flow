#!/usr/bin/env python

import os, re, sys, socket
from optparse import OptionParser
from registration import registrations, RegistrationError
from config import config, SuiteConfigError

parser = OptionParser( usage = """cylc register [options] [SUITE] [PATH] 

Create and manage cylc suite registrations, which associate a suite name
with a suite definition directory (stored in $HOME/.cylc/registrations).
Cylc commands target a particular suite using its registered name.

1/ Create a new registration:
     $ cylc register SUITE PATH, or 
     $ cylc register PATH SUITE

2/ Print, retrieve or delete an existing registration:
     $ cylc register '[--print] [--get] [--delete] SUITE

3/ List all of your registrations:
     $ cylc register --list

4/ Delete all registrations, or just those that are no longer valid:
     $ cylc register [--wipe] [--clean]

A suite's name is available to its tasks as $CYLC_SUITE_NAME. If all
suite I/O directories include the suite name, then multiple instances of
the same suite (not just copies of it) can run at the same time under
different names. The cylc lockserver will allow this if you set:
  SUITE.RC: allow multiple simultaneous suite instances = True

If you accidentally delete the registration of a running suite, just
register it again under the same name. 

Real and dummy mode instances of a suite can be run simultaneously
under different names (but see 'cylc restart --practice-mode' which
automates this without requiring a new registration).

Arguments:
  PATH            Path to a cylc suite definition directory.
  SUITE           Suite CLASS:NAME or NAME.""" )

parser.add_option( "-g", "--get",
        help="Get the suite definition directory for SUITE.",
        action="store_true", default=False, dest="get" )

parser.add_option( "-p", "--print",
        help="Print the registration of SUITE.",
        action="store_true", default=False, dest="prnt" )

parser.add_option( "-l", "--list",
        help="List all of your suite registrations.",
        action="store_true", default=False, dest="listall" )

parser.add_option( "-d", "--delete",
        help="Delete the registration with name SUITE.",
        action="store_true", default=False, dest="delete" )

parser.add_option( "-c", "--clean",
        help="Delete any registrations that are not valid.",
        action="store_true", default=False, dest="clean" )

parser.add_option( "-w", "--wipe",
        help="Delete all of your suite registrations.",
        action="store_true", default=False, dest="wipe" )

( options, args ) = parser.parse_args()

new_reg = False
prt_reg = False
get_reg = False
del_reg = False
lst_reg = False
chk_reg = False
wpe_reg = False

if len(args) == 2:
    # + cylc SUITE PATH
    new_reg = True
    suite = args[0]
    rdir = args[1]
    if not os.path.isdir( rdir ):
        print "Second argument is not a valid directory: " + rdir
        print "Trying reversed arguments..."
        suite = args[1]
        rdir = args[0]
    if not os.path.isdir( rdir ):
        raise SystemExit( 'ERROR: Suite definition PATH not valid' )

    # remove trailing '/'
    rdir = rdir.rstrip( '/' )
    # remove leading './'
    #rdir = re.sub( '^\.\/', '', rdir )
    rdir = rdir.lstrip('\./')
    # also strip / off name in case of registering same name as dir 
    # whilst sitting one level up from the suite dir itself, using
    # tab completion, and getting the args the wrong way around.
    suite = suite.rstrip( '/' )

    # make registered path absolute
    # rdir = os.path.abspath( rdir )
       # On GPFS os.path.abspath() returns the full path with fileset
       # prefix which can make filenames (for files stored under the 
       # cylc suite directory) too long for hardwired limits in the
       # UKMO executables, which will core dump. Use of $PWD to
       # absolutize a relative path, on GPFS, results in a shorter
       # path string ... so we'll do this the crude way for now:
    if not re.match( '^/', rdir ):
        rdir = os.path.join( os.environ['PWD'], rdir )

elif len(args) == 1:
    # + cylc register --print SUITE
    # + cylc register --get SUITE
    # + cylc register --delete SUITE
    suite = args[0]
    if options.prnt:
        prt_reg = True
    elif options.get:
        get_reg = True
    elif options.delete:
        del_reg = True
    else:
        parser.error( "Please specify what to do with '" + suite + "'" )

elif len(args) == 0:
    # + cylc register --clean
    # + cylc register --wipe
    # + cylc register --list
    if options.clean:
        chk_reg = True
    elif options.wipe:
        wpe_reg = True
    elif options.listall:
        lst_reg = True
    else:
        parser.print_usage()
        sys.exit(0)
else:
    parser.error( "Wrong number of arguments")

if [ new_reg, prt_reg, get_reg, del_reg, lst_reg, chk_reg, wpe_reg ].count( True ) != 1:
    parser.error( "Choose one option only" )

reg = registrations()

#---------------------------------------
if new_reg:
    # get suite title from config file
    try:
        config = config( path=rdir )
    except SuiteConfigError,x:
        raise SystemExit(x)
    else:
        descr = config['title']

    try:
        reg.register( suite, rdir, descr )
    except RegistrationError, x:
        raise SystemExit(x)
    reg.dump_to_file()
    print suite + ' --> ' + rdir + ' [' + descr + ']'
    sys.exit(0)

#---------------------------------------
if prt_reg:
    try:
        dir,descr = reg.get( suite )
    except RegistrationError, x:
        raise SystemExit(x)
    print suite + ' --> ' + dir + ' [' + descr + ']'
    sys.exit(0)

#---------------------------------------
if get_reg:
    try:
        dir, descr = reg.get( suite )
    except RegistrationError, x:
        raise SystemExit(x)
    print dir
    sys.exit(0)

#---------------------------------------
if lst_reg:
    reg.print_all()
    sys.exit(0)

#----------------------------------------
if wpe_reg:
    reg.unregister_all()
    reg.dump_to_file()
    sys.exit(0)

#----------------------------------------
if del_reg:
    try:
        reg.unregister(suite)
    except RegistrationError, x:
        raise SystemExit(x)
    reg.dump_to_file()
    sys.exit(0)
 
#----------------------------------------
if chk_reg:
    reg.clean()
    reg.dump_to_file()
    sys.exit(0)
