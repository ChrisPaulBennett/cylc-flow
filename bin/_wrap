#!/bin/bash

# Cylc task wrapper script.

# Allows cylc to control existing tasks that have not been modified to
# do their own cylc messaging. It can only be used for tasks that:
# (a) see their processing through till the end (as opposed to
#    submitting or spawning subprocesses and then exiting), and 
# (b) return non-zero exit status for failure. 

# The task wrapper does the following:
# (1) sends special 'started' message
# (2) executes the wrapped task, with any commandline arguments
# (3) if success: reports all registered outputs completed and finishes
#     if failure: reports failure.

# Wrapped tasks can also send their own cylc messages, which will be
# logged by cylc, but must not send their own start/finished/failed or
# registered output messages.

usage() {
    echo ""
    echo "USAGE: 1/ cylc wrap COMMAND ARGS"
    echo '       2/ cylc wrap --multi="COM1 ARGS1; COM2 ARGS; ..."'
}

usage2() {
    echo 
    echo "The cylc task wrapper allows cylc to run most existing tasks"
    echo "without any cylc-specific modification. It reports (to the "
    echo "parent cylc instance) the task started, executes it, and"
    echo "then reports success (and completion of all outputs) or failure"
    echo "according to the task's exit status. Any task that is followed"
    echo "through to completion by a single control process can be wrapped"
    echo "so long as it returns standard exit codes on success or failure."
    echo "A task whose initial process detaches and returns immediately"
    echo "after spawning other processes to complete the job cannot be"
    echo "wrapped - it must be modified slightly to add cylc messaging."
}

if [[ $1 == '-h' ]] || [[ $1 == '--help' ]]; then
    usage
    usage2
    exit 0
fi

# SEND THE STARTUP MESSAGE
cylc task-started || exit 1

if (( $# == 0 )); then
    usage
    cylc task-failed "cylc wrap: no task to wrap"
    exit 1
fi

multiple=false
if [[ $1 == '-m' ]]; then
    multiple=true
    shift
fi 

# EXECUTE THE WRAPPED TASK AND CHECK FOR SUCCESS OR FAILURE

success=false
if $multiple; then
    if eval $@; then
        success=true
    fi
else
    if $@; then 
        success=true
    fi
fi

if $success; then
    # SUCCEEDED
    cylc task-message --all-outputs-completed
    cylc task-finished
else
    # FAILED
    cylc task-failed 
fi
