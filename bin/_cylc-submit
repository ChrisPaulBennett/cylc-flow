#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


import re, os, sys, datetime, socket, logging
from time import sleep
from optparse import OptionParser
from OrderedDict import OrderedDict

from dynamic_instantiation import get_object
from registration import registrations
from job_submit import job_submit
import cylc_pyro_ns, cycle_time, pimp_my_logger
from preferences import prefs
from suite_lock import suite_lock
from suiterc import suiterc

usage = """cylc submit [options] SUITE TASK_ID

Submit a single task to run as the scheduler would submit it. This can
be used as an easy way to invoke single tasks for any reason, but it is
particularly useful for testing external task scripts during forecast
suite development. When the cylc messaging interface is invoked by
standalone tasks it simply directs all messages to stdout.

arguments:
   SUITE           Registered name of the target suite.
   TASK_ID         Identity of the task to run (NAME%YYYYMMDDHH).""" 


def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( pns_host= socket.getfqdn(), sched=False,
            dry_run=False )

    parser.add_option( "-d", "--dry-run",
            help="Generate the cylc task execution file for the "
            "task and report how it would be submitted to run.",
            action="store_true", dest="dry_run" )

    parser.add_option( "--host",
            help="Pyro Nameserver host (defaults to local host name).",
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "--scheduler",
            help="(EXPERIMENTAL) tell the task to run as a scheduler task, "
            "i.e. to attempt to communicate with a task proxy in a running "
            "cylc suite (you probably do not want to do this).",
            action="store_true", dest="sched" )

    return parser

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) != 2:
    parser.error( "suite name and task ID required." )

# get input args_------------------------------------------------------
name = args[0]
task_id = args[1]

# find location of the suite task and config modules------------------
reg = registrations()
if reg.is_registered( name ):
    suite_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "suite " + name + " is not registered!" )

# check task ----------------------------------------------------------
try:
    ( task_name, ctime ) = task_id.split( '%' )
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH" )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

# get Pyro nameserver hostname-----------------------------------------
if not options.pns_host:
    # (this won't happen; defaults to local hostname)
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host

username = os.environ['USER']
pyro_groupname = ':cylc.' + username + '.' + name

# load cylcrc file----------------------------------------------------
rcfile = prefs()
logging_dir = rcfile.get_suite_logging_dir( name + '-submit' ) 
logging_lvl = rcfile.get_logging_level()

use_lockserver = False
if rcfile.get( 'cylc', 'use lockserver' ) == 'True':
    use_lockserver = True
    # request suite access from the lock server
    # submit does not need to call release_suite_access()
    suite_lock = suite_lock( pns_host, username, name, suite_dir, 'submit' )
    if not suite_lock.request_suite_access():
        raise SystemExit( 'locked out!' )

# provide access to the suite scripts and source modules--------------
# for external processes launched by this program.

# add suite scripts to $PATH
os.environ[ 'PATH' ] += ':' + suite_dir + '/scripts'
# add suite Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + suite_dir + '/configured'

# provide access to the suite source modules for THIS program---------
sys.path.append( suite_dir )
sys.path.append( os.path.join( suite_dir, 'tasks' ))

# import suite modules now that PYTHONPATH is defined------------------ 
from config import config
import task
import remote_switch

# initial global environment ----------------------------------------
globalenv = OrderedDict()
if options.sched:
    globalenv[ 'CYLC_MODE' ] = 'scheduler'
else:
    globalenv[ 'CYLC_MODE' ] = 'submit'
globalenv[ 'CYLC_NS_HOST' ] = pns_host
globalenv[ 'CYLC_NS_GROUP' ] = pyro_groupname
globalenv[ 'CYLC_DIR' ] = os.environ[ 'CYLC_DIR' ]
globalenv[ 'CYLC_SUITE_DIR' ] = suite_dir
globalenv[ 'CYLC_SUITE_NAME' ] = name
globalenv[ 'CYLC_USE_LOCKSERVER' ] = str( use_lockserver )

# load suite configuration--------------------------------------------
config = config( name, globalenv, logging_dir )
config.job_submit_config()

# create the task log
log = logging.getLogger( 'main.' + task_name )
pimp_my_logger.pimp_it( log, task_name, logging_dir, \
        logging_lvl, False, None, True )

if use_lockserver:
    # LOCATE THE PYRO NAMESERVER---------------------------------------
    # (required for suite locking)
    nameserver = cylc_pyro_ns.ns( pns_host )

job_submit.global_env = config.get( 'environment' )

jsc = config.get('job submit class')
clsmod = __import__( 'task_classes' )
try:
    cls = getattr( clsmod, task_name )
except AttributeError:
    print "ERROR: " + task_name + " not found in " + name
    sys.exit(1)

setattr( cls, 'job_submit_method', jsc[ task_name ] )

# intantiate the task--------------------------------------------------
task = get_object( 'task_classes', task_name )( ctime, 'waiting', startup=True )

# SUBMIT THE TASK TO RUN-----------------------------------------------
print
if not options.dry_run:
    print "Cylc messages will be directed to stdout (=> the task log file)."
    print "Logging directory is " + logging_dir
    print
task.run_external_task( options.dry_run )
print
