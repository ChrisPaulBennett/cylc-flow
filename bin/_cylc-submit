#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# standard Python modules
import re, os, sys, datetime, socket, logging
from time import sleep
from optparse import OptionParser

# cycl source modules
from dynamic_instantiation import get_object
from registration import registrations
from job_submit import job_submit
import cylc_pyro_ns, cycle_time, pimp_my_logger
from preferences import prefs
from system_lock import system_lock

usage = """cylc submit [options] SYSTEM TASK_ID

Submit a single task to run as the scheduler would submit it. This can
be used as an easy way to invoke single tasks for any reason, but it is
particularly useful for testing external task scripts during forecast
system development. When the cylc messaging interface is invoked by
standalone tasks it simply directs all messages to stdout.

arguments:
   SYSTEM          Registered name of the target system.
   TASK_ID         Identity of the task to run (NAME%YYYYMMDDHH).""" 


def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( pns_host= socket.getfqdn(), sched=False,
            dry_run=False )

    parser.add_option( "-d", "--dry-run",
            help="Generate the cylc task execution file for the "
            "task and report how it would be submitted to run.",
            action="store_true", dest="dry_run" )

    parser.add_option( "--host",
            help="Pyro Nameserver host (defaults to local host name).",
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "--scheduler",
            help="(EXPERIMENTAL) tell the task to run as a scheduler task, "
            "i.e. to attempt to communicate with a task proxy in a running "
            "cylc system (you probably do not want to do this).",
            action="store_true", dest="sched" )

    return parser

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) != 2:
    parser.error( "System name and task ID required." )

# get input args_------------------------------------------------------
name = args[0]
task_id = args[1]

# find location of the system task and config modules------------------
reg = registrations()
if reg.is_registered( name ):
    system_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "System " + name + " is not registered!" )

# check task ----------------------------------------------------------
try:
    ( task_name, ctime ) = task_id.split( '%' )
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH" )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

# get Pyro nameserver hostname-----------------------------------------
if not options.pns_host:
    # (this won't happen; defaults to local hostname)
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host

username = os.environ['USER']
pyro_groupname = ':cylc.' + username + '.' + name

# load cylcrc file----------------------------------------------------
rcfile = prefs()
logging_dir = rcfile.get_system_logging_dir( name + '-submit' ) 
logging_lvl = rcfile.get_logging_level()

use_lockserver = False
if rcfile.get( 'cylc', 'use lockserver' ) == 'True':
    use_lockserver = True
    # request system access from the lock server
    # submit does not need to call release_system_access()
    system_lock = system_lock( pns_host, username, name, system_dir, 'submit' )
    if not system_lock.request_system_access():
        raise SystemExit( 'locked out!' )

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.

# add system scripts to $PATH
os.environ[ 'PATH' ] += ':' + system_dir + '/scripts'
# add system Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + system_dir

# provide access to the system source modules for THIS program---------
sys.path.append( system_dir )
sys.path.append( os.path.join( system_dir, 'tasks' ))

# import system-specific cylc modules now------------------------------ 
from system_config import system_config 
import task
import remote_switch

# load system configuration--------------------------------------------
config = system_config( name )
config.put( 'logging_dir', logging_dir ) 
config.job_submit_config()

# create the task log
log = logging.getLogger( 'main.' + task_name )
pimp_my_logger.pimp_it( log, task_name, logging_dir, \
        logging_lvl, False, None, True )

# LOCATE THE PYRO NAMESERVER-------------------------------------------
# (required for system locking)
nameserver = cylc_pyro_ns.ns( pns_host )

# set global (all tasks) environment variables-------------------------
if options.sched:
    config.put_env( 'CYLC_MODE', 'scheduler' )
else:
    config.put_env( 'CYLC_MODE', 'submit' )
config.put_env( 'CYLC_NS_HOST', pns_host ) 
config.put_env( 'CYLC_NS_GROUP', pyro_groupname )
config.put_env( 'CYLC_DIR', os.environ[ 'CYLC_DIR' ] )
config.put_env( 'CYLC_SYSTEM_DIR', system_dir )
config.put_env( 'CYLC_SYSTEM_NAME', name )
config.put_env( 'CYLC_USE_LOCKSERVER', str( use_lockserver) )

config.check_environment()
job_submit.global_env = config.get( 'environment' )

jsc = config.get('job submit class')
clsmod = __import__( 'task_classes' )
try:
    cls = getattr( clsmod, task_name )
except AttributeError:
    print "ERROR: " + task_name + " not found in " + name
    sys.exit(1)

setattr( cls, 'job_submit_method', jsc[ task_name ] )

# intantiate the task--------------------------------------------------
task = get_object( 'task_classes', task_name )( ctime, 'waiting', startup=True )

# SUBMIT THE TASK TO RUN-----------------------------------------------
print
if not options.dry_run:
    print "Cylc messages will be directed to stdout (=> the task log file)."
    print "Logging directory is " + logging_dir
    print
task.run_external_task( options.dry_run )
print
