#!/usr/bin/python

import os
import re
import sys
import pyrex
import Pyro.core
from optparse import OptionParser
from time import sleep
from Pyro.errors import PyroError,NamingError

ctrl_end = "\033[0m"

def prompt( reason ):

    if options.force:
        return True

    print reason + " '" + system_name + "':",
    response = raw_input( 'ARE YOU SURE (y/n)? ' )
    if response == 'y':
        return True
    else:
        print "Aborted!"
        return False

# construct a command line parser
parser = OptionParser( "%prog [options]" )

parser.add_option( "-f", "--force", help="don't prompt before acting",
        action="store_true", default=False, dest="force" )

parser.add_option( "-p", "--pause", help="pause system now",
        action="store_true", default=False, dest="pause" )

parser.add_option( "--hold", help="set system hold time",
        metavar="YYYYMMDDHH", action="store", dest="hold_time" )

parser.add_option( "--reset", help="reset a failed task to the waiting state",
        metavar="name%YYYYMMDDHH", action="store", dest="reset_id" )

parser.add_option( "-r", "--resume", help="unhold/resume system",
        action="store_true", default=False, dest="resume" )

parser.add_option( "-s", "--shutdown", help="shutdown system",
        action="store_true", default=False, dest="shutdown" )

parser.add_option( "-t", "--stop-time", help="set stop time",
        metavar="YYYYMMDDHH", action="store", dest="stop_time" )

parser.add_option( "-c", "--configured", help="use configured system",
        action="store_true", default=False, dest="use_configured" )

parser.add_option( "-n", "--name", help="system name",
        metavar="SYSTEM-NAME", action="store", dest="system_name" )

parser.add_option( "-k", "--kill", 
        help="abdicate and kill one or more named tasks, or all waiting tasks, at a given reference time",
        metavar="[<name1,name2,...>%]YYYYMMDDHH", 
        action="store", dest="kill_task_id" )

parser.add_option( "--purge", 
        help="abdicate and kill a task and its dependees down to a given time",
        metavar="name%YYYYMMDDHH,YYYYMMDDHH", 
        action="store", dest="purge" )

parser.add_option( "-d", "--dump-requisites", 
        help="dump the prerequisites and outputs of one or more tasks",
        metavar="<name1,name2,...>%YYYYMMDDHH", 
        action="store", dest="dump_task_id" )

parser.add_option( "-x", "--describe-tasks", 
        help="dump the descriptive information on one or more tasks",
        metavar="<name1,name2,...>", 
        action="store", dest="describe_names" )

parser.add_option( "-i", "--insert", help="insert a new task (EXPERIMENTAL!)",
        metavar="[GROUP:]<name>%<YYYYMMDDHH>", action="store", dest="insert_task_id" )

verbosity_choices = ['debug','info', 'warning', 'error', 'critical'] 
parser.add_option( "-v", "--verbosity",
        help="set verbosity: " + ', '.join(verbosity_choices),
        action="store", 
        choices=verbosity_choices,
        dest="verbosity" )

parser.add_option( "-b", "--bump", help= "bump the system",
        action="store_true", default=False, dest="bump" )

#if len( sys.argv ) == 1:
#    # no options or args supplied
#    parser.print_help()
#    sys.exit(1)

# get command line options and positional args
( options, args ) = parser.parse_args()

#if len( args ) > 1:
#    parser.error( "incorrect number of arguments" )

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover()

if options.use_configured:
    # use the configured system
    import config
    config = config.config()
    config.load()
    system_name = config.get( 'system_name' )

elif options.system_name:
    # use the given system name
    system_name = options.system_name
    if ns_groups.registered( system_name ):
        print "system: " + system_name
    else:
        print "WARNING: no " + system_name + " registered yet ..." 
        ns_groups.print_info()
        sys.exit(1)

else:
    # print available systems and exit
    print
    print "ERROR: you must specify a system name; use '-c' or '-n'"
    print
    parser.print_help()
    print
    ns_groups.print_info()
    print
    print "ERROR: you must specify a system name; use '-c' or '-n'"
    print
    sys.exit(1)


try:
    # connect to the remote switch object in cyclon
    control = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.' + 'remote' )
except NamingError:
    print "\n\033[1;37;41mfailed to connect" + ctrl_end + ' to remote switch in "' + system_name + '"'
    raise SystemExit

if options.reset_id:
    if prompt( 'Reset ' + options.reset_id + ' to the waiting state for' ):
        control.reset_to_waiting( options.reset_id )

if options.pause:
    if prompt( 'Pause' ):
        control.hold()

if options.hold_time:
    if prompt( 'Set hold time ' + options.hold_time + ' for'):
        control.set_hold_time( options.hold_time )

if options.stop_time:
    if prompt( 'Set stop time ' + options.stop_time + ' for'):
        control.set_stop_time( options.stop_time )

if options.resume:
    if prompt( 'Resume' ):
        control.resume()

if options.shutdown:
    if prompt( 'Shutdown' ):
        control.shutdown()

if options.verbosity:
    print "Requesting verbosity " + options.verbosity
    control.set_verbosity( options.verbosity )

if options.insert_task_id:
    if prompt( 'Insert ' + options.insert_task_id + ' in' ):
        print "Requesting insertion of " + options.insert_task_id
        control.insert( options.insert_task_id )

if options.describe_names:
    # retrieve and print task class descriptions
    if re.search( ',', options.describe_names ):
        names = options.describe_names.split( ',' )
    else:
        names = [ options.describe_names ]

    print "Getting descriptive information for " + options.describe_names
    info = control.get_task_info( names )
    for name in info.keys():
        print
        print name + ':'
        for line in info[name]:
            print '  ' + line
    print

if options.dump_task_id:
    # TO DO: this currently gets cyclon to dump the requested
    # information to stdout. It might be better to connect to the
    # task objects themselves and print the information here. 
    [ tmp, reftime ] = options.dump_task_id.split( '%' )
    if re.search( ',', tmp ):
        names = tmp.split( ',' )
    else:
        names = [ tmp ]

    print "Requesting (pre)requisite dump for " + options.dump_task_id

    ids = []
    for name in names:
        id = name + '%' + reftime
        ids.append( id )

    result = control.dump_task_requisites( ids )
    for id in result.keys():
        [ pre, out ] = result[ id ]
        print
        print id + ' prerequisites:'
        for item in pre:
            [ msg, state ] = item
            if state:
                descr = 'satisfied:     '
            else:
                descr = 'not satisfied: '
            print descr + msg
        print
        print id + ' outputs:'
        for item in out:
            [ msg, state ] = item
            if state:
                descr = 'completed:     '
            else:
                descr = 'not completed: '
            print descr + msg


if options.purge:
    if prompt( 'Purge ' + options.purge + ' in' ):

        [ task_id, stop_purge_time ] = options.purge.split( ',' )
        print "Requesting purge for " + options.purge
        control.purge( task_id, stop_purge_time )

if options.kill_task_id:
    if prompt( 'Kill all waiting tasks at ' + options.kill_task_id + ' in' ):

        if not re.search( '%', options.kill_task_id ):
            # kill all tasks in given reference time
            # TO DO: check validity of given ref time
            reftime = options.kill_task_id
            print "Requesting abdicate and kill all WAITING tasks at " + reftime
            control.abdicate_and_kill_rt( reftime )

        else:

            [ tmp, reftime ] = options.kill_task_id.split( '%' )
            if re.search( ',', tmp ):
                names = tmp.split( ',' )
            else:
                names = [ tmp ]

            print "Requesting abdicate and kill for " + options.kill_task_id

            ids = []
            for name in names:
                id = name + '%' + reftime
                ids.append( id )

            control.abdicate_and_kill( ids )

        print "WARNING: you may also need to kill the REAL task(s)"

if options.bump:
    control.nudge()

#if options.bump_hours:
#DISABLED, NOT VERY USEFUL. 
#    # bump the dummy time forward. 
#    try:
#        dummy_clock = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.' + 'clock' )
#    except:
#        print "ERROR: failed to connect to the dummy clock"
#        sys.exit(1)
#    print "current time: " + str( dummy_clock.get_datetime() )
##    print "bumped on to: " + str( dummy_clock.bump( options.bump_hours ))
