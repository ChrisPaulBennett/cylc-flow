#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2013 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, sys
from time import sleep, time
from cylc.remote import remrun
from cylc.task_state import task_state

if remrun().execute():
    sys.exit(0)

from cylc.CylcOptionParsers import cop
from cylc.dbstatecheck import CylcSuiteDBChecker, DBNotFoundError
from cylc.global_config import get_global_cfg
from cylc.command_polling import poller

class suite_poller( poller ):
    """A polling object that checks suite state."""

    def connect( self, verbose=False ):
        """Connect to the suite db, polling if necessary in case the
        suite has not been started up yet."""

        # Returns True if connected, otherwise (one-off failed to
        # connect, or max number of polls exhausted) False
        connected = False
        
        if verbose:
            sys.stdout.write("connecting to suite db for " + 
                  self.args['run_dir'] + "/" + self.args['suite'])
        
        # max_polls*interval is equivalent to a timeout, and we
        # include time taken to connect to the run db in this...
        while ( not connected and self.n_polls < self.max_polls ):
            self.n_polls += 1
            try:
                self.checker = CylcSuiteDBChecker(self.args['run_dir'], self.args['suite'])
                connected = True
                # ... but ensure we at least get one proper poll of the db 
                self.n_polls -= 1
            except DBNotFoundError:
                if verbose:
                    sys.stdout.write('.')
                sleep(self.interval)
        if verbose:
            sys.stdout.write('\n')
        return connected

    def check( self ):
        # return True if desired suite state achieved, else False
        if self.checker.task_state_met(
                self.args['task'],
                self.args['cycle'],
                self.args['status']):
            return True
        else:
            return False

parser = cop( usage = """cylc suite-state REG [OPTIONS]

Print task states retrieved from a suite database, or poll until a task
reaches a particular state (by using the --task, --cycle, and --status
options with --interval and --max-polls). For a one-off check instead 
of polling, use --max-polls=1. The suite database does not need to exist
at the time polling commences, but polls are consumed waiting for it.

Note, for non-cycling tasks --cycle=1 must be provided.

Example usage:
  cylc suite-state REG --task=TASK --cycle=CYCLE --status=STATUS
Returns 0 if TASK at CYCLE has reached STATUS, 1 otherwise.""")

parser.add_option( "-t", "--task", 
        help="Specify a task to check the state of.",
        action="store", dest="task", default=None )

parser.add_option( "-c", "--cycle", 
        help="Specify the cycle to check task states for.",
        action="store", dest="cycle", default=None )

# TODO - this should not be necessary.  If --host is used the command
# will be re-invoked on the suite host where the run directory is
# determined by site/user config. Or is it for testing purposes?
parser.add_option( "-d", "--run-dir", 
        help="Specify the top level cylc run directory, if not as "
        "determined by site/user config on the suite host.",
        action="store", dest="run_dir", default=None )

conds = ("Valid triggering conditions to check for include: '" + 
         ("', '").join(sorted(CylcSuiteDBChecker.STATE_ALIASES.keys())[:-1]) + 
         "' and '" + sorted(CylcSuiteDBChecker.STATE_ALIASES.keys())[-1] + "'. ")
states = ("Valid states to check for include: '" + 
         ("', '").join(sorted(task_state.legal)[:-1]) + "' and '" + 
         sorted(task_state.legal)[-1] + "'.")

parser.add_option( "-S", "--status", 
        help="Specify a particular status or triggering condition to check for. " + conds + states,
        action="store", dest="status", default=None )
        
suite_poller.add_to_cmd_options(parser)

( options, args ) = parser.parse_args( remove_opts=["--db", "--debug"] )

suite = args[0]

# this only runs locally (use of --host results in re-invocation on the suite host account).
gcfg = get_global_cfg()
run_dir = options.run_dir or gcfg.get_host_item( 'run directory' )

spoller = suite_poller( "requested state",
        options.interval, options.max_polls,
        args={
            'suite'   : suite,
            'run_dir' : run_dir,
            'task'    : options.task,
            'cycle'   : options.cycle,
            'status'  : options.status
            })

if not spoller.connect(verbose=options.verbose):
    sys.exit( "ERROR: cannot connect to the suite DB" )

if options.status:
    if options.status in task_state.legal or options.status in CylcSuiteDBChecker.STATE_ALIASES:
        pass
    else:
        sys.exit( "ERROR: invalid status '" + options.status + "'" )

if options.status and options.task and options.cycle:
    """check a task status"""
    spoller.condition = options.status
    if not spoller.poll():
        sys.exit(1)
else:
    """just display query results"""
    spoller.checker.display_maps(
            spoller.checker.suite_state_query(
                task=options.task,
                cycle=options.cycle,
                status=options.status))

