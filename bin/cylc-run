#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2012 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, re, sys
import subprocess
from cylc.CylcOptionParsers import NoPromptOptionParser
from cylc.cycle_time import ct, CycleTimeError
from cylc.scheduler import scheduler
from cylc.hostname import hostname

global debug
debug = True

class start( scheduler ):
    def __init__( self ):
        usage = """cylc [control] run|start [options] SUITE [START]

Start a suite running at a specified initial cycle time.
(To restart a suite from a previous state, see 'cylc restart SUITE').

The following are all equivalent if no intercycle dependence exists:
  1/ Cold start (default)    : use special cold-start tasks 
  2/ Warm start (-w,--warm)  : assume a previous cycle 
  3/ Raw  start (-r,--raw)   : assume nothing

1/ COLD START -- at start up, insert designated cold-start tasks in the 
waiting state, to satisfy any initial dependence on a previous cycle.

2/ WARM START -- at start up, insert designated cold-start tasks in the
succeeded state, to stand in for a previous cycle (from a previous run).

3/ RAW START -- do not insert cold-start tasks at all.

NOTE: daemonize important suites with the POSIX nohup command:
  $ nohup cylc [con] run SUITE [START] > suite.out 2> suite.err &

NOTE: suites can be (re)started on remote hosts or other user accounts
if passwordless ssh is set up. The ssh tunnel will remain open to
receive the suite stdout and stderr streams. To control the running 
suite from the local host requires the suite passphrase to be installed.
If they exist /etc/profile and $HOME/.profile will be sourced on the
remote host prior to attempting to run the suite.""" 

        self.parser = NoPromptOptionParser( usage,
                [ """START                Initial cycle time. This is optional if defined in the 
                        suite.rc file, in which case the command line
                        takes priority (and a suite.rc final cycle time
                        will be ignored), and is not required if the
                        suite contains no cycling tasks.""" ])

        self.parser.add_option( "-w", "--warm", help="Warm start the suite",
        action="store_true", default=False, dest="warm" )

        self.parser.add_option( "-r", "--raw", help="Raw start the suite",
        action="store_true", default=False, dest="raw" )

        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        largs = len( self.args )
        if largs == 0:
            self.parser.error( "ERROR: suite group:name required." )
        elif largs > 2:
            self.parser.error( "ERROR: too many arguments." )

        self.start_time = None
        if largs == 2:
            try:
                self.start_time = ct( self.args[1] ).get()
            except CycleTimeError, x:
                raise SystemExit(x)

        scheduler.parse_commandline( self )

        if self.options.warm:
            self.banner[ "WARM START" ] = self.start_time
            self.load_tasks = self.load_tasks_warm
        elif self.options.raw:
            self.banner[ "RAW START" ] = self.start_time
            self.load_tasks = self.load_tasks_raw
        else:
            self.banner[ "COLD START" ] = self.start_time
            self.load_tasks = self.load_tasks_cold

        global debug
        debug = self.options.debug

    def load_tasks_cold( self ):
        if self.start_time:
            self.log.info( 'Cold Start ' + self.start_time )
            # set clock before using log (affects simulation mode only)
            self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )

        for name in task_list:
            if name in self.asynchronous_task_list:
                tag = '1' # asynchronous tasks start with tag = 1
            else:
                if self.start_time:
                    tag = self.start_time
                else:
                    # no initial cycle time: we can't load cycling tasks
                    continue
            itask = self.config.get_task_proxy( name, tag, 'waiting', stopctime=None, startup=True )
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.tag ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.pool.add( itask )

    def load_tasks_warm( self ):
        if self.start_time:
            self.log.info( 'Warm Start ' + self.start_time )
            # set clock before using log (affects simulation mode only)
            self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        startup_tasks = self.config.get_startup_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'cold start task list' CONFIG ITEM" )
        for name in task_list:
            # (startup=True is only for cold start)
            if name in self.asynchronous_task_list:
                tag = '1' # asynchronous tasks start with tag = 1
            else:
                if self.start_time:
                    tag = self.start_time
                else:
                    # no initial cycle time: we can't load cycling tasks
                    continue
            itask = self.config.get_task_proxy( name, tag, 'waiting', stopctime=None, startup=False )
            if name in coldstart_tasks:
                itask.log( 'WARNING', "warm start: starting in succeeded state" )
                itask.state.set_status( 'succeeded' )
                itask.prerequisites.set_all_satisfied()
                itask.outputs.set_all_completed()
            if name in startup_tasks:
                itask.log( 'WARNING', "This is a warm start: I will self-destruct." )
                itask.prepare_for_death()
                del itask
                continue
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.tag ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.pool.add( itask )

    def load_tasks_raw( self ):
        if self.start_time:
            self.log.info( 'Raw Start ' + self.start_time )
            # set clock before using log (affects simulation mode only)
            self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )

        coldstart_tasks = self.config.get_coldstart_task_list()
        startup_tasks = self.config.get_startup_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'cold start task list' CONFIG ITEM" )

        for name in task_list:
            # startup=True only for cold start
            if name in self.asynchronous_task_list:
                tag = '1' # asynchronous tasks start with tag = 1
            else:
                if self.start_time:
                    tag = self.start_time
                else:
                    # no initial cycle time: we can't load cycling tasks
                    continue
            itask = self.config.get_task_proxy( name, tag, 'waiting', stopctime=None, startup=False )
            if name in coldstart_tasks or name in startup_tasks:
                itask.log( 'WARNING', "This is a raw start: I will self-destruct." )
                itask.prepare_for_death()
                del itask
                continue
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.tag ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
                continue
            self.pool.add( itask )

if __name__ == '__main__':
    owner = None
    host = None
    remote = False
    argstr = ' '.join(sys.argv[1:])
    m = re.search( '(-o\s+|--owner=)(\w+)\s+', argstr )
    if m:
        owner = m.groups()[1]
        if owner != os.environ['USER']:
            remote = True
    n = re.search( '(--host=)(\w+)', argstr )
    if n:
        host = n.groups()[1]
        if host != shorthostname:
            remote = True
    if remote:
        sshopts = ''
        if owner: 
            sshopts = owner  + '@'
        if host:
            sshopts += host
        else:
            sshopts += 'localhost'

	command = "ssh " + sshopts + """ '\
if [[ -f /etc/profile ]]; then source /etc/profile; fi; \
if [[ -f .profile ]]; then source .profile; fi; cylc -v; \
cylc restart """ + ' '.join(sys.argv[1:]) + "'"

        try:
            popen = subprocess.Popen( command, shell=True )
            res = popen.wait()
            if res < 0:
                print >> sys.stderr, "command terminated by signal", res
            elif res > 0:
                print >> sys.stderr, "command failed", res
            else:
                # res == 0
                pass
        except OSError, e:
            # (note this would not catch background execution failure)
            print >> sys.stderr, "Job submission failed", e
            success = False
            raise
        else:
            # done (remote suite finished)
            sys.exit(0)

    # local invocation
    try:
        server = start()
    except Exception, x:
        if debug:
            raise
        else:
            print >> sys.stderr, x
            print >> sys.stderr, "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print >> sys.stderr, "ERROR CAUGHT, will clean up before exit"
        # this assumes no exceptions in shutdown():
        server.shutdown( 'ERROR: ' + str(x) )

        if debug:
            raise
        else:
            print >> sys.stderr, "THE ERROR WAS:"
            print >> sys.stderr, x
            print >> sys.stderr, "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # ?catch 'sys.exit(1)' and 'raise SystemExit("foo")'?
        print >> sys.stderr, "ERROR CAUGHT; will clean up before exit"
        server.shutdown('!cylc error - please report!')
        raise
    else:
        server.shutdown('Run completed normally')
