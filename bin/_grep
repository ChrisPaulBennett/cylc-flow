#!/usr/bin/env python

import os, re, sys
from config import config
from optparse import OptionParser
from collections import deque

lineprefix = ''

def include_files( suitedir, inf ):
    outf = []
    for line in inf:
        m = re.match( '\s*#include\s+([\w.]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if os.path.isfile(inc):
                #print "Inlining", inc
                outf.append('# ++++ INLINED INCLUDE FILE STARTS ++++ : ' + match + '\n')
                h = open(inc, 'rb')
                inc = h.readlines()
                h.close()
                # recursive inclusion
                outf.extend( include_files( suitedir, inc ))
                outf.append('# ++++ INLINED INCLUDE FILE ENDS ++++ : ' + match + '\n')
            else:
                raise SystemExit( "File not found: " + inc )
        else:
            # no match
            outf.append( line )
    return outf

def section_level( heading ):
    # e.g. foo => 0
    #     [foo] => 1
    #    [[foo]] => 2
    m = re.match( '^(\[+)', heading )
    if m:
        level = len( m.groups()[0] )
    else:
        level = 0
    return level

def print_heading( heading ):
    space = ' '
    indent = lineprefix
    for i in range( 1, section_level(heading) ):
        indent += space * 2
    print indent + heading

parser = OptionParser( """cylc grep [options] PATTERN SUITE 

Search for matches to PATTERN in a suite config file, which may contain 
include-files, and, optionally, in all files in the suite bin directory.

Matches are printed with their nested config file section heading and
file line number, even when include-files are used in the config file.

See also 'cylc edit'.

Arguments:
  PATTERN - a string, or Python-style regular expression.
  SUITE   - name of the suite to search.""")

parser.add_option( "-b", "--bin", help="Search all files in the suite "
        "bin directory as well as suite.rc (and any include-files)",
        action="store_true", default=False, dest="search_bin" )


( options, args ) = parser.parse_args()

if len(args) != 2:
    parser.error( "wrong number of arguments" )

pattern = args[0]
suite = args[1]

suiterc = config( suite ).get_filename()
suitedir = config( suite ).get_dirname()

if os.path.isfile( suiterc ):
    h = open( suiterc, 'rb' )
    lines0 = h.readlines()
    h.close()
    lines = include_files( suitedir, lines0 )
else:
    parser.error("Suite " + suite + " config file not found: " + suiterc )

sections = deque()

line_count = 1
inc_file = None
in_include_file = False

for line in lines:

    m = re.match('^# \+\+\+\+ INLINED INCLUDE FILE STARTS \+\+\+\+ : ([\w/.]+)', line )
    if m:
        inc_file = m.groups()[0]
        in_include_file = True
        inc_line_count = 0
        continue
 
    if not in_include_file:
        line_count += 1
    else:
        inc_line_count += 1
        m = re.match('^# \+\+\+\+ INLINED INCLUDE FILE ENDS \+\+\+\+ : ' + inc_file, line )
        if m:
            in_include_file = False
            inc_file = None
            continue

    m = re.match( '\s*(\[+\s*([\w ]+)\s*\]+)', line )
    if m:
        # new section heading detected
        heading = m.groups()[0] 
        level = section_level( heading )
        name = m.groups()[1]
        # unwind to the current section level
        while len(sections) > level - 1:
            sections.pop()
        sections.append( heading )
        continue

    if re.search( pattern, line ):
        # Found a pattern match.
        for heading in sections:
            # Print indented section headings
            print_heading( heading )
        # print the matching line
        if in_include_file:
            lineno = lineprefix + os.path.join( suitedir, inc_file ) + '[' + str(inc_line_count) + ']:' 
        else:
            lineno = lineprefix + suiterc + '[' + str(line_count) + ']:' 
        print lineno
        print line

if not options.search_bin:
    sys.exit(0)

# search files in suite bin directory
bin = os.path.join( suitedir, 'bin' )
for file in os.listdir( bin ):
    new_file = True
    h = open( os.path.join(bin,file), 'rb')
    contents = h.readlines()
    h.close()

    count = 0
    for line in contents:
        line = line.rstrip('\n')
        count += 1
        if re.search( pattern, line ):
            if new_file:
                print '\n', file
                new_file = False
            print '['+str(count)+']: ' + line
