#!/usr/bin/env python

import os, re, sys
from optparse import OptionParser
from collections import deque
from registration import localdb, centraldb, RegistrationError

def include_files( suitedir, inf ):
    outf = []
    for line in inf:
        m = re.match( '\s*%include\s+([\w/\.\-]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if os.path.isfile(inc):
                #print "Inlining", inc
                outf.append('++++ START INLINED INCLUDE FILE ' + match + '\n')
                h = open(inc, 'rb')
                inc = h.readlines()
                h.close()
                # recursive inclusion
                outf.extend( include_files( suitedir, inc ))
                outf.append('++++ END INLINED INCLUDE FILE ' + match + '\n')
            else:
                raise SystemExit( "File not found: " + inc )
        else:
            # no match
            outf.append( line )
    return outf

def section_level( heading ):
    # e.g. foo => 0
    #     [foo] => 1
    #    [[foo]] => 2
    m = re.match( '^(\[+)', heading )
    if m:
        level = len( m.groups()[0] )
    else:
        level = 0
    return level

def print_heading( heading ):
    print '>>>' + '->'.join(heading)
    #space = ' '
    #indent = '>>>'
    #for i in range( 1, section_level(heading) ):
    #    indent += space * 2
    #print indent + heading

parser = OptionParser( """cylc grep [options] PATTERN SUITE 

Find matches to PATTERN in the suite.rc file, and any contained
include-files, and in any files in the suite bin directory. For the
suite.rc and include-files, matches are reported by file line number and
suite section (even if include files are nested).

Note that the order of commandline arguments conforms to normal grep usage
('grep PATTERN FILE') not normal cylc command usage ('command SUITE ARGS').
However, if the second argument is not found to be a registered suite, an
attempt will be made to action the command with the arguments reversed.

For case insenstive matching use '(?i)PATTERN'.

See also: 
  cylc edit
  cylc inline 

Arguments:
  PATTERN - or Python-style regular expression or a raw string.
  SUITE   - name of the suite to search.""")

parser.add_option( "-x", help="Do not search in the suite bin directory",
        action="store_false", default=True, dest="search_bin" )

parser.add_option( "-c","--centraldb",
        help="Search a suite from the central database.",
        action="store_true", default=False, dest="central" )

( options, args ) = parser.parse_args()

if len(args) != 2:
    parser.error( "wrong number of arguments" )

arg0 = args[0]
arg1 = args[1]

# find location of the suite definition directory
if options.central:
    reg = centraldb()
else:
    reg = localdb()
reg.load_from_file()
try:
    reg.get( arg1 )
except RegistrationError,x:
    print x
    print "Trying reversed arguments..."
    try:
        reg.get( arg0 )
    except RegistrationError,x:
        raise SystemExit(x)
    else:
        # cylc grep SUITE PATTERN
        suite = arg0
        pattern = arg1
else:
    # cylc grep PATTERN SUITE
    suite = arg1
    pattern = arg0

suitedir, descr = reg.get( suite )
suiterc = os.path.join( suitedir, 'suite.rc' )

if os.path.isfile( suiterc ):
    h = open( suiterc, 'rb' )
    lines0 = h.readlines()
    h.close()
    lines = include_files( suitedir, lines0 )
else:
    parser.error("Suite " + suite + " config file not found: " + suiterc )

sections = deque( ['(top)'] )

line_count = 1
inc_file = None
in_include_file = False
prev_section_key = None
prev_file = None

for line in lines:

    m = re.match('^\+\+\+\+ START INLINED INCLUDE FILE ([\w/\.\-]+)', line )
    if m:
        inc_file = m.groups()[0]
        in_include_file = True
        inc_line_count = 0
        continue
 
    if not in_include_file:
        line_count += 1
    else:
        inc_line_count += 1
        m = re.match('^\+\+\+\+ END INLINED INCLUDE FILE ' + inc_file, line )
        if m:
            in_include_file = False
            inc_file = None
            continue

    m = re.match( '\s*(\[+\s*([\w ]+)\s*\]+)', line )
    if m:
        # new section heading detected
        heading = m.groups()[0] 
        level = section_level( heading )
        name = m.groups()[1]
        # unwind to the current section level
        while len(sections) > level - 1:
            sections.pop()
        sections.append( heading )
        continue

    if re.search( pattern, line ):
        # Found a pattern match.

        # Print the file name
        if in_include_file:
            curr_file = os.path.join( suitedir, inc_file ) 
            line_no = inc_line_count
        else:
            curr_file = suiterc
            line_no = line_count

        if curr_file != prev_file:
            prev_file = curr_file
            print "\nFILE:", curr_file

        # Print the nested section headings
        section_key = '->'.join( sections )
        if section_key != prev_section_key:
            prev_section_key = section_key
            #for heading in sections:
            #    print_heading( heading )
            print '   SECTION:', section_key

        # Print the pattern match, with line number
        print '      [' + str(line_no) + ']:', line.rstrip('\n')

if not options.search_bin:
    sys.exit(0)

# search files in suite bin directory
bin = os.path.join( suitedir, 'bin' )
if not os.path.isdir( bin ):
    print "\nSuite " + suite + " has no bin directory"
    sys.exit(0)

for file in os.listdir( bin ):
    if re.match( '^\.', file):
        # skip hidden dot-files
        # (e.g. vim editor temporary files)
        continue
    new_file = True
    h = open( os.path.join(bin,file), 'rb')
    contents = h.readlines()
    h.close()

    count = 0
    for line in contents:
        line = line.rstrip('\n')
        count += 1
        if re.search( pattern, line ):
            if new_file:
                print '\nFILE:', file
                new_file = False
            print '   ['+str(count)+']: ' + line
