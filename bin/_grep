#!/usr/bin/env python

import os, re, sys
from config import config
from optparse import OptionParser
from collections import deque

def include_files( suitedir, inf ):
    outf = []
    for line in inf:
        m = re.match( '\s*#include\s+([\w.]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if os.path.isfile(inc):
                #print "Inlining", inc
                outf.append('# ++++ INLINED INCLUDE FILE STARTS ++++ : ' + match + '\n')
                h = open(inc, 'rb')
                inc = h.readlines()
                h.close()
                # recursive inclusion
                outf.extend( include_files( suitedir, inc ))
                outf.append('# ++++ INLINED INCLUDE FILE ENDS ++++ : ' + match + '\n')
            else:
                raise SystemExit( "File not found: " + inc )
        else:
            # no match
            outf.append( line )
    return outf

def section_level( heading ):
    # e.g. foo => 0
    #     [foo] => 1
    #    [[foo]] => 2
    m = re.match( '^(\[+)', heading )
    if m:
        level = len( m.groups()[0] )
    else:
        level = 0
    return level

def print_heading( heading ):
    print '>>>' + '->'.join(heading)
    #space = ' '
    #indent = '>>>'
    #for i in range( 1, section_level(heading) ):
    #    indent += space * 2
    #print indent + heading

parser = OptionParser( """cylc grep [options] PATTERN SUITE 

Search for matches to PATTERN in a suite config file, which may contain 
include-files, and, optionally, in all files in the suite bin directory.

Matches are printed with their nested config file section heading and
file line number, even when include-files are used in the config file.

See also 'cylc edit'.

Arguments:
  PATTERN - a string, or Python-style regular expression.
  SUITE   - name of the suite to search.""")

parser.add_option( "-b", "--bin", help="Search all files in the suite "
        "bin directory as well as suite.rc (and any include-files)",
        action="store_true", default=False, dest="search_bin" )


( options, args ) = parser.parse_args()

if len(args) != 2:
    parser.error( "wrong number of arguments" )

pattern = args[0]
suite = args[1]

suiterc = config( suite ).get_filename()
suitedir = config( suite ).get_dirname()

if os.path.isfile( suiterc ):
    h = open( suiterc, 'rb' )
    lines0 = h.readlines()
    h.close()
    lines = include_files( suitedir, lines0 )
else:
    parser.error("Suite " + suite + " config file not found: " + suiterc )

sections = deque( ['(top)'] )

line_count = 1
inc_file = None
in_include_file = False
prev_section_key = None
prev_file = None

for line in lines:

    m = re.match('^# \+\+\+\+ INLINED INCLUDE FILE STARTS \+\+\+\+ : ([\w/.]+)', line )
    if m:
        inc_file = m.groups()[0]
        in_include_file = True
        inc_line_count = 0
        continue
 
    if not in_include_file:
        line_count += 1
    else:
        inc_line_count += 1
        m = re.match('^# \+\+\+\+ INLINED INCLUDE FILE ENDS \+\+\+\+ : ' + inc_file, line )
        if m:
            in_include_file = False
            inc_file = None
            continue

    m = re.match( '\s*(\[+\s*([\w ]+)\s*\]+)', line )
    if m:
        # new section heading detected
        heading = m.groups()[0] 
        level = section_level( heading )
        name = m.groups()[1]
        # unwind to the current section level
        while len(sections) > level - 1:
            sections.pop()
        sections.append( heading )
        continue

    if re.search( pattern, line ):
        # Found a pattern match.

        # Print the file name
        if in_include_file:
            curr_file = os.path.join( suitedir, inc_file ) 
            line_no = inc_line_count
        else:
            curr_file = suiterc
            line_no = line_count

        if curr_file != prev_file:
            prev_file = curr_file
            print "\nFILE:", curr_file

        # Print the nested section headings
        section_key = '->'.join( sections )
        if section_key != prev_section_key:
            prev_section_key = section_key
            #for heading in sections:
            #    print_heading( heading )
            print '   SECTION:', section_key

        # Print the pattern match, with line number
        print '      [' + str(line_no) + ']:', line.rstrip('\n')

if not options.search_bin:
    sys.exit(0)

# search files in suite bin directory
bin = os.path.join( suitedir, 'bin' )
for file in os.listdir( bin ):
    if re.match( '^\.', file):
        # skip hidden dot-files
        # (e.g. vim editor temporary files)
        continue
    new_file = True
    h = open( os.path.join(bin,file), 'rb')
    contents = h.readlines()
    h.close()

    count = 0
    for line in contents:
        line = line.rstrip('\n')
        count += 1
        if re.search( pattern, line ):
            if new_file:
                print '\nFILE:', file
                new_file = False
            print '   ['+str(count)+']: ' + line
