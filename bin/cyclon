#!/usr/bin/python

# USE $PYTHONPATH IN YOUR ENVIRONMENT TO MAKE AVAILABLE:
# 1/ cyclon 'src' module directory
# 2/ user config module (for user_config.py and task_classes.py)

import re
import os
import sys
import task
import pyrex
import config
import shutil
import profile
import manager
import logging
import datetime
import execution
import dead_letter
import remote_switch
import state_summary
import pimp_my_logger
import accelerated_clock 
from optparse import OptionParser

# auto-replace with version tag at build/install:
cyclon_version = "foo-bar-baz";

def clean_shutdown( pyro, reason ):
    log = logging.getLogger( 'main' )
    log.critical( 'System Halt: ' + reason )
    pyro.shutdown( True ) 

# MAIN PROGRAM
#---
def main( argv ):

    # construct a command line parser
    usage =  """
    %prog [options]
    %prog -r, --restart <filename>
    """
             
    parser = OptionParser( usage )

    parser.add_option( "-r", "--restart", 
            help="""Restart from the named state dump file, which is
assumed to be in the directory of the configured state dump file unless
an absolute path is supplied. Defaults to the configured state dump
file.""",
            action="store_true", default=False, dest="restart" )

    parser.add_option( "-d", "--dummy_mode", help="run in dummy (simulation) mode",
       action="store_true", default=False, dest="dummy_mode" )

    parser.add_option( "-f", "--fail", help="fail out a task in dummy mode",
        metavar="<name>%<YYYYMMDDHH>", action="store", dest="failout_task_id" )

    # get command line options and positional args
    ( options, args ) = parser.parse_args()

    print "__________________________________________________________"
    print
    print "      .       cyclon Dynamic Metascheduler        ."
    print "              version: " + cyclon_version
    print "      .         Hilary Oliver, NIWA, 2008         ."
    print "              See repository documentation"
    print "      .    Pyro nameserver required: 'pyro-ns'    ."
    print "__________________________________________________________"

    # load system configuration
    system_config = config.config()
    system_config.load()

    dummy_mode = False
    if system_config.get( 'dummy_mode' ):
        dummy_mode = True

    elif options.dummy_mode:
        system_config.put( 'dummy_mode', True )
        dummy_mode = True

    if dummy_mode:
        print
        print "RUNNING IN DUMMY MODE!"
        print

    # check restart
    restart_statedump = None
    if options.restart:
        if len( args ) == 0:
            # default
            pass
        elif len( args ) == 1:
            restart_statedump = args[0]
        else:
            parser.error( "too many arguments" )
            
    # set configured environment variables
    env = system_config.get('environment')
    for VAR in env.keys():
        os.environ[ VAR ] = env[ VAR ]

    # configure my pyro helper
    pyro = pyrex.pyrex( system_config.get( 'system_name' ))

    # system clock for accelerated time in dummy mode
    clock = accelerated_clock.clock( 
                system_config.get('alarm_seconds' ),
                system_config.get('start_time' ),
                system_config.get('dummy_clock_rate'), 
                system_config.get('dummy_clock_offset'),
                dummy_mode ) 

    pyro.connect( clock, 'clock' )

    # external task launcher
    launcher = execution.launcher( system_config, dummy_mode, options.failout_task_id )

    state_dump_file = system_config.get('state_dump_file')
    if os.path.exists( state_dump_file ):
        print "STATE DUMP BACKUP..."
        backup = state_dump_file + '.' + datetime.datetime.now().isoformat()
        print ' + ' + backup
        shutil.copyfile( state_dump_file, backup )

    print "CREATING MAIN LOG......."
    # create logging dirs
    if not os.path.exists( system_config.get('logging_dir') ):
       os.makedirs( system_config.get('logging_dir') )

    # top level logging
    log = logging.getLogger( 'main' )
    pimp_my_logger.pimp_it( log, 'main', system_config, dummy_mode, clock )

    # remote control switch
    remote = remote_switch.remote_switch( system_config, system_config.get('task_list') )
    pyro.connect( remote, 'remote' )

    # remotely accessible system state summary
    system_state = state_summary.state_summary( system_config, dummy_mode )
    pyro.connect( system_state, 'state_summary' )

    # dead letter box for remote use
    dead_letter_box = dead_letter.letter_box()
    pyro.connect( dead_letter_box, 'dead_letter_box' )

    # initialize the task manager from general config file or state dump
    god = manager.manager( system_config, dummy_mode, pyro, clock, options.restart, restart_statedump )

    print "\nBeginning task processing now\n"

    halt = False
    task.state_changed = True
    while True: # MAIN LOOP

        if remote.get_halt():
            # stop launching new tasks, but wait on running ones before
            # shutting down (otherwise they will generate screeds of
            # pyro-related error messages when they try to phone home).
            halt = True
            god.set_system_hold()

        if remote.get_hold():
            god.set_system_hold()

        if remote.get_resume():
            god.unset_system_hold()

        go_ahead = False
        if task.state_changed or clock.get_alarm():
            # PROCESS ALL TASKS whenever one has changed state
            # as a result of a remote task message coming in: 
            # then run, create new, and kill spent tasks
            #--

            god.regenerate_tasks()

            god.negotiate_dependencies()

            god.run_tasks( launcher )

            god.kill_spent_tasks()

            if remote.do_purge:
                log.info( 'pre-purge state dump: ' + god.dump_state( new_file = True ))
                god.purge( remote.purge_id, remote.purge_stop )
                remote.do_purge = False
                remote.purge_id = None
                remote.purge_stop = None
                go_ahead = True
            if remote.kill_ids:
                log.info( 'pre-kill state dump: ' + god.dump_state( new_file = True ))
                god.abdicate_and_kill( remote.kill_task_ids )
                remote.kill_ids = False
                remote.kill_task_ids = {}
                go_ahead = True
            if remote.kill_rt:
                log.info( 'pre-kill state dump: ' + god.dump_state( new_file = True ))
                god.abdicate_and_kill_rt( remote.kill_reftime )
                remote.kill_rt = False
                remote.kill_reftime = None
                go_ahead = True
            if remote.reset_a_task:
                log.info( 'pre-reset state dump: ' + god.dump_state( new_file = True ))
                god.reset_task( remote.reset_task_id )
                remote.reset_a_task = False
                remote.reset_task_id = None
                go_ahead = True
            if remote.insert_this:
                log.info( 'pre-insert state dump: ' + god.dump_state( new_file = True ))
                god.insertion( remote.insert_this )
                remote.insert_this = None
                go_ahead = True
            if remote.set_stop:
                god.set_stop_time( remote.stop_time )
                remote.set_stop = False
            if remote.set_hold:
                log.info( 'pre-hold state dump: ' + god.dump_state( new_file = True ))
                god.set_system_hold( remote.hold_time )
                remote.set_hold = False
            if remote.requisite_dump:
                god.dump_task_requisites( remote.dump_task_ids )
                remote.requisite_dump = False
                remote.dump_task_ids = {}

            god.dump_state()

            system_state.update( god.tasks, clock )

            if god.all_tasks_finished():
                clean_shutdown( pyro, "ALL TASKS FINISHED" )
                return

            if halt and god.no_tasks_running():
                clean_shutdown( pyro, "all running tasks finished" )
                return

        # REMOTE METHOD HANDLING; with no timeout and single-
        # threaded pyro, handleRequests() returns after one or
        # more remote method invocations are processed (these 
        # are not just task messages, hence the use of the
        # state_changed variable above).
        #--

        if go_ahead:
            task.state_changed = True
        else:
            task.state_changed = False

        # incoming task messages set task.state_changed = True 
        pyro.handleRequests( timeout = None )

     # END MAIN LOOP

if __name__ == "__main__":
    
    if False:
	# Do this to get performance profiling information
	# This method has a big performance hit itself, so
	# maybe there is a better way to do it?!)
        profile.run( 'main( sys.argv )' )
    else:
    	main( sys.argv )
