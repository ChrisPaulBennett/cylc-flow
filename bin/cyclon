#!/usr/bin/python

# USE $PYTHONPATH IN YOUR ENVIRONMENT TO MAKE AVAILABLE:
# 1/ cyclon 'src' module directory
# 2/ user config module (for user_config.py and task_classes.py)

import re
import os
import sys
import task
import pyrex
import config
import shutil
import profile
import manager
import logging
import datetime
import execution
import dead_letter
import remote_switch
import state_summary
import pimp_my_logger
import dummy_mode_clock 
from optparse import OptionParser

# auto-replace with version tag at build/install:
cyclon_version = "foo-bar-baz";

def clean_shutdown( pyro, reason ):
    log = logging.getLogger( 'main' )
    log.critical( 'System Halt: ' + reason )
    pyro.shutdown( True ) 

# MAIN PROGRAM
#---
def main( argv ):

    # construct a command line parser
    parser = OptionParser( "%prog [options]" )

    parser.add_option( "-r", "--restart", help="restart from state dump",
        action="store_true", default=False, dest="restart" )

    parser.add_option( "-f", "--fail", help="fail out a dummy task",
        metavar=" <name>%<YYYYMMDDHH>", action="store", dest="failout_task_id" )

    # get command line options and positional args
    ( options, args ) = parser.parse_args()

    print "__________________________________________________________"
    print
    print "      .       cyclon Dynamic Metascheduler       ."
    print "              version: " + cyclon_version
    print "      .         Hilary Oliver, NIWA, 2008         ."
    print "              See repository documentation"
    print "      .    Pyro nameserver required: 'pyro-ns'    ."
    print "__________________________________________________________"

    # load system configuration
    system_config = config.config()
    system_config.load()

    # external task launcher
    launcher = execution.launcher( system_config )

    # configure my pyro helper
    pyro = pyrex.pyrex( system_config.get( 'system_name' ))

    # dummy mode accelerated clock
    if system_config.get('dummy_mode'):
        dummy_clock = dummy_mode_clock.time_converter( system_config.get('start_time'), 
                                                       system_config.get('dummy_clock_rate'), 
                                                       system_config.get('dummy_clock_offset') ) 
        pyro.connect( dummy_clock, 'dummy_clock' )

    else:
        dummy_clock = None


    if options.failout_task_id:
        if not system_config.get('dummy_mode'):
            print 'ERROR: failout is only for dummy mode'
            sys.exit(1)
        # export a variable to be read by the dummy task script
        os.putenv( 'FAILOUT_TASK_ID', options.failout_task_id )

    state_dump_file = system_config.get('state_dump_file')
    if os.path.exists( state_dump_file ):
        print "STATE DUMP BACKUP..."
        backup = state_dump_file + '.' + datetime.datetime.now().isoformat()
        print ' + ' + backup
        shutil.copyfile( state_dump_file, backup )

    print "CREATING MAIN LOG......."
    # create logging dirs
    if not os.path.exists( system_config.get('logging_dir') ):
       os.makedirs( system_config.get('logging_dir') )

    # top level logging
    log = logging.getLogger( 'main' )
    pimp_my_logger.pimp_it( log, 'main', system_config, dummy_clock )

    # remote control switch
    remote_control = remote_switch.remote_switch( system_config, system_config.get('task_list') )
    pyro.connect( remote_control, 'remote_control' )

    # remotely accessible system state summary
    system_state = state_summary.state_summary( system_config )
    pyro.connect( system_state, 'state_summary' )

    # dead letter box for remote use
    dead_letter_box = dead_letter.letter_box()
    pyro.connect( dead_letter_box, 'dead_letter_box' )

    # initialize the task manager from general config file or state dump
    god = manager.manager( system_config, pyro, options.restart, dummy_clock )

    print "\nBeginning task processing now\n"

    task.state_changed = True
    while True: # MAIN LOOP

        if remote_control.system_halt_requested:
            clean_shutdown( pyro, 'remote request' )
            return

        if remote_control.get_hold():
            god.set_system_hold()

        if remote_control.get_resume():
            god.unset_system_hold()

        if task.state_changed:
            # PROCESS ALL TASKS whenever one has changed state
            # as a result of a remote task message coming in: 
            # then run, create new, and kill spent tasks
            #--

            god.regenerate_tasks()

            god.negotiate_dependencies()

            god.run_tasks( launcher )

            god.kill_spent_tasks()

            god.kill_lame_tasks()

            go_ahead = False
            if remote_control.go_psycho:
                print "KILLING NOW"
                god.abdicate_and_kill( remote_control.kill_task_id )
                remote_control.go_psycho = False
                go_ahead = True
 
            god.dump_state()

            system_state.update( god.tasks )

            if god.all_finished():
                clean_shutdown( pyro, "ALL TASKS FINISHED" )
                return

        # REMOTE METHOD HANDLING; with no timeout and single-
        # threaded pyro, handleRequests() returns after one or
        # more remote method invocations are processed (these 
        # are not just task messages, hence the use of the
        # state_changed variable above).
        #--
        if go_ahead:
            task.state_changed = True
        else:
            task.state_changed = False

        # incoming task messages set task.state_changed = True 
        pyro.handleRequests( timeout = None )

     # END MAIN LOOP

if __name__ == "__main__":
    
    if False:
	# Do this to get performance profiling information
	# This method has a big performance hit itself, so
	# maybe there is a better way to do it?!)
        profile.run( 'main( sys.argv )' )
    else:
    	main( sys.argv )
