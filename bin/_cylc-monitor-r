#!/usr/bin/python

"""
Display progress of currently running tasks objects.
TO DO: UPDATE THIS TO MATCH THE MONITOR FOR ALL PROCESSES.

For color terminal ASCII escape codes, see
http://ascii-table.com/ansi-escape-sequences.php
"""

# import standard Python modules
# cylc modules are imported after parsing the command line, so that we
# don't need access to a specific system to print the usage message.
import os
import re
import sys
import Pyro.core
from Pyro.errors import PyroError,NamingError,ProtocolError,TimeoutError,ConnectionClosedError
import datetime
from time import sleep
from string import ljust, rjust, split, upper, lower
from optparse import OptionParser

# construct a command line parser
parser = OptionParser( """cylc monitor-r [options] SYSTEM

A terminal-based monitor that displays information about task proxy
objects in the 'submitted' or 'running' states, in the target system. 

Note that this program does not monitor real running tasks. How to do
that necessarily depends on the job submission method used by the system
(and, potentially, by individual tasks in the system). 

If the target system is not running under your username you must use
--user=USERNAME so that the right Pyro nameserver group name can be
inferred (cylc uses USERNAME_SYSTEM).

arguments:
   SYSTEM               Registered name of the target system.""" ) 

parser.add_option( "-u", "--user",
        help="Owner of the target system (i.e. the username under which "
        "the scheduler is running). Defaults to your username, $USER.",
        metavar="USERNAME", action="store", dest="username" )

parser.add_option( "-n", "--nameserver",
        help="The Pyro nameserver host. Defaults to localhost. Depending "
        "on network configuration you may not need to use this option.",
        metavar="HOSTNAME", action="store", default="localhost",
        dest="pns_host" )

# get command line options and positional args
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

system_name = args[0]

# import cylc modules now (the reason for this is explained above)
import pyrex

header = 'key:   submitted   running'
header = '                          '
key = 'key:   \033[1;37;40msubmitted\033[0m   \033[1;37;42mrunning\033[0m'

if options.pns_host:
    pns_host = options.pns_host
else:
    parser.error( 'Required: Pyro nameserver hostname' )

# Pyro nameserver groupname of the target system
if options.username:
    username = options.username
else:
    username = os.environ[ 'USER' ] 

groupname = username + '_' + system_name

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover( pns_host )

if ns_groups.registered( groupname ):
    print "System: " + system_name
else:
    print "No " + groupname + " group registered with Pyro yet, waiting ..." 

ctrl_end = "\033[0m"

print
print "here we go ..."
sleep(2)

alerted = False
alerted2 = False
alerted3 = False
while True:
    # connect to remote state summary object
    try: 
        god = Pyro.core.getProxyForURI('PYRONAME://' + groupname + '.state_summary' )
        # timeout (sec) determines max wait for an answer from god.
        god._setTimeout(60)

    except ProtocolError:
        if not alerted:
            print "\n\033[1;37;41mfailed to connect" + ctrl_end 
            alerted = True
        #raise
        # if no connection, try again to connect
        sleep(1)
        continue

    except NamingError:
        if not alerted:
            print "\n\033[1;37;41mfailed to connect" + ctrl_end 
            alerted = True
        #raise
        # if no connection, try again to connect
        sleep(1)
        continue

    except KeyboardInterrupt:
        print 'ok, whatever'
        sys.exit(1)

    alerted = False

    while True:
        # continual redisplay loop

        # get state summary, task names, cycle times
        try:
            [glbl, states] = god.get_state_summary()

        except TimeoutError:
            if not alerted3:
                print "\n\033[1;37;41mconnection timed out" + ctrl_end
                alerted3 = True
            # if timed out, try again on same connection
            sleep(1)
            continue
            #break

        except ConnectionClosedError:
            if not alerted2:
                print "\n\033[1;37;41mconnection closed" + ctrl_end 
                alerted2 = True
            sleep(1)
            # if connection lost, try to reconnect
            break

        except ProtocolError:
            if not alerted:
                print "\n\033[1;37;41mfailed to connect" + ctrl_end 
                alerted = True
            #raise
            # wh'th'fu'?
            sleep(1)
            continue

        alerted2 = False
        alerted3 = False

        dt = glbl[ 'last_updated' ]
        rate = glbl[ 'dummy_clock_rate' ]
        dummy_mode = glbl[ 'dummy_mode' ]

        max_name_len = 0
        max_total_len = 0
        max_prog_len = 0
        lines = {}
        all_waiting = {}

        task_ids = states.keys()
        n_tasks_all = len( task_ids )
        task_ids.sort()

        for task_id in task_ids:
            [name, ctime] = split( task_id, "%" )
            
            state = states[ task_id ]['state']
            complete = states[ task_id ]['n_completed_outputs']
            total = states[ task_id ][ 'n_total_outputs' ]
            latest = states[ task_id ][ 'latest_message' ]

            if len( name ) > max_name_len:
                max_name_len = len( name )

            if len( str( total ) ) > max_total_len:
                max_total_len = len( str( total ) )

            if int( total ) > max_prog_len:
                max_prog_len = int( total )

        seen_time = {}
        seen_name = {}
        name_list = []

        for task_id in states.keys():
            [name, ctime] = split( task_id, "%" )
            
            if name not in seen_name.keys():
                seen_name[ name ] = True
                name_list.append( name )

            n_task_types = len( name_list )
            name_list.sort()
 
            state = states[ task_id ]['state']
            complete = states[ task_id ]['n_completed_outputs']
            total = states[ task_id ][ 'n_total_outputs' ]
            latest = states[ task_id ][ 'latest_message' ]

            prog = ""
            for k in range( 1, int(total) + 1):
                if k <= int(complete):
                    prog += "|"
                else:
                    prog += "-"

            prog = ljust( prog, max_prog_len + 1 )

            name = ljust( name, max_name_len + 1 )
            frac = rjust( str( complete) + "/" + str( total), 2 * max_total_len + 1 )

            ctrl_end = "\033[0m"

            if state == "running" or state == "submitted":
                if state == "running":
                    foo_start = "\033[1;37;42m"
                    bar_start = "\033[0;34m"
                elif state == "submitted":
                    foo_start = "\033[1;37;40m"
                    bar_start = "\033[0;34m"

                line = bar_start + "  " + ctrl_end + foo_start + name + ctrl_end + " " + bar_start + " " + frac + " " + prog + " " + latest + ctrl_end

                if ctime in lines.keys(): 
                    lines[ ctime ].append( line )

                else:
                    # first appearane of rt
                    lines[ ctime ] = [ line ]

        # sort cycle times using int( string )
        ctimes = lines.keys()
        ctimes.sort( key = int )

        # construct an array of lines to blit to the screen

        # MONITOR HEADER and CURRENT TIME
        blit = []
        # SYSTEM NAME, NUMBER OF TASKS, DUMMY MODE
        foo = header
        bar = system_name + '", ' + str( n_task_types ) + ' types, ' + str( n_tasks_all ) + ' tasks)'
        foo = re.sub( '^.{' + str(len('cylc!')) + '}', 'cylc!', foo )
        foo = re.sub( '.{' + str(len(system_name)) + '}$', system_name, foo )

        blit.append( '\033[1;37;43m' + foo + ctrl_end )
        blit.append( key )

        if dummy_mode:
            foo = 'DUMMY MODE:'
            bar = str(rate) + ' seconds = 1 hour' 
            baz = header
            baz = re.sub( '^.{' + str(len(foo)) + '}', foo, baz )
            baz = re.sub( '.{' + str(len(bar)) + '}$', bar, baz )
            blit.append( baz )

        blit.append( dt )
        for rt in ctimes:
            if len( lines[rt] ) != 0:
                blit.append( "\033[1;31m" + "__________" + "\033[0m" ) # red
                blit.append( "\033[1;31m" + rt + "\033[0m" )  # red

                for line in lines[rt]:
                    blit.append( line )

        os.system( "clear" )
        for line in blit:
            print line
        # sleep here determines minimum display time before trying to
        # update the information and redisplay it (?). 
        sleep(0.5)

    # sleep here determines how long to wait before trying to reconnect (?)
    sleep( 1 )
