#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


"""
Display progress of currently running tasks objects.
TO DO: UPDATE THIS TO MATCH THE MONITOR FOR ALL PROCESSES.

For color terminal ASCII escape codes, see
http://ascii-table.com/ansi-escape-sequences.php
"""

import pyrex
import os, re, sys
import Pyro.core
from Pyro.errors import PyroError,NamingError,ProtocolError,TimeoutError,ConnectionClosedError
from time import sleep
from string import ljust, rjust, split, upper, lower
from CylcOptionParsers import NoPromptOptionParser

parser = NoPromptOptionParser( """cylc monitor-r [options] SYSTEM

A terminal-based monitor that displays information about task proxy
objects in the 'submitted' or 'running' states, in the target system. 

THIS PROGRAM DOES NOT MONITOR THE REAL RUNNING TASKS (how to do
that depends on the job submission method used by each task).""" ) 

( options, args ) = parser.parse_args()

system_name = parser.get_system_name()
pns_host = parser.get_pns_host()
groupname = parser.get_groupname()

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover( pns_host )

if ns_groups.registered( groupname ):
    print "System: " + system_name
else:
    print "No " + groupname + " group registered with Pyro yet, waiting ..." 

header = 'key:   submitted   running'
header = '                          '
key = 'key:   \033[1;37;40msubmitted\033[0m   \033[1;37;42mrunning\033[0m'
ctrl_end = "\033[0m"

print
print "here we go ..."
sleep(2)

alerted = False
alerted2 = False
alerted3 = False
while True:
    # connect to remote state summary object
    try: 
        god = Pyro.core.getProxyForURI('PYRONAME://' + groupname + '.state_summary' )
        # timeout (sec) determines max wait for an answer from god.
        god._setTimeout(60)

    except ProtocolError:
        if not alerted:
            print "\n\033[1;37;41mfailed to connect" + ctrl_end 
            alerted = True
        #raise
        # if no connection, try again to connect
        sleep(1)
        continue

    except NamingError:
        if not alerted:
            print "\n\033[1;37;41mfailed to connect" + ctrl_end 
            alerted = True
        #raise
        # if no connection, try again to connect
        sleep(1)
        continue

    except KeyboardInterrupt:
        print 'ok, whatever'
        sys.exit(1)

    alerted = False

    while True:
        # continual redisplay loop

        # get state summary, task names, cycle times
        try:
            [glbl, states] = god.get_state_summary()

        except TimeoutError:
            if not alerted3:
                print "\n\033[1;37;41mconnection timed out" + ctrl_end
                alerted3 = True
            # if timed out, try again on same connection
            sleep(1)
            continue
            #break

        except ConnectionClosedError:
            if not alerted2:
                print "\n\033[1;37;41mconnection closed" + ctrl_end 
                alerted2 = True
            sleep(1)
            # if connection lost, try to reconnect
            break

        except ProtocolError:
            if not alerted:
                print "\n\033[1;37;41mfailed to connect" + ctrl_end 
                alerted = True
            #raise
            # wh'th'fu'?
            sleep(1)
            continue

        alerted2 = False
        alerted3 = False

        dt = glbl[ 'last_updated' ]
        rate = glbl[ 'dummy_clock_rate' ]
        dummy_mode = glbl[ 'dummy_mode' ]
        paused = glbl['paused']
        stopping = glbl['stopping']
        will_pause_at = glbl['will_pause_at']
        will_stop_at = glbl['will_stop_at']

        max_name_len = 0
        max_total_len = 0
        max_prog_len = 0
        lines = {}
        all_waiting = {}

        task_ids = states.keys()
        n_tasks_all = len( task_ids )
        task_ids.sort()

        for task_id in task_ids:
            [name, ctime] = split( task_id, "%" )
            
            total = states[ task_id ][ 'n_total_outputs' ]

            if len( name ) > max_name_len:
                max_name_len = len( name )

            if len( str( total ) ) > max_total_len:
                max_total_len = len( str( total ) )

            if int( total ) > max_prog_len:
                max_prog_len = int( total )

        seen_time = {}
        seen_name = {}
        name_list = []

        for task_id in states.keys():
            [name, ctime] = split( task_id, "%" )
            
            if name not in seen_name.keys():
                seen_name[ name ] = True
                name_list.append( name )

            n_task_types = len( name_list )
            name_list.sort()
 
            state = states[ task_id ]['state']
            complete = states[ task_id ]['n_completed_outputs']
            total = states[ task_id ][ 'n_total_outputs' ]
            latest = states[ task_id ][ 'latest_message' ]

            prog = ""
            for k in range( 1, int(total) + 1):
                if k <= int(complete):
                    prog += "|"
                else:
                    prog += "-"

            prog = ljust( prog, max_prog_len + 1 )

            name = ljust( name, max_name_len + 1 )
            frac = rjust( str( complete) + "/" + str( total), 2 * max_total_len + 1 )

            ctrl_end = "\033[0m"

            if state == "running" or state == "submitted":
                foo_start = ''
                bar_start = ''
                if state == "running":
                    foo_start = "\033[1;37;42m"
                    bar_start = "\033[0;34m"
                elif state == "submitted":
                    foo_start = "\033[1;37;40m"
                    bar_start = "\033[0;34m"

                line = bar_start + "  " + ctrl_end + foo_start + name + ctrl_end + " " + bar_start + " " + frac + " " + prog + " " + latest + ctrl_end

                if ctime in lines.keys(): 
                    lines[ ctime ].append( line )

                else:
                    # first appearane of rt
                    lines[ ctime ] = [ line ]

        # sort cycle times using int( string )
        ctimes = lines.keys()
        ctimes.sort( key = int )

        # construct an array of lines to blit to the screen

        # MONITOR HEADER and CURRENT TIME
        blit = []
        # SYSTEM NAME, NUMBER OF TASKS, DUMMY MODE
        foo = header
        bar = system_name + '", ' + str( n_task_types ) + ' types, ' + str( n_tasks_all ) + ' tasks)'
        foo = re.sub( '^.{' + str(len('cylc!')) + '}', 'cylc!', foo )
        foo = re.sub( '.{' + str(len(system_name)) + '}$', system_name, foo )

        blit.append( '\033[1;37;43m' + foo + ctrl_end )
        blit.append( key )

        if dummy_mode:
            foo = 'DUMMY MODE:'
            bar = str(rate) + ' seconds = 1 hour' 
            baz = header
            baz = re.sub( '^.{' + str(len(foo)) + '}', foo, baz )
            baz = re.sub( '.{' + str(len(bar)) + '}$', bar, baz )
            blit.append( baz )
        
        blit.append( dt )

        if stopping:
            #            'waiting submitted running done failed'
            foo = '-----------S-T-O-P-P-I-N-G'
        elif paused:
            #            'waiting submitted running done failed'
            foo = '---------------P-A-U-S-E-D'
        elif will_pause_at:
            #            'waiting submitted running done failed'
            #                                    YYYYMMDDHH                                
            foo = 'P-A-U-S-E--A-T--' + will_pause_at
        elif will_stop_at:
            #            'waiting submitted running done failed'
            #                                    YYYYMMDDHH                                
            foo = '--S-T-O-P--A-T--' + will_stop_at
        else:
            #            'waiting submitted running done failed'
            foo = '-------------R-U-N-N-I-N-G'
        
        blit.append( '\033[1;31m' + foo + ctrl_end )
                
        for rt in ctimes:
            if len( lines[rt] ) != 0:
                blit.append( "\033[1;31m" + "__________" + ctrl_end ) # red
                blit.append( "\033[1;31m" + rt + ctrl_end )  # red

                for line in lines[rt]:
                    blit.append( line )

        os.system( "clear" )
        for line in blit:
            print line
        # sleep here determines minimum display time before trying to
        # update the information and redisplay it (?). 
        sleep(0.5)

    # sleep here determines how long to wait before trying to reconnect (?)
    sleep( 1 )
