#!/usr/bin/python

import os
import re
import sys
import pyrex
import Pyro.core
from optparse import OptionParser
from time import sleep
from Pyro.errors import PyroError,NamingError

ctrl_end = "\033[0m"

def print_heading( strng ):
        print
        print strng
        underline = re.sub( '.', '-', strng )
        print underline

def prompt( reason ):

    msg =  reason + " '" + system_name + "'"
    if options.force:
        print msg + " NOW"
        return True

    response = raw_input( msg + ': ARE YOU SURE (y/n)? ' )
    if response == 'y':
        return True
    else:
        print "Aborted!"
        return False

# construct a command line parser
usage = "cylc control [options]"
parser = OptionParser( usage )

parser.add_option( "-n", "--name", 
	help="Control the named system",
        metavar="SYSTEM-NAME", action="store", dest="system_name" )

parser.add_option( "-f", "--force", 
	help="Do not ask for confirmation before acting",
        action="store_true", default=False, dest="force" )

parser.add_option( "--pause", 
	help="Pause the system now, i.e. do not launch any new tasks",
        action="store_true", default=False, dest="pause" )

parser.add_option( "--hold", 
	help="Tell the system to pause all tasks when the reach cycle time HOLD (YYYYMMHHDD)",
        metavar="HOLD", action="store", dest="hold_time" )

parser.add_option( "--resume", 
	help="Unhold/Resume the system",
        action="store_true", default=False, dest="resume" )

parser.add_option( "-s", "--shutdown", 
	help="Halt the system as soon as all running tasks have finished",
        action="store_true", default=False, dest="shutdown" )

parser.add_option( "--shutdown-now", 
	help="Halt the system NOW, even if tasks are still running",
        action="store_true", default=False, dest="shutdownnow" )

parser.add_option( "--stop-time", 
	help="Tell the system to shut down when all tasks have reached STOP (YYYYMMDDHH)",
        metavar="STOP", action="store", dest="stop_time" )

parser.add_option( "--reset", 
	help="Reset a (failed) task to the waiting state. TASK_ID = 'NAME%YYYYMMDDHH'",
        metavar="TASK_ID", action="store", dest="reset_id" )

parser.add_option( "--kill", 
	help="Kill the named task(s) or all waiting tasks at the given cycle time "
        "(after spawing their successors if necessary)",
        metavar="[NAME1,NAME2,...%]YYYYMMDDHH", 
        action="store", dest="kill_task_id" )

parser.add_option( "--purge", 
	help="Kill a task and, recursively, all of its dependents through to a given cycle time"
	"TASK_ID = NAME%YYYYMMDDHH, STOP = YYYYMMDDHH",
        metavar="TASK_ID,STOP", 
        action="store", dest="purge" )

parser.add_option( "--insert", help="Insert a new task or task group into a running system.",
        metavar="[GROUP:]NAME%YYYYMMDDHH", action="store", dest="insert_task_id" )

parser.add_option( "--dump", 
        help="Show if the named tasks prerequisites are satisfied yet, and if their outputs are"
	"completed yet.",
        metavar="NAME1,NAME2,...%YYYYMMDDHH", 
        action="store", dest="dump_task_id" )

parser.add_option( "--describe", 
        help="Get the description of the named task(s)",
        metavar="NAME1,NAME2,...", 
        action="store", dest="describe_names" )

verbosity_choices = ['debug','info', 'warning', 'error', 'critical'] 
parser.add_option( "-v", "--verbosity",
        help="set verbosity: " + ', '.join(verbosity_choices),
        action="store", 
        choices=verbosity_choices,
        dest="verbosity" )

parser.add_option( "--bump", 
	help= "Bump the system (i.e. invoke the task processing loop)"
	"even if nothing is happening at the moment.",
        action="store_true", default=False, dest="bump" )

#if len( sys.argv ) == 1:
#    # no options or args supplied
#    parser.print_help()
#    sys.exit(1)

# get command line options and positional args
( options, args ) = parser.parse_args()

#if len( args ) > 1:
#    parser.error( "incorrect number of arguments" )

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover()

system_name = options.system_name
if ns_groups.registered( system_name ):
    #print "system: " + system_name
    pass
else:
    print "WARNING: no " + system_name + " registered yet ..." 
    ns_groups.print_info()

    # print available systems and exit
    print
    parser.print_help()
    print
    ns_groups.print_info()
    print
    sys.exit(1)


try:
    # connect to the remote switch object in cylc
    control = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.' + 'remote' )
except NamingError:
    print "\n\033[1;37;41mfailed to connect" + ctrl_end 
    raise SystemExit

if options.reset_id:
    if prompt( 'Reset ' + options.reset_id + ' to the waiting state for' ):
        control.reset_to_waiting( options.reset_id )

if options.pause:
    if prompt( 'Pause' ):
        control.hold()

if options.hold_time:
    if prompt( 'Set hold time ' + options.hold_time + ' for'):
        control.set_hold_time( options.hold_time )

if options.stop_time:
    if prompt( 'Set stop time ' + options.stop_time + ' for'):
        control.set_stop_time( options.stop_time )

if options.resume:
    if prompt( 'Resume' ):
        control.resume()

if options.shutdown:
    if prompt( 'Shutdown' ):
        control.shutdown()

if options.shutdownnow:
    if prompt( 'Shutdown NOW' ):
        control.shutdown_now()

if options.verbosity:
    control.set_verbosity( options.verbosity )

if options.insert_task_id:
    if prompt( 'Insert ' + options.insert_task_id + ' in' ):
        control.insert( options.insert_task_id )

if options.describe_names:

    print
    print 'system: ' + system_name

    # retrieve and print task class descriptions
    if re.search( ',', options.describe_names ):
        # multiple names
        names = options.describe_names.split( ',' )
    else:
        # one name
        names = [ options.describe_names ]

    # strip off reference time, if given
    names = [ re.sub( '%.*', '', name ) for name in names ]

    info = control.get_task_info( names )
    for name in info.keys():
        print
        print name + ':'
        for line in info[name]:
            print '  ' + line
    print

if options.dump_task_id:
    [ tmp, reftime ] = options.dump_task_id.split( '%' )
    if re.search( ',', tmp ):
        names = tmp.split( ',' )
    else:
        names = [ tmp ]

    ids = []
    for name in names:
        id = name + '%' + reftime
        ids.append( id )

    result = control.get_task_requisites( ids )

    print
    print 'System:  ' + system_name
    print 'Task ID: ' + id
    print
    print ' + => prerequisite satisfied, or output completed' 
    print ' - => prerequisite NOT satisfied, or output NOT completed' 

    for id in ids:
        if id not in result.keys():
            print
            print 'ERROR: task not found'

    for id in result.keys():
        [ pre, out, extra_info ] = result[ id ]

        print_heading( 'Prerequisites:')
        if len( pre ) == 0:
            print '(None)'
        for item in pre:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        print_heading( 'Outputs:' )
        if len( out ) == 0:
            print '(None)'
        for item in out:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        if len( extra_info.keys() ) > 0:
            print_heading( 'Other:' )
            for item in extra_info:
                print item, '...', extra_info[ item ]

    print

if options.purge:
    if prompt( 'Purge ' + options.purge + ' in' ):

        [ task_id, stop_purge_time ] = options.purge.split( ',' )
        control.purge( task_id, stop_purge_time )

if options.kill_task_id:
    if prompt( 'abdicate and kill ' + options.kill_task_id + ' in' ):

        if not re.search( '%', options.kill_task_id ):
            # kill all tasks in given reference time
            # TO DO: check validity of given ref time
            reftime = options.kill_task_id
            control.abdicate_and_kill_rt( reftime )

        else:

            [ tmp, reftime ] = options.kill_task_id.split( '%' )
            if re.search( ',', tmp ):
                names = tmp.split( ',' )
            else:
                names = [ tmp ]

            ids = []
            for name in names:
                id = name + '%' + reftime
                ids.append( id )

            control.abdicate_and_kill( ids )

        print "WARNING: you may also need to kill the REAL task(s)"

if options.bump:
    control.nudge()
