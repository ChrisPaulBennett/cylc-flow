#!/usr/bin/python

# import standard Python modules
# cylc modules are imported after parsing the command line, so that we
# don't need access to a specific system to print the usage message.
import os
import re
import sys
import Pyro.core
from optparse import OptionParser
from time import sleep
from Pyro.errors import PyroError,NamingError

ctrl_end = "\033[0m"

def print_heading( strng ):
        print
        print strng
        underline = re.sub( '.', '-', strng )
        print underline

def prompt( reason ):

    msg =  reason + " '" + system_name + "'"
    if options.force:
        print msg + " NOW"
        return True

    response = raw_input( msg + ': ARE YOU SURE (y/n)? ' )
    if response == 'y':
        return True
    else:
        print "Aborted!"
        return False

# construct a command line parser
usage = """cylc control [options] SYSTEM 

Interact with (interrogate or control) a running cylc system.

If the target system is not running under your username you must use
--user=USERNAME so that the right Pyro nameserver group name can be
inferred (cylc uses USERNAME_SYSTEM).

arguments:
   SYSTEM               Registered name of the target system.""" 

parser = OptionParser( usage )

parser.add_option( "-u", "--username",
        help="Owner of the target system (i.e. the username under which "
        "the scheduler is running), defaults to $USER. WARNING: this "
        "allows others to control your systems, and you theirs; you "
        "may want to disable this option.",
        metavar="USERNAME", action="store", dest="username" )

parser.add_option( "-n", "--nameserver",
        help="The Pyro nameserver host. Defaults to localhost. Depending "
        "on network configuration you may not need to use this option.",
        metavar="HOSTNAME", action="store", default="localhost",
        dest="pns_host" )

parser.add_option( "-f", "--force",
        help="Force: do not ask for confirmation before acting.",
        action="store_true", default=False, dest="force" )

parser.add_option( "-p", "--pause", 
        help="Pause the system, i.e. do not launch any new tasks.",
        action="store_true", default=False, dest="pause" )

parser.add_option( "--pause-at", 
        help="Pause the system when all tasks have reached cycle time CYCLE",
        metavar="CYCLE", action="store", dest="hold_time" )

parser.add_option( "-r", "--resume", 
        help="Resume (unpause) the system.",
        action="store_true", default=False, dest="resume" )

parser.add_option( "-s", "--stop", 
        help="Shutdown the system as soon as all tasks that are currently "
        "running have finished.",
        action="store_true", default=False, dest="shutdown" )

parser.add_option( "--stop-now", 
        help="Shutdown the system NOW, even if some tasks are still running. "
        "THIS DOES NOT KILL RUNNING EXTERNAL TASKS",
        action="store_true", default=False, dest="shutdownnow" )

parser.add_option( "--stop-at", 
        help="Do not launch any new tasks beyond cycle time CYCLE, and "
        "shutdown the system as soon as all tasks prior to that time"
        "have finished running.",
        metavar="CYCLE", action="store", dest="stop_time" )

parser.add_option( "--reset-task", 
        help="Reset a task to the 'waiting' state. Use this to get a failed "
        "task to re-run after fixing the problem that caused it to fail.",
        metavar="NAME%CYCLE", action="store", dest="reset_id" )

parser.add_option( "--spawn-and-die", 
        help="Force one or more tasks at a particular cycle time to spawn and die.",
        metavar="[NAME1,NAME2,...%]CYCLE", 
        action="store", dest="kill_task_id" )

parser.add_option( "--purge", 
        help="Force task NAME%CYCLE to spawn and die, then force every "
        "task that depends on its outputs to spawn and die, and then "
        "force every task that depends on their outputs to spawn and "
        "die, and so on through to cycle time STOP.",
        metavar="NAME%CYCLE,STOP", 
        action="store", dest="purge" )

parser.add_option( "--insert", 
        help="Insert a new TASK or TASK GROUP into a running system.",
        metavar="NAME%CYCLE", action="store", dest="insert_task_id" )

parser.add_option( "--dump", 
        help="Display the current status of one or more task's prerequisites, "
        "outputs, and any other information deemed relevant to scheduling.",
        metavar="NAME1,NAME2,...%CYCLE", 
        action="store", dest="dump_task_id" )

parser.add_option( "--describe-task", 
        help="Display the description of one or more task types"
        "(no cycle time required).",
        metavar="NAME1,NAME2,...", 
        action="store", dest="describe_names" )

verbosity_choices = ['debug','info', 'warning', 'error', 'critical'] 
parser.add_option( "-v", "--verbosity",
        help="change the system's logging verbosity: " + ', '.join(verbosity_choices),
        action="store", 
        choices=verbosity_choices,
        dest="verbosity" )

parser.add_option( "--nudge", 
        help= "Nudge the system. When not running the task processing loop on "
        "on a timeout it may be possible for cylc to get \"stuck\"; nudging "
        "invokes the task processing loop and gets things moving again.",
        action="store_true", default=False, dest="bump" )

# get command line options and positional args
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

system_name = args[0]

if not options.pns_host:
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host

# Pyro nameserver groupname of the target system
if options.username:
    username = options.username
else:
    username = os.environ[ 'USER' ] 

groupname = username + '_' + system_name

# import cylc modules now (the reason for this is explained above)
import pyrex

#if len( args ) > 1:
#    parser.error( "incorrect number of arguments" )

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover( pns_host )

if ns_groups.registered( groupname ):
    #print "system: " + system_name
    pass
else:
    print "WARNING: no " + groupname + " registered yet ..." 
    ns_groups.print_info()

    # print available systems and exit
    print
    parser.print_help()
    print
    ns_groups.print_info()
    print
    sys.exit(1)


try:
    # connect to the remote switch object in cylc
    control = Pyro.core.getProxyForURI('PYRONAME://' + pns_host + '/' + groupname + '.' + 'remote' )
except NamingError:
    print "\n\033[1;37;41mfailed to connect" + ctrl_end 
    raise SystemExit

if options.reset_id:
    if prompt( 'Reset ' + options.reset_id + ' to the waiting state for' ):
        control.reset_to_waiting( options.reset_id )

if options.pause:
    if prompt( 'Pause' ):
        control.hold()

if options.hold_time:
    if prompt( 'Set hold time ' + options.hold_time + ' for'):
        control.set_hold_time( options.hold_time )

if options.stop_time:
    if prompt( 'Set stop time ' + options.stop_time + ' for'):
        control.set_stop_time( options.stop_time )

if options.resume:
    if prompt( 'Resume' ):
        control.resume()

if options.shutdown:
    if prompt( 'Shutdown' ):
        control.shutdown()

if options.shutdownnow:
    if prompt( 'Shutdown NOW' ):
        control.shutdown_now()

if options.verbosity:
    control.set_verbosity( options.verbosity )

if options.insert_task_id:
    if prompt( 'Insert ' + options.insert_task_id + ' in' ):
        control.insert( options.insert_task_id )

if options.describe_names:

    print
    print 'system: ' + system_name

    # retrieve and print task class descriptions
    if re.search( ',', options.describe_names ):
        # multiple names
        names = options.describe_names.split( ',' )
    else:
        # one name
        names = [ options.describe_names ]

    # strip off cycle time, if given
    names = [ re.sub( '%.*', '', name ) for name in names ]

    info = control.get_task_info( names )
    for name in info.keys():
        print
        print name + ':'
        for line in info[name]:
            print '  ' + line
    print

if options.dump_task_id:
    [ tmp, ctime ] = options.dump_task_id.split( '%' )
    if re.search( ',', tmp ):
        names = tmp.split( ',' )
    else:
        names = [ tmp ]

    ids = []
    for name in names:
        id = name + '%' + ctime
        ids.append( id )

    result = control.get_task_requisites( ids )

    print
    print 'System:  ' + system_name
    print 'Task ID: ' + id
    print
    print ' + => prerequisite satisfied, or output completed' 
    print ' - => prerequisite NOT satisfied, or output NOT completed' 

    for id in ids:
        if id not in result.keys():
            print
            print 'ERROR: task not found'

    for id in result.keys():
        [ pre, out, extra_info ] = result[ id ]

        print_heading( 'Prerequisites:')
        if len( pre ) == 0:
            print '(None)'
        for item in pre:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        print_heading( 'Outputs:' )
        if len( out ) == 0:
            print '(None)'
        for item in out:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        if len( extra_info.keys() ) > 0:
            print_heading( 'Other:' )
            for item in extra_info:
                print item, '...', extra_info[ item ]

    print

if options.purge:
    if prompt( 'Purge ' + options.purge + ' in' ):

        [ task_id, stop_purge_time ] = options.purge.split( ',' )
        control.purge( task_id, stop_purge_time )

if options.kill_task_id:
    if prompt( 'spawn and die ' + options.kill_task_id + ' in' ):

        if not re.search( '%', options.kill_task_id ):
            # kill all tasks in given cycle time
            # TO DO: check validity of given cycle time
            ctime = options.kill_task_id
            control.spawn_and_die_rt( ctime )

        else:

            [ tmp, ctime ] = options.kill_task_id.split( '%' )
            if re.search( ',', tmp ):
                names = tmp.split( ',' )
            else:
                names = [ tmp ]

            ids = []
            for name in names:
                id = name + '%' + ctime
                ids.append( id )

            control.spawn_and_die( ids )

        print "WARNING: you may also need to kill the REAL task(s)"

if options.bump:
    control.nudge()
