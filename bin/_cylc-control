#!/usr/bin/python

# import standard Python modules
# cylc modules are imported after parsing the command line, so that we
# don't need access to a specific system to print the usage message.
import os
import re
import sys
import Pyro.core
from optparse import OptionParser
from time import sleep
from Pyro.errors import PyroError,NamingError

ctrl_end = "\033[0m"

def print_heading( strng ):
        print
        print strng
        underline = re.sub( '.', '-', strng )
        print underline

def prompt( reason ):

    msg =  reason + " '" + system_name + "'"
    if options.force:
        print msg + " NOW"
        return True

    response = raw_input( msg + ': ARE YOU SURE (y/n)? ' )
    if response == 'y':
        return True
    else:
        print "Aborted!"
        return False

# construct a command line parser
usage = """cylc control -s NAME [-n HOSTNAME] [options]

Interrogate or control the cylc instance running system NAME via the
Pyro nameserver on HOSTNAME. 

Below, START, STOP, and TIME, are cycle times (YYYYMMDDHH).

Note that tasks are uniquely identified by NAME%YYYYMMDDHH."""

parser = OptionParser( usage )

parser.add_option( "-s", 
	help="Name of the target system.",
        metavar="NAME", action="store", dest="system_name" )

parser.add_option( "-u", 
        help="Username, defaults to $USER. Use this option if the target "
        "system is running under another username. (Cylc's Pyro nameserver "
        "groupnames are constructed from username and system name). WARNING: "
        "THIS ALLOWS YOU TO CONTROL OTHER USER'S SYSTEMS, AND VICE VERSA. "
        "SYSADMINS MAY WANT TO DISABLE THIS OPTION.",
        metavar="USER", action="store", dest="username" )

parser.add_option( "-n", 
        help="Hostname of the machine running the Pyro nameserver, "
        "defaults to 'localhost'.",
        metavar="HOSTNAME", action="store", default='localhost',
        dest="pns_host" )

parser.add_option( "-f",
        help="Force: do not ask for confirmation before acting.",
        action="store_true", default=False, dest="force" )

parser.add_option( "--pause", 
        help="Pause the system, i.e. do not launch any new tasks.",
        action="store_true", default=False, dest="pause" )

parser.add_option( "--pause-at", 
        help="Pause the system when all tasks have reached TIME",
        metavar="TIME", action="store", dest="hold_time" )

parser.add_option( "-r", "--resume", 
        help="Resume (unpause) the system.",
        action="store_true", default=False, dest="resume" )

parser.add_option( "--stop", 
        help="Shutdown the system as soon as all tasks that are currently "
        "running have finished.",
        action="store_true", default=False, dest="shutdown" )

parser.add_option( "--stop-now", 
        help="Shutdown the system NOW, even if some tasks are still running. "
        "THIS DOES NOT KILL RUNNING EXTERNAL TASKS",
        action="store_true", default=False, dest="shutdownnow" )

parser.add_option( "--stop-at", 
        help="Do not launch any new tasks beyond TIME, and shutdown the system "
        "as soon as all tasks prior to that time have finished running.",
        metavar="TIME", action="store", dest="stop_time" )

parser.add_option( "--reset", 
        help="Reset a task to the 'waiting' state. Use this to get a failed "
        "task to re-run after fixing the problem that caused it to fail.",
        metavar="NAME%TIME", action="store", dest="reset_id" )

parser.add_option( "--spawn-and-die", 
        help="Force one or more tasks at a particular cycle time to spawn and die.",
        metavar="[NAME1,NAME2,...%]TIME", 
        action="store", dest="kill_task_id" )

parser.add_option( "--recursive-purge", 
        help="Force a task to spawn and die, then force every task that depends "
        "on its outputs to spawn and die, and then force every task that depends "
        "on their outputs to spawn and die, and so on, through to time STOP.",
        metavar="NAME%TIME,STOP", 
        action="store", dest="purge" )

parser.add_option( "--insert", 
        help="Insert a new TASK or TASK GROUP into a running system.",
        metavar="NAME%TIME", action="store", dest="insert_task_id" )

parser.add_option( "--dump", 
        help="Display the current status of one or more task's prerequisites "
        "and outputs, and any other information deemed relevant to scheduling.",
        metavar="NAME1,NAME2,...%YYYYMMDDHH", 
        action="store", dest="dump_task_id" )

parser.add_option( "--describe", 
        help="Display the description of one or more task types (no TIME required!).",
        metavar="NAME1,NAME2,...", 
        action="store", dest="describe_names" )

verbosity_choices = ['debug','info', 'warning', 'error', 'critical'] 
parser.add_option( "-v", "--verbosity",
        help="change the system's logging verbosity: " + ', '.join(verbosity_choices),
        action="store", 
        choices=verbosity_choices,
        dest="verbosity" )

parser.add_option( "--nudge", 
        help= "Nudge the system. When not running the task processing loop on "
        "on a timeout it may be possible for cylc to get \"stuck\"; nudging "
        "invokes the task processing loop and gets things moving again.",
        action="store_true", default=False, dest="bump" )

#if len( sys.argv ) == 1:
#    # no options or args supplied
#    parser.print_help()
#    sys.exit(1)

# get command line options and positional args
( options, args ) = parser.parse_args()

if not options.system_name:
    parser.error( "Required: system name" )
else:
    system_name = options.system_name

if not options.pns_host:
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host

# Pyro nameserver groupname of the target system
if options.username:
    username = options.username
else:
    username = os.environ[ 'USER' ] 

groupname = username + '_' + system_name

# import cylc modules now (the reason for this is explained above)
import pyrex

#if len( args ) > 1:
#    parser.error( "incorrect number of arguments" )

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover( pns_host )

if ns_groups.registered( groupname ):
    #print "system: " + system_name
    pass
else:
    print "WARNING: no " + groupname + " registered yet ..." 
    ns_groups.print_info()

    # print available systems and exit
    print
    parser.print_help()
    print
    ns_groups.print_info()
    print
    sys.exit(1)


try:
    # connect to the remote switch object in cylc
    control = Pyro.core.getProxyForURI('PYRONAME://' + pns_host + '/' + groupname + '.' + 'remote' )
except NamingError:
    print "\n\033[1;37;41mfailed to connect" + ctrl_end 
    raise SystemExit

if options.reset_id:
    if prompt( 'Reset ' + options.reset_id + ' to the waiting state for' ):
        control.reset_to_waiting( options.reset_id )

if options.pause:
    if prompt( 'Pause' ):
        control.hold()

if options.hold_time:
    if prompt( 'Set hold time ' + options.hold_time + ' for'):
        control.set_hold_time( options.hold_time )

if options.stop_time:
    if prompt( 'Set stop time ' + options.stop_time + ' for'):
        control.set_stop_time( options.stop_time )

if options.resume:
    if prompt( 'Resume' ):
        control.resume()

if options.shutdown:
    if prompt( 'Shutdown' ):
        control.shutdown()

if options.shutdownnow:
    if prompt( 'Shutdown NOW' ):
        control.shutdown_now()

if options.verbosity:
    control.set_verbosity( options.verbosity )

if options.insert_task_id:
    if prompt( 'Insert ' + options.insert_task_id + ' in' ):
        control.insert( options.insert_task_id )

if options.describe_names:

    print
    print 'system: ' + system_name

    # retrieve and print task class descriptions
    if re.search( ',', options.describe_names ):
        # multiple names
        names = options.describe_names.split( ',' )
    else:
        # one name
        names = [ options.describe_names ]

    # strip off cycle time, if given
    names = [ re.sub( '%.*', '', name ) for name in names ]

    info = control.get_task_info( names )
    for name in info.keys():
        print
        print name + ':'
        for line in info[name]:
            print '  ' + line
    print

if options.dump_task_id:
    [ tmp, ctime ] = options.dump_task_id.split( '%' )
    if re.search( ',', tmp ):
        names = tmp.split( ',' )
    else:
        names = [ tmp ]

    ids = []
    for name in names:
        id = name + '%' + ctime
        ids.append( id )

    result = control.get_task_requisites( ids )

    print
    print 'System:  ' + system_name
    print 'Task ID: ' + id
    print
    print ' + => prerequisite satisfied, or output completed' 
    print ' - => prerequisite NOT satisfied, or output NOT completed' 

    for id in ids:
        if id not in result.keys():
            print
            print 'ERROR: task not found'

    for id in result.keys():
        [ pre, out, extra_info ] = result[ id ]

        print_heading( 'Prerequisites:')
        if len( pre ) == 0:
            print '(None)'
        for item in pre:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        print_heading( 'Outputs:' )
        if len( out ) == 0:
            print '(None)'
        for item in out:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        if len( extra_info.keys() ) > 0:
            print_heading( 'Other:' )
            for item in extra_info:
                print item, '...', extra_info[ item ]

    print

if options.purge:
    if prompt( 'Purge ' + options.purge + ' in' ):

        [ task_id, stop_purge_time ] = options.purge.split( ',' )
        control.purge( task_id, stop_purge_time )

if options.kill_task_id:
    if prompt( 'spawn and die ' + options.kill_task_id + ' in' ):

        if not re.search( '%', options.kill_task_id ):
            # kill all tasks in given cycle time
            # TO DO: check validity of given cycle time
            ctime = options.kill_task_id
            control.spawn_and_die_rt( ctime )

        else:

            [ tmp, ctime ] = options.kill_task_id.split( '%' )
            if re.search( ',', tmp ):
                names = tmp.split( ',' )
            else:
                names = [ tmp ]

            ids = []
            for name in names:
                id = name + '%' + ctime
                ids.append( id )

            control.spawn_and_die( ids )

        print "WARNING: you may also need to kill the REAL task(s)"

if options.bump:
    control.nudge()
