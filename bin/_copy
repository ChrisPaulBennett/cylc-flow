#!/usr/bin/env python

from mkdir_p import mkdir_p
import os, re, sys
from shutil import copytree
from optparse import OptionParser
from registration import localdb, regsplit, RegistrationError
from regprompt import prompt

parser = OptionParser( usage = """cylc [db] copy [OPTIONS] [ARGUMENTS]

Copy registered suites.

1/ cylc [db] copy FROM TO DIR
copy one suite registered as FROM to TO

2/ cylc [db] copy -a,--all FROMGROUP TOGROUP TOPDIR
copy all members of a registration group

3/ cylc [db] copy [FILTER OPTIONS] TOPDIR
Interactively copy suites selected by filtering on group and name.

Arguments:
    FROM, TO   - registrations, GROUP:NAME or NAME (default group).
    DIR    - destination for the copied suite definition (must not exist).
    TOPDIR - top level directory for copied suite definitions.""" )

parser.add_option( "-g", "--group",
        help="Group filter Regular Expression.",
        metavar="RE", action="store", default=None, dest="groupfilt" )

parser.add_option( "-n", "--name",
        help="Name filter Regular Expression.",
        metavar="RE", action="store", default=None, dest="namefilt" )

parser.add_option( "-a", "--all",
        help="Copy all members of a group.",
        action="store_true", default=False, dest="groupcopy" )

( options, args ) = parser.parse_args()

if len(args) != 1 and len(args) != 3:
    parser.error('Illegal number of arguments')

local = localdb()

if len(args) == 1:
    # interactive, filtered
    if not options.groupfilt and not options.namefilt:
        parser.error( "filtering options are required for single argument" )

    topdir = args[0]
    try:
        mkdir_p( topdir )
    except Exception,x:
        raise SystemExit(x)

    # check for valid regular expressions:
    for filt in options.groupfilt, options.namefilt:
        if filt:
            try:
                re.compile( filt )
            except:
                raise SystemExit( 'Bad expression: ' + filt )

    # retrieve registrations
    local.load_from_file()
    try:
        csuites = local.get_list( groupfilt=options.groupfilt, namefilt=options.namefilt )
    except RegistrationError, x:
        raise SystemExit(x)

    # organise into owner_group groups
    cgroups = {}
    print 'Matched:'
    for csuite, cdir, cdescr in csuites:
        cowner, cgroup, cname = regsplit( csuite ).get()
        print '  ', cgroup + ':' + cname
        cowner_group = cgroup
        if cowner_group not in cgroups:
            cgroups[cowner_group] = [ ( cname, cdir, cdescr ) ]
        else:
            cgroups[cowner_group].append( (cname, cdir, cdescr))

    # import to local
    try:
        local.lock()
    except RegistrationError, x:
        raise SystemExit(x)
    local.load_from_file()
    changed = False
 
    for cowner_group in cgroups:
        cgroup = cowner_group
        lgroup = prompt( "Copy " + cgroup + " as what group?", cgroup )
        if lgroup == 'q':
            local.unlock()
            sys.exit(0)
        if lgroup == 's':
            continue
        for cname, cdir, cdescr in cgroups[cowner_group]:
            lname = prompt( "  Copy " + cgroup + ':' + cname  + " as " + lgroup + ":WHAT?", cname ) 
            if lname == 'q':
                local.unlock()
                sys.exit(0)
            if lname == 's':
                continue
            defldir = os.path.join( topdir, lgroup, lname )
            ldir = prompt( "  Copy Suite Definition to what directory?", defldir ) 
            if os.path.exists( ldir ):
                print >> sys.stderr, 'WARNING: skipping import, directory already exists: ' + ldir
                continue
            lreg = lgroup + ':' + lname
            try:
                local.register( lreg, ldir, cdescr )
            except RegistrationError, x:
                print >> sys.stderr, x
            else:
                print 'Copying suite definition'
                try:
                    mkdir_p( os.path.dirname(ldir))
                except Exception,x:
                    print >> sys.stderr, x
                    local.unregister( lreg )
                else:
                    try:
                        copytree( cdir, ldir )
                    except OSError, x:
                        print >> sys.stderr,x
                        local.unregister( lreg )
                    else:
                        changed = True

    if changed:
        local.dump_to_file()
    local.unlock()

elif not options.groupcopy:
    # single suite
    creg = args[0]
    lreg = args[1]
    ldir = args[2]

    # retrieve registration
    local.load_from_file()
    try:
        cdir, cdescr = local.get( creg )
    except RegistrationError, x:
        raise SystemExit(x)

    if os.path.exists( ldir ):
        raise SystemExit( 'not importing, directory already exists: ' + ldir )

    # import to local
    try:
        local.lock()
    except RegistrationError, x:
        raise SystemExit(x)
    local.load_from_file()
 
    try:
        local.register( lreg, ldir, cdescr )
    except RegistrationError, x:
        local.unlock()
        raise SystemExit(x)
    else:
        print 'Copying suite definition'
        try:
            mkdir_p( os.path.dirname(ldir))
        except Exception,x:
            print >> sys.stderr, x
            local.unregister( lreg )
            local.unlock()
        else: 
            try:
                copytree( cdir, ldir )
            except OSError, x:
                print >> sys.stderr,x
                local.unregister( lreg )
                local.unlock()
            else:
                local.dump_to_file()
                local.unlock()
else:
    # copy a whole group
    fromgroup = args[0]
    togroup = args[1]
    topdir = args[2]

    # retrieve registrations
    local.load_from_file()
    try:
        csuites = local.get_list( groupfilt='^' + fromgroup + '$' )
    except RegistrationError, x:
        raise SystemExit(x)

    print 'Matched:'
    for csuite, cdir, cdescr in csuites:
        cowner, cgroup, cname = regsplit( csuite ).get()
        print '  ', cgroup + ':' + cname

    # import to local
    try:
        local.lock()
    except RegistrationError, x:
        raise SystemExit(x)
    local.load_from_file()
    changed = False
 
    for csuite, cdir, cdescr in csuites:
        cowner, cgroup, cname = regsplit( csuite ).get()
        lgroup = togroup
        lname = cname

        #ldir = os.path.join( topdir, lgroup, lname )
        ldir = os.path.join( topdir, lname )
        if os.path.exists( ldir ):
            print >> sys.stderr, 'WARNING: skipping copy, directory already exists: ' + ldir
            continue
        lreg = lgroup + ':' + lname
        try:
            local.register( lreg, ldir, cdescr )
        except RegistrationError, x:
            print >> sys.stderr, x
            local.unregister( lreg )
        else:
            try:
                mkdir_p( os.path.dirname(ldir))
            except Exception,x:
                print >> sys.stderr, x
                local.unregister(lreg)
            else:
                try:
                    copytree( cdir, ldir )
                except OSError, x:
                    print >> sys.stderr,x
                    local.unregister( lreg )
                else:
                    changed = True
    if changed:
        local.dump_to_file()
    local.unlock()
