#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, re, sys
from shutil import copytree
from optparse import OptionParser
from cylc.mkdir_p import mkdir_p
from cylc.registration import delimiter, delimiter_re, localdb, \
        centraldb, RegistrationError, SuiteTakenError, DatabaseLockedError

parser = OptionParser( usage = """cylc [db] copy|cp [OPTIONS] FROM TO DIR

Make copies of suites or group of suites in your private suite database 
(to copy suites from the central database use 'cylc import'). Suite
definition directories are copied to sub-directories of DIR by
translating the registration path into a directory path.

Note that you can also register an existing suite under a different name
(cylc register) or an alias (cylc alias). 

Arguments:
    FROM - Source suite or group.
    To   - Target suite or group.
    DIR  - Destination for copied suite definition directories.""" )

parser.add_option( "--dry-run",
        help="Show what would be copied.",
        action="store_true", default=False, dest="dryrun" )

# hidden arguments for import from and export to central db
c_import = False
c_export = False
if '--import' in sys.argv:
    c_import = True
    sys.argv.remove( '--import' ) 
elif '--export' in sys.argv:
    c_export = True
    sys.argv.remove( '--export' ) 
    
( options, args ) = parser.parse_args()

if len(args) != 3:
    parser.error('Wrong number of arguments')

# strip registration delimiter off the end, in case the user left it on
# to indicate a group (which is not necessary, but may seem sensible).
arg_from = args[0].rstrip(delimiter)
arg_to = args[1].rstrip(delimiter)
arg_dir = args[2]

if c_import:
    sourcedb = centraldb()
    targetdb = localdb()
elif c_export:
    sourcedb = localdb()
    targetdb = centraldb()
else:
    sourcedb = localdb()
    targetdb = sourcedb

try:
    if c_import or c_export:
        targetdb.lock()
        targetdb.load_from_file()
    else:
        sourcedb.lock()
    sourcedb.load_from_file()

    fsuites = sourcedb.get_list( '^' + arg_from + r'\b' )
    if len(fsuites) == 0:
        raise RegistrationError, 'ERROR, no suites matched: ' + arg_from

    if options.dryrun:
        print 'DRY RUN, I would copy:'

    for fsuite in fsuites:
        freg, fdir, ftitle = fsuite

        treg = re.sub( r'\b' + arg_from + r'\b', arg_to, freg ) 

        tdir = '/'.join( treg.split(delimiter) )
        tdir = os.path.join( arg_dir, tdir )

        if options.dryrun:
            continue

        try:
            targetdb.register( treg, tdir, ftitle )
        except SuiteTakenError, x:
            print >> sys.stderr, 'ERROR, ' + str(x)
            continue

        if os.path.exists( tdir ):
            print >> sys.stderr, 'ERROR, directory already exists: ' + tdir
            targetdb.unregister(treg)
            continue

        tdir = os.path.abspath( tdir )
        try:
            mkdir_p( os.path.dirname(tdir))
        except Exception,x:
            print >> sys.stderr, x
            targetdb.unregister(treg)
            continue

        print 'Copying suite definition for', treg 
        try:
            copytree( fdir, tdir )
        except OSError, x:
            print >> sys.stderr,x
            targetdb.unregister( treg )
            continue

    targetdb.dump_to_file()
    targetdb.unlock()
    if c_import or c_export:
        sourcedb.unlock()

except DatabaseLockedError, x:
    raise SystemExit(x)
except RegistrationError, x:
    print >> sys.stderr, x
    targetdb.unlock()
    if c_import or c_export:
        sourcedb.unlock()
    sys.exit(1)
