#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

from cylc.mkdir_p import mkdir_p
import os, re, sys
from shutil import copytree
from optparse import OptionParser
from cylc.registration import localdb, regsplit, RegistrationError
from cylc.regprompt import prompt

parser = OptionParser( usage = """cylc [db] copy|cp [OPTIONS] FROM TO [DIR]

Copy suites or groups in your private suite database. If DIR is given, suite
definition directories will be copied to that location, otherwise the new
registration will refer to the old suite definition directory. Copying a 
group to GROUP:foo results in the suite definition being copied to
DIR/foo, and so on.

If DIR is not given, a new reference to the original source suite will
be created (i.e. the suite definition directory will not be copied).
 
Arguments:
    FROM, TO - private suite registrations (GROUP:NAME) or groups (GROUP:)
    [DIR]    - destination for the copied suite definition (must not exist).
               or top level directory for copied suite definitions.""" )

( options, args ) = parser.parse_args()

if len(args) < 2 or len(args) > 3:
    parser.error('Wrong number of arguments')

arg_from = args[0]
arg_to = args[1]
copy_dir = False
if len(args) == 3:
    arg_dir = args[2]
    copy_dir = True

local = localdb()

m = re.match( '^(.*):$', arg_from )
n = re.match( '^(.*):$', arg_to )
if m:
    # copy a whole group
    fromgroup = m.groups()[0]
    if n:
        togroup = n.groups()[0]
    else:
        raise SystemExit( 'Inconsistent command arguments' )

    # retrieve registrations
    local.load_from_file()
    try:
        csuites = local.get_list( groupfilt='^' + fromgroup + '$' )
    except RegistrationError, x:
        raise SystemExit(x)

    print 'Matched:'
    for csuite, cdir, cdescr in csuites:
        cowner, cgroup, cname = regsplit( csuite ).get()
        print '  ', cgroup + ':' + cname

    # import to local
    try:
        local.lock()
    except RegistrationError, x:
        raise SystemExit(x)
    local.load_from_file()
    changed = False
 
    for csuite, cdir, cdescr in csuites:
        cowner, cgroup, cname = regsplit( csuite ).get()
        lgroup = togroup
        lname = cname

        if not copy_dir:
            ldir = cdir
        else:
            ldir = os.path.join( arg_dir, lname )
            if os.path.exists( ldir ):
                print >> sys.stderr, 'WARNING: skipping copy, directory already exists: ' + ldir
                continue

        lreg = lgroup + ':' + lname
        try:
            local.register( lreg, ldir, cdescr )
        except RegistrationError, x:
            print >> sys.stderr, x
            # not needed (failed to register)?:
            #local.unregister( lreg )
        else:
            if not copy_dir:
                changed = True
            else:
                # Make path absolute in case user specified a single
                # component relative path such as "foo", in which case
                # os.path.dirname(ldir), below, returns an empty string.
                ldir = os.path.abspath( ldir )
                try:
                    mkdir_p( os.path.dirname(ldir))
                except Exception,x:
                    print >> sys.stderr, x
                    local.unregister(lreg)
                else:
                    print 'Copying suite definition for', lreg 
                    try:
                        copytree( cdir, ldir )
                    except OSError, x:
                        print >> sys.stderr,x
                        local.unregister( lreg )
                    else:
                        changed = True
    if changed:
        local.dump_to_file()
    local.unlock()

else:
    # single suite

    # retrieve registration
    local.load_from_file()
    try:
        cdir, cdescr = local.get( arg_from )
    except RegistrationError, x:
        raise SystemExit(x)

    if not copy_dir:
        ldir = cdir
    else:
        ldir = arg_dir
        if os.path.exists( ldir ):
            raise SystemExit( 'ERROR, destination directory already exists: ' + ldir )

    # import to local
    try:
        local.lock()
    except RegistrationError, x:
        raise SystemExit(x)
    local.load_from_file()
 
    try:
        local.register( arg_to, ldir, cdescr )
    except RegistrationError, x:
        print >> sys.stderr, x
        local.unlock()
        sys.exit(1)
    else:
        if not copy_dir:
            local.dump_to_file()
            local.unlock()
        else:
            # Make path absolute in case user specified a single
            # component relative path such as "foo", in which case
            # os.path.dirname(ldir), below, returns an empty string.
            ldir = os.path.abspath( ldir )
            print 'Copying suite definition'
            try:
                mkdir_p( os.path.dirname(ldir))
            except Exception,x:
                print >> sys.stderr, x
                local.unregister( arg_to )
                local.unlock()
            else: 
                try:
                    copytree( cdir, ldir )
                except OSError, x:
                    print >> sys.stderr,x
                    local.unregister( arg_to )
                    local.unlock()
                else:
                    local.dump_to_file()
                    local.unlock()

