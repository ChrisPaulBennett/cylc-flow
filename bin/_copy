#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, re, sys
from shutil import copytree
from optparse import OptionParser
from cylc.mkdir_p import mkdir_p
from cylc.registration import delimiter, delimiter_re, localdb, \
        centraldb, RegistrationError, SuiteTakenError, DatabaseLockedError

parser = OptionParser( usage = """cylc [db] copy|cp [OPTIONS] SOURCE TARGET TOPDIR

Make copies of suites, or groups of suites, in your private database
(to get copies of suites in the central database use 'cylc import'). 

SOURCE and TARGET are hierarchical suite registrations (foo.bar.baz). 
Consider the following two suites:

% cylc db print '^foo'     # printed in flat form
foo.bar.waz | "Test Suite One" | /tmp/oliverh/waz
foo.bar.baz | "Test Suite Two" | /tmp/oliverh/baz

% cylc db print -t '^foo'  # printed in tree from
foo      
 `-bar   
    |-baz | "Test Suite One" | /tmp/oliverh/baz
    `-waz | "Test Suite Two" | /tmp/oliverh/waz
       
When copying groups of suites SOURCE 
Suites are copied into a directory tree under TOPDIR whose structure
reflects the target registration. When groups of suites are copied 
the target registration is determined by TARGET and lower levels

you specify a SOURCE that has no lower levels a single suite will be copied.
If SOURCE is a group of suites (i.e. there are unspecified lower levels
SOURCE.REGi, say, for some range i), the contained suite definitions are copied to a directory
tree 

If SOURCE contains lower levels REG1 through REGn, say, (i.e. SOURCE.REG1 
through SOURCE.REGn where REGi may also have lower levels) then the
contained suite definitions will be copied to TOPDIR/TARGET/REGi_PATH
where REGi_PATH is obtained by substituting '.' for '/' in REGi etc.,
and then registered as TARGET.REGi.

If SOURCE is a suite, the suite definition directory will be copied to
TOPDIR/TARGET and registered as TARGET.  
Note that you do not need to create suite groups before using them.

Arguments:
    SOURCE - Source suite or group
    TARGET - Target suite or group
    TOPDIR - Destination directory for copied suite definitions""" )

parser.add_option( "--dry-run",
        help="Show what would be copied.",
        action="store_true", default=False, dest="dryrun" )

# hidden arguments for import from and export to central db
c_import = False
c_export = False
if '--import' in sys.argv:
    c_import = True
    sys.argv.remove( '--import' ) 
elif '--export' in sys.argv:
    c_export = True
    sys.argv.remove( '--export' ) 
    
( options, args ) = parser.parse_args()

if len(args) != 3:
    parser.error('Wrong number of arguments')

# strip registration delimiter off the end, in case the user left it on
# to indicate a group (which is not necessary, but may seem sensible).
arg_from = args[0].rstrip(delimiter)
arg_to = args[1].rstrip(delimiter)
arg_dir = args[2]

if c_import:
    sourcedb = centraldb()
    targetdb = localdb()
elif c_export:
    sourcedb = localdb()
    targetdb = centraldb()
else:
    sourcedb = localdb()
    targetdb = sourcedb

try:
    if c_import or c_export:
        targetdb.lock()
        targetdb.load_from_file()
    else:
        sourcedb.lock()
    sourcedb.load_from_file()

    fsuites = sourcedb.get_list( '^' + arg_from + r'\b' )
    if len(fsuites) == 0:
        raise RegistrationError, 'ERROR, no suites matched: ' + arg_from

    if options.dryrun:
        print 'DRY RUN, I would copy:'

    for fsuite in fsuites:
        freg, fdir, ftitle = fsuite

        treg = re.sub( r'\b' + arg_from + r'\b', arg_to, freg ) 

        tdir = '/'.join( treg.split(delimiter) )
        tdir = os.path.join( arg_dir, tdir )

        if options.dryrun:
            continue

        try:
            targetdb.register( treg, tdir, ftitle )
        except SuiteTakenError, x:
            print >> sys.stderr, 'ERROR, ' + str(x)
            continue

        if os.path.exists( tdir ):
            print >> sys.stderr, 'ERROR, directory already exists: ' + tdir
            targetdb.unregister(treg)
            continue

        tdir = os.path.abspath( tdir )
        try:
            mkdir_p( os.path.dirname(tdir))
        except Exception,x:
            print >> sys.stderr, x
            targetdb.unregister(treg)
            continue

        print 'Copying suite definition for', treg 
        try:
            copytree( fdir, tdir )
        except OSError, x:
            print >> sys.stderr,x
            targetdb.unregister( treg )
            continue

    targetdb.dump_to_file()
    targetdb.unlock()
    if c_import or c_export:
        sourcedb.unlock()

except DatabaseLockedError, x:
    raise SystemExit(x)
except RegistrationError, x:
    print >> sys.stderr, x
    targetdb.unlock()
    if c_import or c_export:
        sourcedb.unlock()
    sys.exit(1)
