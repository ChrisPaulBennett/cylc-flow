#!/usr/bin/python

# import standard Python modules
# cylc modules are imported after parsing the command line, so that we
# don't need access to a specific system to print the usage message.
import re
import os
import sys
import shutil
#import profile
import logging
import datetime
from optparse import OptionParser
from time import sleep

# auto-replace with version tag at build/install:
cylc_version = "foo-bar-baz"

def print_banner():
    print ""
    print "_______________C_Y_L_C___________________"
    print ". Self Organising Dynamic Metascheduler ."
    #print "        version: " + cylc_version
    print ".     Hilary Oliver, NIWA, 2008-2010    ."
    print "_______________C_Y_L_C___________________"

def clean_shutdown( pyro, reason ):
    log = logging.getLogger( 'main' )
    log.critical( 'System Halt: ' + reason )
    pyro.shutdown( True ) 

def service_remote_requests( remote, task_manager, log ):

    halt = False
    halt_now = False
    process_tasks = False

    if remote.get_halt():
        # stop launching new tasks, but wait on running ones before
        # shutting down (otherwise they will generate screeds of
        # pyro-related error messages when they try to phone home).
        task_manager.set_system_hold()
        halt = True

    if remote.get_halt_now():
        # stop launching new tasks, NOW.
        # This must be used to shutdown the system if an external task
        # dies without notifying cylc.
        halt_now = True

    if remote.get_nudge():
        process_tasks = True
        remote.set_nudge = False

    if remote.get_hold():
        task_manager.set_system_hold()

    if remote.get_resume():
        task_manager.unset_system_hold()
        process_tasks = True

    if remote.set_stop:
        task_manager.set_stop_time( remote.stop_time )
        remote.set_stop = False

    if remote.set_hold:
        log.warning( 'pre-hold state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.set_system_hold( remote.hold_time )
        remote.set_hold = False

    if remote.do_purge:
        log.warning( 'pre-purge state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.purge( remote.purge_id, remote.purge_stop )
        remote.do_purge = False
        remote.purge_id = None
        remote.purge_stop = None
        process_tasks = True

    if remote.kill_ids:
        log.warning( 'pre-kill state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.abdicate_and_kill( remote.kill_task_ids )
        remote.kill_ids = False
        remote.kill_task_ids = {}
        process_tasks = True
        
    if remote.kill_rt:
        log.warning( 'pre-kill state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.abdicate_and_kill_rt( remote.kill_ctime )
        remote.kill_rt = False
        remote.kill_ctime = None
        process_tasks = True

    if remote.reset_a_task:
        log.warning( 'pre-reset state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.reset_task( remote.reset_task_id )
        remote.reset_a_task = False
        remote.reset_task_id = None
        process_tasks = True

    if remote.insert_this:
        log.warning( 'pre-insert state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.insertion( remote.insert_this )
        remote.insert_this = None
        process_tasks = True


    return [ halt, halt_now, process_tasks ]

def main( argv ):
    # construct a command line parser
    # don't use '%prog' as program name in the usage string, as we
    # invoke this program through the cylc user interface script.

    usage = """cylc schedule -s NAME [options] [START] [STOP]

Start up a new cylc instance for scheduling the configured system NAME.
(1) To cold start a system, supply an initial cycle time START (YYYYMMDDHH). 
(2) To restart a system, use the '--restart' or '--restart-from' options.
(3) If you supply a final cycle time STOP (YYYYMMDDHH) each task will stop
when it reaches that time, and then the system will shut down."""

    parser = OptionParser( usage )

    parser.add_option( "-s", "--system", 
            help="Registered name of the configured system",
            metavar="NAME", action="store", dest="system_name" )

    parser.add_option( "-r", "--restart", 
            help="Restart from the system's configured state dump file",
            action="store_true", default=False, dest="restart" )

    parser.add_option( "--restart-from", 
            help="Restart from a named state dump file, assumed to be "
            "located in the system's configured state dump directory "
            "unless you give an absolute file path.",
            metavar="STATE", action="store", dest="restart_from" )

    parser.add_option( "-d", "--dummy-mode", 
            help="Run in accelerated time dummy mode. System tasks will be "
            "faked by an external dummy program.",
            action="store_true", default=False, dest="dummy_mode" )

    parser.add_option( "--rate", 
            help="(Dummy mode) accelerated clock rate, INT seconds = 1 hour "
            "(defaults to 10 sec = 1 hour).",
            metavar="INT", action="store", default=10, dest="clock_rate" )

    parser.add_option( "--offset", 
            help="(Dummy mode) clock offset at start up. The dummy clock will "
            "start at INT hours prior to START cycle time (default 24 hours). "
            "Use to simulate catching up to real time operation.",
            metavar="HOURS", action="store", default=24, dest="clock_offset" )

    parser.add_option( "--fail", help=\
            "(Dummy mode) get a task to abort after reporting that "
            "it has failed. Use this to test failure and recovery "
            "scenarios. TASK_ID is 'NAME%YYYYMMDDHH'.",
        metavar="TASK-ID", action="store", dest="failout_task_id" )

    parser.add_option( "--reason", 
            help="(Debug) explain why the task processing loop was invoked",
            action="store_true", default=False, dest="task_proc_reason" )

    # get command line options and positional args
    ( options, args ) = parser.parse_args()

    if not options.system_name:
        parser.error( "NO SYSTEM NAME" )

    # import cylc modules now (the reason for this is explained above)
    import pyrex
    import config
    import manager
    import task_base
    import dead_letter
    import task_launcher
    import remote_switch
    import state_summary
    import cycle_time
    import pimp_my_logger
    import accelerated_clock 

    print_banner()

    # load system configuration
    # cylc front end has already exported the system environment.
    system_config = config.config()

    dummy_mode = False
    if options.dummy_mode:
        system_config.put( 'dummy_mode', True )
        dummy_mode = True

    if options.system_name != system_config.get( 'system_name' ):
        # this should never happen
        print 'ERROR: configured system and command line disagree'
        sys.exit(1)

    restart_from = None
    restart = False
    start_time = None
    stop_time = None

    reset_time = None
    if options.restart or options.restart_from:
        restart = True
        # cylc schedule --system=NAME --restart [STOP]
        # cylc schedule --system=NAME --restart-from=STATE [STOP]
        if len( args ) == 0:
            # default
            pass
        elif len( args ) == 1:
            stop_time = args[0]
        else:
            parser.error( "too many arguments" )

        if not dummy_mode:
            # If a restart state dump indicates dummy mode then restart
            # in dummy mode even if the command line does not force it.
            # TO DO: THIS DUPLICATES CODE IN MANAGER but we need to 
            # know dummy mode or not here.

            configured_file = system_config.get('state_dump_dir') + '/' + system_config.get('state_dump_file')
            if options.restart_from:
                filename = options.restart_from
                if filename == os.path.basename( filename ):
                    # is a plain filename; append to configured path
                    dirname = os.path.dirname( configured_file )
                    filename = dirname + '/' + filename
                elif re.match( '^/' ):
                    # is an absolute path
                    pass
                else:
                    # relative path; append to cwd
                    filename = os.getcwd() + '/' + filename

            else:
                filename = configured_file

            # The state dump file first line is:
            # system time : <time>
            #   OR
            # dummy time : <time>,rate

            FILE = open( filename, 'r' )
            lines = FILE.readlines()
            FILE.close()

            [ junk, tmp ] = lines[0].split( ' : ' )

            if junk == 'dummy time':
                system_config.put( 'dummy_mode', True )
                dummy_mode = True
                [ reset_time, rate ] = tmp.split( ',' )
                rate.rstrip() # strip newline
            else:
                reset_time.rstrip() # strip newline

    else:
        # cylc schedule --system=NAME START [STOP]
        if len( args ) == 1:
            start_time = args[0]
        elif len( args ) == 2:
            start_time = args[0]
            stop_time = args[1]
        else:
            parser.error( "too many arguments" )
     
    if start_time:
        if not cycle_time.is_valid( start_time ):
            parser.error( "invalid START time" )

    if stop_time:
        if not cycle_time.is_valid( stop_time ):
            parser.error( "invalid STOP time" )

    if not start_time and \
            not options.restart and \
            not options.restart_from: 
        parser.error( 'Either supply start time or restart' )
       
    # set configured global (all tasks) environment variables
    if dummy_mode:
        os.environ[ 'CLOCK_RATE' ] = str( options.clock_rate )

    env = system_config.get('environment')
    for VAR in env.keys():
        os.environ[ VAR ] = env[ VAR ]

    if dummy_mode:
        print
        print "RUNNING IN DUMMY MODE!"
        print

    # configure my pyro helper
    # this will abort if the nameserver group already exists
    pyro = pyrex.pyrex( options.system_name )

    # system clock for accelerated time in dummy mode
    clock = accelerated_clock.clock( 
            int(options.clock_rate),
            int(options.clock_offset),
            dummy_mode ) 

    if reset_time:
        clock.reset( reset_time )

    pyro.connect( clock, 'clock' )

    print "CREATING MAIN LOG......."
    # create logging dirs
    if not os.path.exists( system_config.get('logging_dir') ):
       os.makedirs( system_config.get('logging_dir') )
    # top level logging
    log = logging.getLogger( 'main' )
    pimp_my_logger.pimp_it( log, 'main', system_config, dummy_mode, clock )

    try:
        # attempt a clean shutdown if anything goes wrong from here on

        # external task launcher
        launcher = task_launcher.launcher( system_config, dummy_mode, options.failout_task_id )

        state_dump_dir = system_config.get('state_dump_dir')
        state_dump_file = state_dump_dir + '/' + system_config.get('state_dump_file')

        if os.path.exists( state_dump_file ):
            print "STATE DUMP BACKUP..."
            backup = state_dump_file + '.' + datetime.datetime.now().isoformat()
            print ' + ' + backup
            shutil.copyfile( state_dump_file, backup )

        elif not os.path.exists( state_dump_dir ):
            print "STATE DUMP DIR..."
            os.makedirs( state_dump_dir )

        # remotely accessible system state summary
        system_state = state_summary.state_summary( system_config, dummy_mode )
        pyro.connect( system_state, 'state_summary' )

        # dead letter box for remote use
        dead_letter_box = dead_letter.letter_box()
        pyro.connect( dead_letter_box, 'dead_letter_box' )

        # initialize the task manager from general config file or state dump
        system_config.put( 'pyro', pyro )
        system_config.put( 'clock', clock )
        system_config.put( 'restart', restart )
        system_config.put( 'start_time', start_time )
        system_config.put( 'stop_time', stop_time )
        system_config.put( 'restart_from', restart_from )

        task_manager = manager.manager( system_config )

        # remote control switch
        remote = remote_switch.remote_switch( system_config, system_config.get('task_list'), task_manager.get_tasks() )
        pyro.connect( remote, 'remote' )

        print "\nBeginning task scheduling NOW\n"

        count = 0
        task_base.state_changed = True
        system_halt = False
        system_halt_now = False

        while True: # MAIN LOOP
            [ halt, halt_now, process_tasks_remote ] = service_remote_requests( remote, task_manager, log )
            if halt:
                system_halt = True
            if halt_now:
                system_halt_now = True

            process_tasks_contact = False
            if task_manager.waiting_contact_task_ready( clock ):
                process_tasks_contact = True

            # PROCESS ALL TASKS whenever something has changed that might
            # require renegotiation of dependencies, etc.
            #--
            if task_base.state_changed or process_tasks_remote or process_tasks_contact:

                if options.task_proc_reason:
                    # log reason for invoking task processing
                    count = count + 1
                    reasons = []
                    if task_base.state_changed:
                        reasons.append( 'task message received' )
                    if process_tasks_remote:
                        reasons.append( 'remote request serviced' )
                    if process_tasks_contact:
                        reasons.append( 'waiting contact task ready' )
                    msg = ', '.join( reasons )
                    # should really be log.debug() but warnings go to stdout...
                    log.warning( 'task processing, ' + str( count ) + ': ' + msg )

                    # simulate the effect on monitoring etc. of long task
                    # processing time (many many tasks...)
                    #if count % 50 == 0:
                    #    # every 50th time, sleep for 30s
                    #    print 'SLEEPING 30s!'
                    #    sleep(30)

                task_manager.regenerate_tasks()

                task_manager.negotiate_dependencies()

                task_manager.run_tasks( launcher )

                task_manager.kill_spent_tasks()

                task_manager.dump_state()

                system_state.update( task_manager.tasks, clock )

            if task_manager.all_tasks_finished():
                clean_shutdown( pyro, "ALL TASKS FINISHED" )
                return

            if system_halt_now or system_halt and task_manager.no_tasks_running():
                clean_shutdown( pyro, "all running tasks finished" )
                return

            # REMOTE METHOD HANDLING; with no timeout and single-
            # threaded pyro, handleRequests() returns after one or
            # more remote method invocations are processed (these 
            # are not just task messages, hence the use of the
            # state_changed variable above).
            #--

            # incoming task messages set this to True
            task_base.state_changed = False
            # handle all remote calls
            pyro.handleRequests( timeout = None )

         # END MAIN LOOP

    except Exception:
        clean_shutdown( pyro, 'Error Occurred' )
        raise

if __name__ == "__main__":
    
    # performance profiling:
    #profile.run( 'main( sys.argv )' )
	# has a big performance hit itself, any better way?

    #try:
  	main( sys.argv )
    #except:
    #    print 'fuck it'
