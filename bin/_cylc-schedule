#!/usr/bin/python

# standard Python modules
import re, os, sys
#import profile
import logging
import datetime
from time import sleep
from optparse import OptionParser

# cycl source modules
import pyrex
import manager
import cycle_time
import dead_letter
import state_summary
import accelerated_clock 

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError

def print_banner():
    items = banner.keys() + startup.keys()

    longest_item = items[0]
    for item in items:
        if len(item) > len(longest_item):
            longest_item = item

    template = re.sub( '.', '.', longest_item )

    for item in banner.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( banner[ item ] )
    for item in startup.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( startup[ item ] )

def locate_pyro_nameserver():
    try:
        nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
    except NamingError:
        raise SystemExit("No Pyro nameserver found on " + pns_host )
    else:
        return nameserver

def create_ns_groupname( nameserver, groupname ):
    try:
        nameserver.createGroup( groupname )

    except NamingError:
        # abort if any existing objects are registered in my group name
        # (this may indicate another instance of cylc is running
        # with the same groupname; must be unique for each instance
        # else the different systems will interfere with each other) 
        print "\nERROR: group '" + groupname + "' is already registered"
        print "in the Pyro nameserver."
        objs = nameserver.list( groupname )
        if len( objs ) == 0:
            print "It currently contains no objects."
        else:
            print "It contains the following registered objects:"
            for obj in objs:
                print '  + ' + obj[0]

        print
        print "If the group is in use by another cylc instance then re-register your"
        print "system under a different name using the 'cylc register' command."
        print 
        print "If the group is being used by a running cylc of yours that you no"
        print "longer need, shut it down using the 'cylc control' command."
        print 
        print "If the group is a relic of an aborted cylc run you can delete it"
        print "manually from the nameserver:"
        print 
        print "pyro-nsc deletegroup " + groupname + "   #<--DO-THIS-!" 
        print
        raise SystemExit( "ABORTING NOW" )

def ns_obj_name( name, groupname ):
    # object name as registered with the Pyro nameserver
    return groupname + '.' + name

usage = """1/ cylc schedule [options] --start-at=CYCLE SYSTEM (cold start)
Usage: 2/ cylc schedule [options] --restart SYSTEM        (restart)

Start or restart a configured, registered, system. 

For a cold start, each task is instantiated at the initial cycle time,
or at the first subsequent cycle allowed for that task. At least one
task in the system must have no prerequisites, or nothing will happen. 

For a restart, the system starts from a prior state recorded in the 
configured, or named, state dump file. Any task that was in the
"submitted", "running", or "failed" states will be reset to the
"waiting" state so that it will be resubmitted immediately.

Use nohup (see 'man nohup') to start a scheduler that will not die with
your terminal session.

arguments:
   SYSTEM               Registered name of the forecasting system.""" 

def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( pns_host='localhost', 
            restart=False, dummy_mode=False,
            clock_rate=10, clock_offset=24 )

    parser.add_option( "-s", "--start-at", 
            help="Initial cycle time (YYYYMMDDHH).",
            metavar="CYCLE", action="store", dest="start_time" )

    parser.add_option( "--stop-at", 
            help="Optional final cycle time (YYYYMMDDHH). The scheduler "
            "will shut down when each task has passed this cycle.",
            metavar="CYCLE", action="store", dest="stop_time" )

    parser.add_option( "-r", "--restart", 
            help="Restart from the system's configured state dump file",
            action="store_true", dest="restart" )

    parser.add_option( "--restart-from", 
            help="Restart from a named state dump file in the configured "
            "state dump directory, or give the file path.",
            metavar="FILE", action="store", dest="restart_from" )

    parser.add_option( "--exclude",
            help="Exclude these tasks at startup. Equivalent to "
            "deleting them from the system task list.",
            metavar="Task1,Task2,...", action="store", dest='exclude' )

    parser.add_option( "--include",
            help="Include only these tasks at startup. "
            "Equivalent to deleting all other tasks from the "
            "system task list.",
            metavar="Task1,Task2,...", action="store", dest='include' )

    parser.add_option( "-n", "--nameserver",
            help="Hostname of the machine running the Pyro nameserver, "
            "defaults to localhost",
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "-p", "--practice-mode",
            help="PRACTICE MODE: a special version of dummy mode that"
            "lets you practice making changes to a current running,"
            "paused, or halted system without corrupting its state or "
            "log files.",
            action="store_true", dest="practice_mode" )

    parser.add_option( "-d", "--dummy-mode",
            help="DUMMY MODE: replace each real system task with a program "
            "that fakes its output messages on time, relative to an "
            "accelerated clock.",
            action="store_true", dest="dummy_mode" )

    parser.add_option( "--dummy-clock-rate", 
            help="(DUMMY MODE) accelerated clock rate: RATE seconds of "
            "real time per simulated hour (defaults to 10).",
            metavar="RATE", action="store", dest="clock_rate" )

    parser.add_option( "--dummy-clock-offset", 
            help="(DUMMY MODE) start the accelerated clock at HOURS "
            "prior to the initial cycle time (default 24 hours). "
            "This simulates catch up to real time operation.",
            metavar="HOURS", action="store", dest="clock_offset" )

    parser.add_option( "--fail-out", help=\
            "(DUMMY MODE) get task NAME at cycle time CYCLE to report failure "
            "and then abort. Use this to test failure and recovery scenarios.",
            metavar="NAME%CYCLE", action="store", dest="failout_task_id" )

    return parser

# =====================================================================
# MAIN PROGRAM
# =====================================================================

banner = {}

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

# get system name------------------------------------------------------
reg_name = args[0]
banner[ 'system name' ] = reg_name

# get Pyro nameserver hostname-----------------------------------------
if not options.pns_host:
    # (this won't happen; defaults to localhost)
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host
    banner[ 'Pyro nameserver' ] = pns_host

# get mode of operation------------------------------------------------

if options.dummy_mode and options.practice_mode:
    parser.error( "choose ONE of dummy or practice mode")

mode = {}
mode['dummy'] = False
mode['practice' ] = False

if options.dummy_mode:
    mode['dummy'] = True
    banner[ 'mode of operation' ] = 'DUMMY'
elif options.practice_mode:
    mode['dummy'] = True
    mode['practice'] = True
    banner[ 'mode of operation' ] = 'PRACTICE DUMMY'
else:
    banner[ 'mode of operation' ] = 'REAL'

# check startup configuration------------------------------------------

startup = {}

startup[ 'start_time'] = None
startup[ 'stop_time' ] = None
startup[ 'restart'   ] = False
startup[ 'restart_from' ] = None

if options.start_time and ( options.restart or options.restart_from ):
    parser.error( "A start time does not make sense for a restart" )

if not options.start_time and not ( options.restart or options.restart_from ):
    parser.error( 'You must supply a start time or specify a restart' )

if options.stop_time:
    startup[ 'stop_time' ] = options.stop_time
    if not cycle_time.is_valid( options.stop_time ):
        parser.error( "invalid cycle time: " + options.stop_time )

if options.start_time:
    startup[ 'start_time' ] = options.start_time
    if not cycle_time.is_valid( options.start_time ):
        parser.error( "invalid cycle time: " + options.start_time )

elif options.restart:
    startup[ 'restart' ] = True

elif options.restart_from:
    startup[ 'restart_from' ] = options.restart_from

else:
    #raise SystemExit( "Illegal startup options" )
    parser.error( "Illegal startup options" )

if options.include and options.exclude:
    parser.error( '--include and --exclude are mutually exclusive' )

if options.exclude:
    exclude = options.exclude.split(',')
else:
    exclude = []
startup[ 'exclude' ] = exclude

if options.include:
    include = options.include.split(',')
else:
    include = []
startup[ 'include' ] = include

# find location of the system task and config modules------------------
registration_file = os.environ['HOME'] + '/.cylc/registered/' + reg_name
if os.path.exists( registration_file ):
    FILE = open( registration_file, 'r' )
    line = FILE.read()
    system_dir = line.rstrip() 
    FILE.close()
else:
    raise SystemExit( "No such system name registered: " + reg_name )

banner[ 'system definition' ] = system_dir

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.
print system_dir
# prepend system scripts to $PATH (prepend in case this is a subsystem!)
# (NOTE this is still somewhat dangerous: if a subsystem task script
# that should be executable but isn't has the same filename as a task in
# the parent system, the parent file will be found and executed).
os.environ['PATH'] = system_dir + '/scripts:' + os.environ['PATH'] 
# prepend add system Python modules to $PYTHONPATH (prepend, as above)
os.environ['PYTHONPATH'] = system_dir + ':' + os.environ['PYTHONPATH']

# provide access to the system source modules for THIS program---------
# prepend to the module search path in case this is a subsystem
sys.path.insert(0, system_dir )

# import system-specific cylc modules now------------------------------ 
from system_config import system_config 
import task_base     # loads task_specif.py
import remote_switch # ditto

# load system configuration--------------------------------------------
config = system_config( reg_name )
config.configure( mode['practice'])

# LOCATE THE PYRO NAMESERVER-------------------------------------------
nameserver = locate_pyro_nameserver()

# CREATE A UNIQUE NAMESERVER GROUPNAME FOR THIS SYSTEM-----------------
#if mode['practice']:
# THIS HAS IMPLICATIONS FOR MESSAGING, CONTROLLING, AND MONITORING
#    groupname = os.environ['USER'] + '_' + reg_name + "_practice"
#else:
#    groupname = os.environ['USER'] + '_' + reg_name
groupname = os.environ['USER'] + '_' + reg_name

create_ns_groupname( nameserver, groupname )
banner[ 'Pyro nameserver group' ] = groupname
 
# REQUIRE SINGLE THREADED PYRO (see documentation)
Pyro.config.PYRO_MULTITHREADED = 0
Pyro.core.initServer()

# CREATE A PYRO DAEMON FOR THIS SYSTEM
daemon = Pyro.core.Daemon()
daemon.useNameServer(nameserver)

# system clock for accelerated time in dummy mode
clock = accelerated_clock.clock( 
        int(options.clock_rate),
        int(options.clock_offset),
        mode['dummy'] ) 

daemon.connect( clock, ns_obj_name( 'clock', groupname ))


# remotely accessible system state summary
system_state = state_summary.state_summary( config, mode['dummy'] )
daemon.connect( system_state, ns_obj_name( 'state_summary', groupname ))

# dead letter box for remote use
dead_letter_box = dead_letter.letter_box()
daemon.connect( dead_letter_box, ns_obj_name( 'dead_letter_box', groupname))

# load some command line options and dynamic stuff into config
# module, for easy handling.
config.put( 'daemon', daemon )
config.put( 'clock', clock )

# initialize the task manager (and create main logger)
pool = manager.manager( config, groupname, mode['dummy'], startup )

# logger is now created and pimped
log = logging.getLogger( 'main' )

# remote control switch
remote = remote_switch.remote_switch( config, pool, options.failout_task_id )
daemon.connect( remote, ns_obj_name( 'remote', groupname) )

# set global (all tasks) environment variables-------------------------
os.environ[ 'CYLC_ON' ] = 'true' # tells 'cylc message' to use the nameserver
os.environ[ 'CYLC_NS_HOST' ] = str( pns_host )  # may be an IP number
os.environ[ 'CYLC_NS_GROUP' ] = groupname
os.environ[ 'SYSTEM_NAME' ] = reg_name
if mode['dummy']:
    os.environ[ 'CLOCK_RATE' ] = str( options.clock_rate )
    # communicate failout_task_id to the dummy task program
    if options.failout_task_id:
        print "FAILOUT: " + options.failout_task_id
        os.environ[ 'FAILOUT_ID' ] = options.failout_task_id

# extra global vars set in the system config file
env = config.get('environment')
for VAR in env.keys():
    #print "! setting", VAR, '=', env[VAR]
    os.environ[ VAR ] = str( env[ VAR ] )

# print system information at startup----------------------------------
print_banner()
print
config.dump()
print "\nSTARTING\n"

count = 0
task_base.state_changed = True

while True: # MAIN LOOP

    # PROCESS ALL TASKS whenever something has changed that might
    # require renegotiation of dependencies, etc.
    #--
    if task_base.state_changed or \
            remote.process_tasks or \
            pool.waiting_contact_task_ready( clock.get_datetime() ):

        pool.negotiate()

        pool.run_tasks()

        pool.cleanup()

        # spawn after cleanup in case the system had stalled, unspawned
        # at max runahead.
        pool.spawn()

        pool.dump_state()

        system_state.update( pool.tasks, clock )

    if pool.all_tasks_finished():
        log.critical( "ALL TASKS FINISHED" )
        break

    if remote.halt_now or remote.halt and pool.no_tasks_running():
        log.critical( "ALL RUNNING TASKS FINISHED" )
        break

    # REMOTE METHOD HANDLING; with no timeout and single- threaded pyro,
    # handleRequests() returns after one or more remote method
    # invocations are processed (these are not just task messages, hence
    # the use of the state_changed variable above).
    #--

    # incoming task messages set this to True
    task_base.state_changed = False
    remote.process_tasks = False
    # handle all remote calls
    #print "hello ..."
    daemon.handleRequests( timeout = None )
    #print "      ... there"

# END MAIN LOOP

print ""
print "STOPPING"
print ""
print "Shutting down my Pyro daemon"
daemon.shutdown( True )
print "Deleting Pyro nameserver group " + groupname
nameserver.deleteGroup( groupname )
print "Bye!"

# to simulate the effect on monitoring etc. of long task processing time
# (many many tasks...), put this in the task processing loop:
#if count % 50 == 0:
#    # every 50th time, sleep for 30s
#    print 'SLEEPING 30s!'
#    sleep(30)
