#!/usr/bin/python

# USE $PYTHONPATH IN YOUR ENVIRONMENT TO MAKE AVAILABLE the
# cylc 'src' module directory, and system definition modules
# (user_config and task_classes).

import re
import os
import sys
import pyrex
import config
import shutil
import profile
import manager
import logging
import datetime
import task_base
import dead_letter
import task_launcher
import remote_switch
import state_summary
import reference_time
import pimp_my_logger
import accelerated_clock 
from optparse import OptionParser
from time import sleep

# auto-replace with version tag at build/install:
cylc_version = "foo-bar-baz"

def print_banner():
    print "_______________C_Y_L_C___________________"
    print ". Self Organising Dynamic Metascheduler ."
    #print "        version: " + cylc_version
    print ".     Hilary Oliver, NIWA, 2008-2010    ."
    print "_______________C_Y_L_C___________________"

def clean_shutdown( pyro, reason ):
    log = logging.getLogger( 'main' )
    log.critical( 'System Halt: ' + reason )
    pyro.shutdown( True ) 

def service_remote_requests( remote, task_manager, log ):

    halt = False
    halt_now = False
    process_tasks = False

    if remote.get_halt():
        # stop launching new tasks, but wait on running ones before
        # shutting down (otherwise they will generate screeds of
        # pyro-related error messages when they try to phone home).
        task_manager.set_system_hold()
        halt = True

    if remote.get_halt_now():
        # stop launching new tasks, NOW.
        # This must be used to shutdown the system if an external task
        # dies without notifying cylc.
        halt_now = True

    if remote.get_nudge():
        process_tasks = True
        remote.set_nudge = False

    if remote.get_hold():
        task_manager.set_system_hold()

    if remote.get_resume():
        task_manager.unset_system_hold()
        process_tasks = True

    if remote.set_stop:
        task_manager.set_stop_time( remote.stop_time )
        remote.set_stop = False

    if remote.set_hold:
        log.warning( 'pre-hold state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.set_system_hold( remote.hold_time )
        remote.set_hold = False

    if remote.do_purge:
        log.warning( 'pre-purge state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.purge( remote.purge_id, remote.purge_stop )
        remote.do_purge = False
        remote.purge_id = None
        remote.purge_stop = None
        process_tasks = True

    if remote.kill_ids:
        log.warning( 'pre-kill state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.abdicate_and_kill( remote.kill_task_ids )
        remote.kill_ids = False
        remote.kill_task_ids = {}
        process_tasks = True
        
    if remote.kill_rt:
        log.warning( 'pre-kill state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.abdicate_and_kill_rt( remote.kill_reftime )
        remote.kill_rt = False
        remote.kill_reftime = None
        process_tasks = True

    if remote.reset_a_task:
        log.warning( 'pre-reset state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.reset_task( remote.reset_task_id )
        remote.reset_a_task = False
        remote.reset_task_id = None
        process_tasks = True

    if remote.insert_this:
        log.warning( 'pre-insert state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.insertion( remote.insert_this )
        remote.insert_this = None
        process_tasks = True


    return [ halt, halt_now, process_tasks ]

def main( argv ):

    # construct a command line parser
    
    # don't use '%prog' as program name in the usage string, as we
    # invoke this program through the cylc user interface script.

    usage = \
    """
(1) cylc schedule [options] START [STOP]
Cold start a cylc system with initial cycle time START. If the optional
STOP cycle time is supplied the system will automatically shut down when
all tasks have reached it.

(2) cylc schedule [options] --restart [STATE-DUMP] [STOP]
Restart a cylc system from the configured or (optionally) named state
dump file, and (optionally) stop when all tasks have reached cycle time
STOP.

Cycle time format: YYYYMMHHDD."""

    parser = OptionParser( usage )

    parser.add_option( "-n", "--name", help=\
            "Name of system to scheduler",
        metavar="SYSTEM-NAME", action="store", dest="system_name" )

    parser.add_option( "-r", "--restart", 
            help="Restart from the named state dump file, which is assumed "
                 "to be in the directory of the configured state dump file "
                 "unless an absolute path is supplied. Defaults to the "
                 "configured state dump file.",
            action="store_true", default=False, dest="restart" )

    parser.add_option( "-d", "--dummy-mode", 
            help="Run in dummy mode: external dummy programs will masquerade as"
            "the configured real tasks, in accelerated time.",
            action="store_true", default=False, dest="dummy_mode" )

    parser.add_option( "--clock-rate", 
            help="Dummy mode accelerated clock rate in seconds per simulated hour"
            "(default 10, i.e. 10 sec = 1 hour).",
            metavar="SECONDS", action="store", default=10, dest="clock_rate" )

    parser.add_option( "--clock-offset", 
            help="Dummy mode clock offset from initial cycle time at startup (default 24)."
            "Use to simulate catch up to real time operation.",
            metavar="HOURS", action="store", default=24, dest="clock_offset" )

    parser.add_option( "--fail", help=\
            "In dummy mode, get this task to abort after reporting that"
            "it has failed. You can use this to test failure and recovery"
            "scenarios. TASK_ID is 'NAME%YYYYMMDDHH'.",
        metavar="TASK-ID", action="store", dest="failout_task_id" )

    parser.add_option( "--task-proc-reason", 
            help="Print why the task processing loop was invoked each time",
            action="store_true", default=False, dest="task_proc_reason" )

    # get command line options and positional args
    ( options, args ) = parser.parse_args()

    print_banner()

    # load system configuration
    # cylc front end has already exported the system environment.
    system_config = config.config()

    dummy_mode = False
    if system_config.get( 'dummy_mode' ):
        dummy_mode = True

    elif options.dummy_mode:
        system_config.put( 'dummy_mode', True )
        dummy_mode = True

    if dummy_mode:
        print
        print "RUNNING IN DUMMY MODE!"
        print

    restart_statedump = None
    start_time = None
    stop_time = None

    if options.restart:
        # restarting the system
        if len( args ) == 0:
            # default
            pass
        elif len( args ) == 1:
            if reference_time.is_valid( args[0] ):
                stop_time = args[0]
            else:
                restart_statedump = args[0]
        elif len( args ) == 2:
            restart_statedump = args[0]
            stop_time = args[1]
        else:
            parser.error( "too many arguments" )

    else:
        # cold starting the system
        if len( args ) == 1:
            start_time = args[0]
        elif len( args ) == 2:
            start_time = args[0]
            stop_time = args[1]
        else:
            parser.error( "wrong number of arguments" )
     
    if not start_time and not options.restart: 
        parser.error( 'start time and restart both undefined' )
       
    # set configured environment variables
    env = system_config.get('environment')
    for VAR in env.keys():
        os.environ[ VAR ] = env[ VAR ]

    # configure my pyro helper
    # this will abort if the nameserver group already exists
    pyro = pyrex.pyrex( system_config.get( 'system_name' ))

    # system clock for accelerated time in dummy mode
    clock = accelerated_clock.clock( 
            int(options.clock_rate),
            int(options.clock_offset),
            dummy_mode ) 
    pyro.connect( clock, 'clock' )

    print "CREATING MAIN LOG......."
    # create logging dirs
    if not os.path.exists( system_config.get('logging_dir') ):
       os.makedirs( system_config.get('logging_dir') )
    # top level logging
    log = logging.getLogger( 'main' )
    pimp_my_logger.pimp_it( log, 'main', system_config, dummy_mode, clock )

    try:
        # attempt a clean shutdown if anything goes wrong from here on

        # external task launcher
        launcher = task_launcher.launcher( system_config, dummy_mode, int(options.clock_rate), options.failout_task_id )

        state_dump_dir = system_config.get('state_dump_dir')
        state_dump_file = state_dump_dir + '/' + system_config.get('state_dump_file')

        if os.path.exists( state_dump_file ):
            print "STATE DUMP BACKUP..."
            backup = state_dump_file + '.' + datetime.datetime.now().isoformat()
            print ' + ' + backup
            shutil.copyfile( state_dump_file, backup )

        elif not os.path.exists( state_dump_dir ):
            print "STATE DUMP DIR..."
            os.makedirs( state_dump_dir )

        # remotely accessible system state summary
        system_state = state_summary.state_summary( system_config, dummy_mode )
        pyro.connect( system_state, 'state_summary' )

        # dead letter box for remote use
        dead_letter_box = dead_letter.letter_box()
        pyro.connect( dead_letter_box, 'dead_letter_box' )

        # initialize the task manager from general config file or state dump
        task_manager = manager.manager( system_config, dummy_mode, pyro, clock, options.restart, start_time, stop_time, restart_statedump )

        # remote control switch
        remote = remote_switch.remote_switch( system_config, system_config.get('task_list'), task_manager.get_tasks() )
        pyro.connect( remote, 'remote' )

        print "\nBeginning task processing now\n"

        count = 0
        task_base.state_changed = True
        system_halt = False
        system_halt_now = False

        while True: # MAIN LOOP
            [ halt, halt_now, process_tasks_remote ] = service_remote_requests( remote, task_manager, log )
            if halt:
                system_halt = True
            if halt_now:
                system_halt_now = True

            process_tasks_contact = False
            if task_manager.waiting_contact_task_ready( clock ):
                process_tasks_contact = True

            # PROCESS ALL TASKS whenever something has changed that might
            # require renegotiation of dependencies, etc.
            #--
            if task_base.state_changed or process_tasks_remote or process_tasks_contact:

                if options.task_proc_reason:
                    # log reason for invoking task processing
                    count = count + 1
                    reasons = []
                    if task_base.state_changed:
                        reasons.append( 'task message received' )
                    if process_tasks_remote:
                        reasons.append( 'remote request serviced' )
                    if process_tasks_contact:
                        reasons.append( 'waiting contact task ready' )
                    msg = ', '.join( reasons )
                    # should really be log.debug() but warnings go to stdout...
                    log.warning( 'task processing, ' + str( count ) + ': ' + msg )

                    # simulate the effect on monitoring etc. of long task
                    # processing time (many many tasks...)
                    #if count % 50 == 0:
                    #    # every 50th time, sleep for 30s
                    #    print 'SLEEPING 30s!'
                    #    sleep(30)

                task_manager.regenerate_tasks()

                task_manager.negotiate_dependencies()

                task_manager.run_tasks( launcher )

                task_manager.kill_spent_tasks()

                task_manager.dump_state()

                system_state.update( task_manager.tasks, clock )

            if task_manager.all_tasks_finished():
                clean_shutdown( pyro, "ALL TASKS FINISHED" )
                return

            if system_halt_now or system_halt and task_manager.no_tasks_running():
                clean_shutdown( pyro, "all running tasks finished" )
                return

            # REMOTE METHOD HANDLING; with no timeout and single-
            # threaded pyro, handleRequests() returns after one or
            # more remote method invocations are processed (these 
            # are not just task messages, hence the use of the
            # state_changed variable above).
            #--

            # incoming task messages set this to True
            task_base.state_changed = False
            # handle all remote calls
            pyro.handleRequests( timeout = None )

         # END MAIN LOOP

    except Exception:
        clean_shutdown( pyro, 'Error Occurred' )
        raise

if __name__ == "__main__":
    
    # performance profiling:
    #profile.run( 'main( sys.argv )' )
	# has a big performance hit itself, any better way?

    #try:
  	main( sys.argv )
    #except:
    #    print 'fuck it'
