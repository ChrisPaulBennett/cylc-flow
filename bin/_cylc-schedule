#!/usr/bin/python

# standard Python modules
import re, os, sys, shutil
#import profile
import logging
import datetime
from time import sleep
from optparse import OptionParser

# cycl source modules
import pyrex
import manager
import cycle_time
import dead_letter
import state_summary
import pimp_my_logger
import accelerated_clock 

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError

# auto-replace with version tag at build/install:
cylc_version = "REPLACE-ME"

def print_banner():
    print ""
    print "_______________C_Y_L_C___________________"
    print ". Self Organising Dynamic Metascheduler ."
    print ".     Hilary Oliver, NIWA, 2008-2010    ."
    print "_______________C_Y_L_C___________________"
    print "version: " + cylc_version
    print ""

    items = banner.keys() + startup.keys()

    longest_item = items[0]
    for item in items:
        if len(item) > len(longest_item):
            longest_item = item

    template = re.sub( '.', '.', longest_item )

    print "STARTUP CONFIGURATION:"
    for item in banner.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( banner[ item ] )
    for item in startup.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( startup[ item ] )

def locate_pyro_nameserver():
    try:
        nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
    except NamingError:
        raise SystemExit("No Pyro nameserver found on " + pns_host )
    else:
        return nameserver

def create_ns_groupname( nameserver, groupname ):
    try:
        nameserver.createGroup( groupname )

    except NamingError:
        # abort if any existing objects are registered in my group name
        # (this may indicate another instance of cylc is running
        # with the same groupname; must be unique for each instance
        # else the different systems will interfere with each other) 
        print "\nERROR: group '" + groupname + "' is already registered"
        objs = nameserver.list( groupname )
        if len( objs ) == 0:
            print "(although it currently contains no registered objects)."
        else:
            print "And contains the following registered objects:"
            for obj in objs:
                print '  + ' + obj[0]

        print "\nOPTIONS:"
        print "(i) if the group is yours from a previous aborted run you can"
        print "    manually delete it with 'pyro-nsc deletegroup " + groupname +"'"
        print "(ii) if the group is being used by another program, change"
        print "    'system_name' in your config file to avoid interference.\n"

        raise SystemExit( "ABORTING NOW" )

def service_remote_requests( remote, pool, log, failout = None ):

    halt = False
    halt_now = False
    process_tasks = False

    if remote.get_halt():
        # stop launching new tasks, but wait on running ones before
        # shutting down (otherwise they will generate screeds of
        # pyro-related error messages when they try to phone home).
        pool.set_system_hold()
        halt = True

    if remote.get_halt_now():
        # stop launching new tasks, NOW.
        # This must be used to shutdown the system if an external task
        # dies without notifying cylc.
        halt_now = True

    if remote.get_nudge():
        process_tasks = True
        remote.set_nudge = False

    if remote.get_hold():
        pool.set_system_hold()

    if remote.get_resume():
        pool.unset_system_hold()
        process_tasks = True

    if remote.set_stop:
        pool.set_stop_time( remote.stop_time )
        remote.set_stop = False

    if remote.set_hold:
        log.warning( 'pre-hold state dump: ' + pool.dump_state( new_file = True ))
        pool.set_system_hold( remote.hold_time )
        remote.set_hold = False

    if remote.do_purge:
        log.warning( 'pre-purge state dump: ' + pool.dump_state( new_file = True ))
        pool.purge( remote.purge_id, remote.purge_stop )
        remote.do_purge = False
        remote.purge_id = None
        remote.purge_stop = None
        process_tasks = True

    if remote.kill_ids:
        log.warning( 'pre-kill state dump: ' + pool.dump_state( new_file = True ))
        #pool.abdicate_and_kill( remote.kill_task_ids )
        pool.kill( remote.kill_task_ids )
        remote.kill_ids = False
        remote.kill_task_ids = {}
        process_tasks = True
        
    if remote.kill_rt:
        log.warning( 'pre-kill state dump: ' + pool.dump_state( new_file = True ))
        pool.abdicate_and_kill_rt( remote.kill_ctime )
        remote.kill_rt = False
        remote.kill_ctime = None
        process_tasks = True

    if remote.reset_a_task:
        log.warning( 'pre-reset state dump: ' + pool.dump_state( new_file = True ))
        pool.reset_task( remote.reset_task_id )
        remote.reset_a_task = False
        remote.reset_task_id = None
        process_tasks = True

    if remote.insert_this:
        if failout:
            if remote.insert_this == failout:
                print "resetting failout on " + failout + " prior to insertion"
                os.environ['FAILOUT_ID'] = ""
        log.warning( 'pre-insert state dump: ' + pool.dump_state( new_file = True ))
        pool.insertion( remote.insert_this )
        remote.insert_this = None
        process_tasks = True


    return [ halt, halt_now, process_tasks ]

def ns_obj_name( name, groupname ):
    # object name as registered with the Pyro nameserver
    return groupname + '.' + name

usage = """cylc schedule -s NAME [-n HOSTNAME] [options] [START] [STOP]

Start scheduling a system registered under the name NAME, via the Pyro
nameserver running on HOSTNAME (which defaults to localhost). You can
run multiple systems (and even multiple instances of the same system)
at once, so long as each instance is registered under a different name. 

To cold start system NAME, give the initial cycle time START. 

To restart system NAME, use '--restart' or '--restart-from=FILE'. 

If a final cycle time STOP is supplied, each task will stop when it
reaches that time, and then the system will shut down.

arguments:
  START                 Initial cycle time (YYYYMMDDHH) for a cold start
  STOP                  Optional final cycle time (YYYYMMDDHH)"""

def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( pns_host='localhost', restart=False, dummy_mode=False,
            clock_rate=10, clock_offset=24, task_proc_reason=False )

    parser.add_option( "-s", 
            help="Name of a registered cylc system to run",
            metavar="NAME", action="store", dest="system_name" )

    parser.add_option( "-n", 
            help="Hostname of the machine running the Pyro nameserver, "
            "defaults to localhost",
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "-r", 
            help="Restart from the system's configured state dump file",
            action="store_true", dest="restart" )

    parser.add_option( "--restart-from", 
            help="Restart from a named state dump file, assumed to be "
            "located in the system's configured state dump directory "
            "unless you give an absolute file path.",
            metavar="FILE", action="store", dest="restart_from" )

    parser.add_option( "-d",
            help="Run in accelerated time DUMMY MODE. System tasks will be "
            "faked by an external dummy program.",
            action="store_true", dest="dummy_mode" )

    parser.add_option( "--clock-rate", 
            help="(Dummy mode) accelerated clock rate, INT seconds = 1 hour "
            "(defaults to 10 sec = 1 hour).",
            metavar="INT", action="store", dest="clock_rate" )

    parser.add_option( "--clock-offset", 
            help="(Dummy mode) clock offset at start up. The dummy clock will "
            "start at INT hours prior to START cycle time (default 24 hours). "
            "Use to simulate catching up to real time operation.",
            metavar="HOURS", action="store", dest="clock_offset" )

    parser.add_option( "--fail", help=\
            "(Dummy mode) get a task to abort after reporting that "
            "it has failed. Use this to test failure and recovery "
            "scenarios. TASK_ID is 'NAME%YYYYMMDDHH'.",
            metavar="TASK-ID", action="store", dest="failout_task_id" )

    parser.add_option( "--reason", 
            help="(Debug) explain why the task processing loop was invoked",
            action="store_true", dest="task_proc_reason" )

    return parser

# =====================================================================
# MAIN PROGRAM
# =====================================================================

banner = {}

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

# get system name------------------------------------------------------
if not options.system_name:
    parser.error( "Required: system name" )
else:
    system_name = options.system_name
    banner[ 'system name' ] = system_name

# get Pyro nameserver hostname-----------------------------------------
if not options.pns_host:
    # (this won't happen; defaults to localhost)
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host
    banner[ 'Pyro nameserver hostname' ] = pns_host

# get mode of operation------------------------------------------------
if options.dummy_mode:
    dummy_mode = True
    banner[ 'mode of operation' ] = 'real'
else:
    dummy_mode = False
    banner[ 'mode of operation' ] = 'dummy'

# get startup configuration--------------------------------------------

startup = {}
if options.restart or options.restart_from:
    startup[ 'restart' ] = True
    if len( args ) == 0:
        start_time = None
        stop_time = None
        # default
        pass
    elif len( args ) == 1:
        # stop at given time
        stop_time = args[0]
        startup[ 'stop time' ] = stop_time
    else:
        parser.error( "wrong number of arguments" )

    if options.restart_from:
        startup[ 'state dump file' ] = options.restart_from
    else:
        startup[ 'state dump file' ] = None

else:
    startup[ 'restart' ] = False
    if len( args ) == 1:
        startup[ 'start time' ] = args[0]
    elif len( args ) == 2:
        startup[ 'start time' ] = args[0]
        startup[ 'stop time' ] = args[1]
    else:
        parser.error( "too many arguments" )

# check startup parameters---------------------------------------------
if 'start time' in startup.keys():
    start_time = startup['start time'] 
    if not cycle_time.is_valid( start_time ):
        parser.error( "invalid START time: " + start_time )

if 'stop time' in startup.keys():
    stop_time = startup['stop time'] 
    if not cycle_time.is_valid( stop_time ):
        parser.error( "invalid STOP time: " + stop_time )

if 'start time' not in startup.keys() \
        and not 'stop time' not in startup.keys() \
        and not startup[ 'restart' ]:
            parser.error( 'Supply a start time or specify a restart' )

# find location of the system task and config modules------------------
registration_file = os.environ['HOME'] + '/.cylc/registered/' + system_name
if os.path.exists( registration_file ):
    FILE = open( registration_file, 'r' )
    line = FILE.read()
    system_dir = line.rstrip() 
    FILE.close()
else:
    raise SystemExit( "No such system name registered: " + system_name )

banner[ 'system definition' ] = system_dir

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.
print system_dir
# add system scripts to $PATH
os.environ[ 'PATH' ] += ':' + system_dir + '/scripts'
# add system Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + system_dir

# provide access to the system source modules for THIS program---------
sys.path.append( system_dir )

# import system-specific cylc modules now------------------------------ 
import config        # loads system_config.py
import task_base     # loads system_tasks.py
import remote_switch # ditto

# load system configuration--------------------------------------------
system_config = config.config()

# set global (all tasks) environment variables-------------------------
os.environ[ 'PNS_HOST' ] = str( pns_host )
os.environ[ 'SYSTEM_NAME' ] = str( system_name )
if dummy_mode:
    os.environ[ 'CLOCK_RATE' ] = str( options.clock_rate )
    # communicate failout_task_id to the dummy task program
    if options.failout_task_id:
        print "FAILOUT: " + options.failout_task_id
        os.environ[ 'FAILOUT_ID' ] = options.failout_task_id

# extra global vars set in the system config file
env = system_config.get('environment')
for VAR in env.keys():
    os.environ[ VAR ] = env[ VAR ]

# LOCATE THE PYRO NAMESERVER-------------------------------------------
nameserver = locate_pyro_nameserver()

# CREATE A UNIQUE NAMESERVER GROUPNAME FOR THIS SYSTEM-----------------
create_ns_groupname( nameserver, system_name )
 
# REQUIRE SINGLE THREADED PYRO (see documentation)
Pyro.config.PYRO_MULTITHREADED = 0
Pyro.core.initServer()

# CREATE A PYRO DAEMON FOR THIS SYSTEM
daemon = Pyro.core.Daemon()
daemon.useNameServer(nameserver)

# system clock for accelerated time in dummy mode
clock = accelerated_clock.clock( 
        int(options.clock_rate),
        int(options.clock_offset),
        dummy_mode ) 

daemon.connect( clock, ns_obj_name( 'clock', system_name ))

# create logging dirs
logging_dir = system_config.get('logging_dir') 
if not os.path.exists( logging_dir ):
   os.makedirs(  logging_dir )
# top level logging
log = logging.getLogger( 'main' )
pimp_my_logger.pimp_it( log, 'main', system_config, dummy_mode, clock )
banner[ 'logging_dir' ] = logging_dir

state_dump_dir = system_config.get('state_dump_dir')
state_dump_file = state_dump_dir + '/' + system_config.get('state_dump_file')
banner[ 'state dump file' ] = state_dump_file
if os.path.exists( state_dump_file ):
    backup = state_dump_file + '.' + datetime.datetime.now().isoformat()
    shutil.copyfile( state_dump_file, backup )
    banner[ 'initial state dump backup' ] = backup
elif not os.path.exists( state_dump_dir ):
    os.makedirs( state_dump_dir )

# remotely accessible system state summary
system_state = state_summary.state_summary( system_config, dummy_mode )
daemon.connect( system_state, ns_obj_name( 'state_summary', system_name ))

# dead letter box for remote use
dead_letter_box = dead_letter.letter_box()
daemon.connect( dead_letter_box, ns_obj_name( 'dead_letter_box', system_name))

# load some command line options and dynamic stuff into config
# module, for easy handling.
system_config.put( 'daemon', daemon )
system_config.put( 'clock', clock )

# initialize the task manager
pool = manager.manager( system_config, system_name, dummy_mode, startup )

# remote control switch
remote = remote_switch.remote_switch( system_config, pool.get_tasks() )
daemon.connect( remote, ns_obj_name( 'remote', system_name) )

# print system information at startup----------------------------------
print_banner()
print "\nSTARTING\n"

count = 0
task_base.state_changed = True
system_halt = False
system_halt_now = False

while True: # MAIN LOOP
    [ halt, halt_now, process_tasks_remote ] = service_remote_requests( remote, pool, log, options.failout_task_id )
    if halt:
        system_halt = True
    if halt_now:
        system_halt_now = True

    process_tasks_contact = False
    if pool.waiting_contact_task_ready( clock.get_datetime() ):
        process_tasks_contact = True

    # PROCESS ALL TASKS whenever something has changed that might
    # require renegotiation of dependencies, etc.
    #--
    if task_base.state_changed or process_tasks_remote or process_tasks_contact:

        if options.task_proc_reason:
            # log reason for invoking task processing
            count = count + 1
            reasons = []
            if task_base.state_changed:
                reasons.append( 'task message received' )
            if process_tasks_remote:
                reasons.append( 'remote request serviced' )
            if process_tasks_contact:
                reasons.append( 'waiting contact task ready' )
            msg = ', '.join( reasons )
            # should really be log.debug() but warnings go to stdout...
            log.warning( 'task processing, ' + str( count ) + ': ' + msg )

        pool.spawn()

        pool.negotiate()

        pool.run_tasks()

        pool.cleanup()

        pool.dump_state()

        system_state.update( pool.tasks, clock )

    if pool.all_tasks_finished():
        log.critical( "ALL TASKS FINISHED" )
        break

    if system_halt_now or system_halt and pool.no_tasks_running():
        log.critical( "ALL RUNNING TASKS FINISHED" )
        break

    # REMOTE METHOD HANDLING; with no timeout and single-
    # threaded pyro, handleRequests() returns after one or
    # more remote method invocations are processed (these 
    # are not just task messages, hence the use of the
    # state_changed variable above).
    #--

    # incoming task messages set this to True
    task_base.state_changed = False
    # handle all remote calls
    daemon.handleRequests( timeout = None )

# END MAIN LOOP

print ""
print "STOPPING"
print ""
print "Shutting down my Pyro daemon"
daemon.shutdown( True )
print "Deleting Pyro nameserver group " + system_name
nameserver.deleteGroup( system_name )
print "Bye!"

# to simulate the effect on monitoring etc. of long task processing time
# (many many tasks...), put this in the task processing loop:
#if count % 50 == 0:
#    # every 50th time, sleep for 30s
#    print 'SLEEPING 30s!'
#    sleep(30)
