#!/usr/bin/python

# standard Python modules
import re, os, sys, shutil
#import profile
import logging
import datetime
from time import sleep
from optparse import OptionParser

# cycl source modules
import pyrex
import manager
import cycle_time
import dead_letter
import state_summary
import pimp_my_logger
import accelerated_clock 

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError

def print_banner():
    items = banner.keys() + startup.keys()

    longest_item = items[0]
    for item in items:
        if len(item) > len(longest_item):
            longest_item = item

    template = re.sub( '.', '.', longest_item )

    for item in banner.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( banner[ item ] )
    for item in startup.keys():
        print ' o ', re.sub( '^.{' + str(len(item))+ '}', item, template) + '...' + str( startup[ item ] )

def locate_pyro_nameserver():
    try:
        nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
    except NamingError:
        raise SystemExit("No Pyro nameserver found on " + pns_host )
    else:
        return nameserver

def create_ns_groupname( nameserver, groupname ):
    try:
        nameserver.createGroup( groupname )

    except NamingError:
        # abort if any existing objects are registered in my group name
        # (this may indicate another instance of cylc is running
        # with the same groupname; must be unique for each instance
        # else the different systems will interfere with each other) 
        print "\nERROR: group '" + groupname + "' is already registered"
        print "in the Pyro nameserver."
        objs = nameserver.list( groupname )
        if len( objs ) == 0:
            print "It currently contains no objects."
        else:
            print "It contains the following registered objects:"
            for obj in objs:
                print '  + ' + obj[0]

        print
        print "If the nameserver group is being used by another cylc"
        print "instance, re-register your system under a different name."
        print "using the 'cylc register' command."
        print 
        print "If the nameserver group is being used by a running cylc"
        print "instance of yours that you no longer need, shut it down"
        print "properly using the 'cylc control' command."
        print 
        print "If the nameserver group is a relic of an aborted cylc run"
        print "you can delete it manually from the nameserver as follows:"
        print 
        print "pyro-nsc deletegroup " + groupname + "   #<--DO-THIS-!" 
        print
        raise SystemExit( "ABORTING NOW" )

def service_remote_requests( remote, pool, log, failout = None ):

    halt = False
    halt_now = False
    process_tasks = False

    if remote.get_halt():
        # stop launching new tasks, but wait on running ones before
        # shutting down (otherwise they will generate screeds of
        # pyro-related error messages when they try to phone home).
        pool.set_system_hold()
        halt = True

    if remote.get_halt_now():
        # stop launching new tasks, NOW.
        # This must be used to shutdown the system if an external task
        # dies without notifying cylc.
        halt_now = True

    if remote.get_nudge():
        process_tasks = True
        remote.set_nudge = False

    if remote.get_hold():
        pool.set_system_hold()

    if remote.get_resume():
        pool.unset_system_hold()
        process_tasks = True

    if remote.set_stop:
        pool.set_stop_time( remote.stop_time )
        remote.set_stop = False

    if remote.set_hold:
        log.warning( 'pre-hold state dump: ' + pool.dump_state( new_file = True ))
        pool.set_system_hold( remote.hold_time )
        remote.set_hold = False

    if remote.do_purge:
        log.warning( 'pre-purge state dump: ' + pool.dump_state( new_file = True ))
        pool.purge( remote.purge_id, remote.purge_stop )
        remote.do_purge = False
        remote.purge_id = None
        remote.purge_stop = None
        process_tasks = True

    if remote.die_flag:
        log.warning( 'pre-kill state dump: ' + pool.dump_state( new_file = True ))
        pool.kill( [ remote.die_task ] )
        remote.die_flag = False
        remote.die_task = None
        process_tasks = True
 
    if remote.spawn_and_die_flag:
        log.warning( 'pre-kill state dump: ' + pool.dump_state( new_file = True ))
        pool.spawn_and_die( [ remote.spawn_and_die_task ] )
        remote.spawn_and_die_flag = False
        remote.spawn_and_die_task = None
        process_tasks = True
        
    if remote.reset_a_task:
        log.warning( 'pre-reset state dump: ' + pool.dump_state( new_file = True ))
        pool.reset_task( remote.reset_task_id )
        remote.reset_a_task = False
        remote.reset_task_id = None
        process_tasks = True

    if remote.insert_this:
        if failout:
            if remote.insert_this == failout:
                print "resetting failout on " + failout + " prior to insertion"
                os.environ['FAILOUT_ID'] = ""
        log.warning( 'pre-insert state dump: ' + pool.dump_state( new_file = True ))
        pool.insertion( remote.insert_this )
        remote.insert_this = None
        process_tasks = True


    return [ halt, halt_now, process_tasks ]

def ns_obj_name( name, groupname ):
    # object name as registered with the Pyro nameserver
    return groupname + '.' + name

usage = """cylc schedule [options] SYSTEM

Start scheduling a configured, registered, cylc system. 

To cold start a system give an initial cycle time. Each task in the task
list will be instantiated with a cycle time equal to the initial cycle
time, or to the first subsequent cycle time that is valid for that task.
At least one task must have no prerequisites, or nothing will happen. 

In a restart [-r], any task that was "submitted", "running" or "failed"
will be restarted in the "waiting" state.

arguments:
   SYSTEM               Registered name of the forecasting system.""" 

def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( pns_host='localhost', restart=False, dummy_mode=False,
            clock_rate=10, clock_offset=24, task_proc_reason=False )

    parser.add_option( "-s", "--start-at", 
            help="Initial cycle time (YYYYMMDDHH).",
            metavar="CYCLE", action="store", dest="start_time" )

    parser.add_option( "--stop-at", 
            help="Optional final cycle time (YYYYMMDDHH). The scheduler "
            "will shut down when each task has passed this cycle.",
            metavar="CYCLE", action="store", dest="stop_time" )

    parser.add_option( "-r", "--restart", 
            help="Restart from the system's configured state dump file",
            action="store_true", dest="restart" )

    parser.add_option( "--restart-from", 
            help="Restart from a named state dump file in the configured "
            "state dump directory, or give the file path.",
            metavar="FILE", action="store", dest="restart_from" )

    parser.add_option( "--exclude",
            help="Exclude these tasks at startup. Equivalent to "
            "deleting them from the system task list.",
            metavar="Task1,Task2,...", action="store", dest='exclude' )

    parser.add_option( "--include",
            help="Include only these tasks at startup. "
            "Equivalent to deleting all other tasks from the "
            "system task list.",
            metavar="Task1,Task2,...", action="store", dest='include' )

    parser.add_option( "-n", "--nameserver",
            help="Hostname of the machine running the Pyro nameserver, "
            "defaults to localhost",
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "-d", "--dummy-mode",
            help="DUMMY MODE: replace each real system task with a program "
            "that fakes its output messages on time, relative to an "
            "accelerated clock.",
            action="store_true", dest="dummy_mode" )

    parser.add_option( "--dummy-clock-rate", 
            help="(DUMMY MODE) accelerated clock rate: RATE seconds of "
            "real time per simulated hour (defaults to 10).",
            metavar="RATE", action="store", dest="clock_rate" )

    parser.add_option( "--dummy-clock-offset", 
            help="(DUMMY MODE) start the accelerated clock at HOURS "
            "prior to the initial cycle time (default 24 hours). "
            "This simulates catch up to real time operation.",
            metavar="HOURS", action="store", dest="clock_offset" )

    parser.add_option( "--fail-out", help=\
            "(DUMMY MODE) get task NAME at cycle time CYCLE to report failure "
            "and then abort. Use this to test failure and recovery scenarios.",
            metavar="NAME%CYCLE", action="store", dest="failout_task_id" )

    parser.add_option( "--proc-reason", 
            help="(debug) print the task processing loop reason.",
            action="store_true", dest="task_proc_reason" )

    return parser

# =====================================================================
# MAIN PROGRAM
# =====================================================================

banner = {}

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

# get system name------------------------------------------------------
reg_name = args[0]
banner[ 'system name' ] = reg_name

# get Pyro nameserver hostname-----------------------------------------
if not options.pns_host:
    # (this won't happen; defaults to localhost)
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host
    banner[ 'Pyro nameserver' ] = pns_host

# get mode of operation------------------------------------------------
if options.dummy_mode:
    dummy_mode = True
    banner[ 'mode of operation' ] = 'DUMMY'
else:
    dummy_mode = False
    banner[ 'mode of operation' ] = 'real'

# check startup configuration------------------------------------------

startup = {}

if options.start_time and ( options.restart or options.restart_from ):
    parser.error( "A start time does not make sense for a restart" )

if not options.start_time and not ( options.restart or options.restart_from ):
    parser.error( 'You must supply a start time or specify a restart' )

if options.start_time:
    startup[ 'restart' ] = False
    startup[ 'start time' ] = options.start_time
    if not cycle_time.is_valid( options.start_time ):
        parser.error( "invalid cycle time: " + options.start_time )
else:
    startup[ 'restart' ] = True

if options.stop_time:
    startup[ 'stop time' ] = options.stop_time
    if not cycle_time.is_valid( options.stop_time ):
        parser.error( "invalid cycle time: " + options.stop_time )

# find location of the system task and config modules------------------
registration_file = os.environ['HOME'] + '/.cylc/registered/' + reg_name
if os.path.exists( registration_file ):
    FILE = open( registration_file, 'r' )
    line = FILE.read()
    system_dir = line.rstrip() 
    FILE.close()
else:
    raise SystemExit( "No such system name registered: " + reg_name )

banner[ 'system definition' ] = system_dir

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.
print system_dir
# prepend system scripts to $PATH (prepend in case this is a subsystem!)
# (NOTE this is still somewhat dangerous: if a subsystem task script
# that should be executable but isn't has the same filename as a task in
# the parent system, the parent file will be found and executed).
os.environ['PATH'] = system_dir + '/scripts:' + os.environ['PATH'] 
# prepend add system Python modules to $PYTHONPATH (prepend, as above)
os.environ['PYTHONPATH'] = system_dir + ':' + os.environ['PYTHONPATH']

# provide access to the system source modules for THIS program---------
# prepend to the module search path in case this is a subsystem
sys.path.insert(0, system_dir )

# import system-specific cylc modules now------------------------------ 
from system_config import system_config 
import task_base     # loads task_specif.py
import remote_switch # ditto

# load system configuration--------------------------------------------
config = system_config( reg_name )
config.configure()

# LOCATE THE PYRO NAMESERVER-------------------------------------------
nameserver = locate_pyro_nameserver()

# CREATE A UNIQUE NAMESERVER GROUPNAME FOR THIS SYSTEM-----------------
groupname = os.environ['USER'] + '_' + reg_name
create_ns_groupname( nameserver, groupname )
banner[ 'Pyro nameserver group' ] = groupname
 
# REQUIRE SINGLE THREADED PYRO (see documentation)
Pyro.config.PYRO_MULTITHREADED = 0
Pyro.core.initServer()

# CREATE A PYRO DAEMON FOR THIS SYSTEM
daemon = Pyro.core.Daemon()
daemon.useNameServer(nameserver)

# system clock for accelerated time in dummy mode
clock = accelerated_clock.clock( 
        int(options.clock_rate),
        int(options.clock_offset),
        dummy_mode ) 

daemon.connect( clock, ns_obj_name( 'clock', groupname ))

# logging dir
logging_dir = config.get('logging_dir')

# set up main log already, for use in this module
log = logging.getLogger( 'main' )
pimp_my_logger.pimp_it( \
        log, 'main', config.get('logging_dir'), \
        config.get('logging_level'), dummy_mode, clock )

# state dump file
state_dump_file = config.get( 'state_dump_file' )
banner[ 'state dump file' ] = state_dump_file
if os.path.exists( state_dump_file ):
    backup = state_dump_file + '.' + datetime.datetime.now().isoformat()
    shutil.copyfile( state_dump_file, backup )
    banner[ 'state dump backup' ] = backup

if options.restart_from:
    filename = options.restart_from
    if not os.path.exists( filename ):
        # assume located in state dump dir
        filename = config.get('state_dump_dir') + '/' + filename
        if not os.path.exists( filename ):
            raise SystemExit( "ERROR: initial state dump not found" )

    startup[ 'initial state dump' ] = filename

if options.include and options.exclude:
    parser.error( '--include and --exclude are mutually exclusive' )

if options.exclude:
    exclude = options.exclude.split(',')
else:
    exclude = []
startup[ 'exclude' ] = exclude

if options.include:
    include = options.include.split(',')
else:
    include = []
startup[ 'include' ] = include


# remotely accessible system state summary
system_state = state_summary.state_summary( config, dummy_mode )
daemon.connect( system_state, ns_obj_name( 'state_summary', groupname ))

# dead letter box for remote use
dead_letter_box = dead_letter.letter_box()
daemon.connect( dead_letter_box, ns_obj_name( 'dead_letter_box', groupname))

# load some command line options and dynamic stuff into config
# module, for easy handling.
config.put( 'daemon', daemon )
config.put( 'clock', clock )

# initialize the task manager
pool = manager.manager( config, groupname, dummy_mode, startup )

# remote control switch
remote = remote_switch.remote_switch( config, pool.get_tasks() )
daemon.connect( remote, ns_obj_name( 'remote', groupname) )

# set global (all tasks) environment variables-------------------------
os.environ[ 'CYLC_ON' ] = 'true' # tells 'cylc message' to use the nameserver
os.environ[ 'CYLC_NS_HOST' ] = str( pns_host )  # may be an IP number
os.environ[ 'CYLC_NS_GROUP' ] = groupname
if dummy_mode:
    os.environ[ 'CLOCK_RATE' ] = str( options.clock_rate )
    # communicate failout_task_id to the dummy task program
    if options.failout_task_id:
        print "FAILOUT: " + options.failout_task_id
        os.environ[ 'FAILOUT_ID' ] = options.failout_task_id

# extra global vars set in the system config file
env = config.get('environment')
for VAR in env.keys():
    #print "! setting", VAR, '=', env[VAR]
    os.environ[ VAR ] = str( env[ VAR ] )

# print system information at startup----------------------------------
print_banner()
print
config.dump()
print "\nSTARTING\n"

count = 0
task_base.state_changed = True
system_halt = False
system_halt_now = False

while True: # MAIN LOOP
    [ halt, halt_now, process_tasks_remote ] = service_remote_requests( remote, pool, log, options.failout_task_id )
    if halt:
        system_halt = True
    if halt_now:
        system_halt_now = True

    process_tasks_contact = False
    if pool.waiting_contact_task_ready( clock.get_datetime() ):
        process_tasks_contact = True

    # PROCESS ALL TASKS whenever something has changed that might
    # require renegotiation of dependencies, etc.
    #--
    if task_base.state_changed or process_tasks_remote or process_tasks_contact:

        if options.task_proc_reason:
            # log reason for invoking task processing
            count = count + 1
            reasons = []
            if task_base.state_changed:
                reasons.append( 'task message received' )
            if process_tasks_remote:
                reasons.append( 'remote request serviced' )
            if process_tasks_contact:
                reasons.append( 'waiting contact task ready' )
            msg = ', '.join( reasons )
            # should really be log.debug() but warnings go to stdout...
            log.warning( 'task processing, ' + str( count ) + ': ' + msg )

        pool.spawn()

        pool.negotiate()

        pool.run_tasks()

        pool.cleanup()

        pool.dump_state()

        system_state.update( pool.tasks, clock )

    if pool.all_tasks_finished():
        log.critical( "ALL TASKS FINISHED" )
        break

    if system_halt_now or system_halt and pool.no_tasks_running():
        log.critical( "ALL RUNNING TASKS FINISHED" )
        break

    # REMOTE METHOD HANDLING; with no timeout and single-
    # threaded pyro, handleRequests() returns after one or
    # more remote method invocations are processed (these 
    # are not just task messages, hence the use of the
    # state_changed variable above).
    #--

    # incoming task messages set this to True
    task_base.state_changed = False
    # handle all remote calls
    daemon.handleRequests( timeout = None )

# END MAIN LOOP

print ""
print "STOPPING"
print ""
print "Shutting down my Pyro daemon"
daemon.shutdown( True )
print "Deleting Pyro nameserver group " + groupname
nameserver.deleteGroup( groupname )
print "Bye!"

# to simulate the effect on monitoring etc. of long task processing time
# (many many tasks...), put this in the task processing loop:
#if count % 50 == 0:
#    # every 50th time, sleep for 30s
#    print 'SLEEPING 30s!'
#    sleep(30)
