#!/usr/bin/python

# standard Python modules
import re, os, sys, shutil
#import profile
import logging
import datetime
from time import sleep
from optparse import OptionParser

# cycl source modules
import pyrex
import manager
import cycle_time
import dead_letter
import state_summary
import pimp_my_logger
import accelerated_clock 

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError

# auto-replace with version tag at build/install:
cylc_version = "REPLACE-ME"

def print_banner():
    print ""
    print "_______________C_Y_L_C___________________"
    print ". Self Organising Dynamic Metascheduler ."
    print ".     Hilary Oliver, NIWA, 2008-2010    ."
    print "_______________C_Y_L_C___________________"
    print "version: " + cylc_version
    print ""

def locate_pyro_nameserver():
    try:
        nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
    except NamingError:
        raise SystemExit("Failed to find a Pyro nameserver on " + pns_host )
    else:
        print "Using Pyro Nameserver on " + pns_host
        return nameserver

def create_ns_groupname( nameserver, groupname ):
    try:
        nameserver.createGroup( groupname )

    except NamingError:
        # abort if any existing objects are registered in my group name
        # (this may indicate another instance of cylc is running
        # with the same groupname; must be unique for each instance
        # else the different systems will interfere with each other) 
        print "\nERROR: group '" + groupname + "' is already registered"
        objs = nameserver.list( groupname )
        if len( objs ) == 0:
            print "(although it currently contains no registered objects)."
        else:
            print "And contains the following registered objects:"
            for obj in objs:
                print '  + ' + obj[0]

        print "\nOPTIONS:"
        print "(i) if the group is yours from a previous aborted run you can"
        print "    manually delete it with 'pyro-nsc deletegroup " + groupname +"'"
        print "(ii) if the group is being used by another program, change"
        print "    'system_name' in your config file to avoid interference.\n"

        raise SystemExit( "ABORTING NOW" )

    else:
        print "Created groupname '" + groupname + "' in the Pyro nameserver"

def service_remote_requests( remote, task_manager, log, failout = None ):

    halt = False
    halt_now = False
    process_tasks = False

    if remote.get_halt():
        # stop launching new tasks, but wait on running ones before
        # shutting down (otherwise they will generate screeds of
        # pyro-related error messages when they try to phone home).
        task_manager.set_system_hold()
        halt = True

    if remote.get_halt_now():
        # stop launching new tasks, NOW.
        # This must be used to shutdown the system if an external task
        # dies without notifying cylc.
        halt_now = True

    if remote.get_nudge():
        process_tasks = True
        remote.set_nudge = False

    if remote.get_hold():
        task_manager.set_system_hold()

    if remote.get_resume():
        task_manager.unset_system_hold()
        process_tasks = True

    if remote.set_stop:
        task_manager.set_stop_time( remote.stop_time )
        remote.set_stop = False

    if remote.set_hold:
        log.warning( 'pre-hold state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.set_system_hold( remote.hold_time )
        remote.set_hold = False

    if remote.do_purge:
        log.warning( 'pre-purge state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.purge( remote.purge_id, remote.purge_stop )
        remote.do_purge = False
        remote.purge_id = None
        remote.purge_stop = None
        process_tasks = True

    if remote.kill_ids:
        log.warning( 'pre-kill state dump: ' + task_manager.dump_state( new_file = True ))
        #task_manager.abdicate_and_kill( remote.kill_task_ids )
        task_manager.kill( remote.kill_task_ids )
        remote.kill_ids = False
        remote.kill_task_ids = {}
        process_tasks = True
        
    if remote.kill_rt:
        log.warning( 'pre-kill state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.abdicate_and_kill_rt( remote.kill_ctime )
        remote.kill_rt = False
        remote.kill_ctime = None
        process_tasks = True

    if remote.reset_a_task:
        log.warning( 'pre-reset state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.reset_task( remote.reset_task_id )
        remote.reset_a_task = False
        remote.reset_task_id = None
        process_tasks = True

    if remote.insert_this:
        if failout:
            if remote.insert_this == failout:
                print "resetting failout on " + failout + " prior to insertion"
                os.environ['FAILOUT_ID'] = ""
        log.warning( 'pre-insert state dump: ' + task_manager.dump_state( new_file = True ))
        task_manager.insertion( remote.insert_this )
        remote.insert_this = None
        process_tasks = True


    return [ halt, halt_now, process_tasks ]

def ns_obj_name( name, groupname ):
    # object name as registered with the Pyro nameserver
    return groupname + '.' + name

usage = """"cylc schedule -s NAME [-n HOSTNAME] [options] [START] [STOP]

Start up a cylc instance for scheduling system NAME via the Pyro
nameserver running on HOSTNAME (which defaults to localhost). 

To cold start a system, supply an initial cycle time START (YYYYMMDDHH). 

To restart a system, use the '--restart' or '--restart-from' options. 

If you supply a final cycle time STOP (YYYYMMDDHH) each task will stop 
when it reaches that time, and then the system will shut down."""

def commandline_parser():
    parser = OptionParser( usage )

    parser.add_option( "-s", 
            help="Name of the configured cylc system",
            metavar="NAME", action="store", dest="system_name" )

    parser.add_option( "-n", 
            help="Hostname of the machine running the Pyro nameserver, "
            "defaults to localhost",
            metavar="HOSTNAME", action="store", default="localhost",
            dest="pns_host" )

    parser.add_option( "-r", 
            help="Restart from the system's configured state dump file",
            action="store_true", default=False, dest="restart" )

    parser.add_option( "--restart-from", 
            help="Restart from a named state dump file, assumed to be "
            "located in the system's configured state dump directory "
            "unless you give an absolute file path.",
            metavar="STATE", action="store", dest="restart_from" )

    parser.add_option( "-d",
            help="Run in accelerated time DUMMY MODE. System tasks will be "
            "faked by an external dummy program.",
            action="store_true", default=False, dest="dummy_mode" )

    parser.add_option( "--clock-rate", 
            help="(Dummy mode) accelerated clock rate, INT seconds = 1 hour "
            "(defaults to 10 sec = 1 hour).",
            metavar="INT", action="store", default=10, dest="clock_rate" )

    parser.add_option( "--clock-offset", 
            help="(Dummy mode) clock offset at start up. The dummy clock will "
            "start at INT hours prior to START cycle time (default 24 hours). "
            "Use to simulate catching up to real time operation.",
            metavar="HOURS", action="store", default=24, dest="clock_offset" )

    parser.add_option( "--fail", help=\
            "(Dummy mode) get a task to abort after reporting that "
            "it has failed. Use this to test failure and recovery "
            "scenarios. TASK_ID is 'NAME%YYYYMMDDHH'.",
            metavar="TASK-ID", action="store", dest="failout_task_id" )

    parser.add_option( "--reason", 
            help="(Debug) explain why the task processing loop was invoked",
            action="store_true", default=False, dest="task_proc_reason" )

    return parser

# =====================================================================
# MAIN PROGRAM
# =====================================================================

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

# check compulsory arguments-------------------------------------------
if not options.system_name:
    parser.error( "Required: system name" )
if not options.pns_host:
    # (this won't happen; defaults to localhost)
    parser.error( "Required: Pyro nameserver hostname" )

pns_host = options.pns_host
system_name = options.system_name

dummy_mode = False
if options.dummy_mode:
    dummy_mode = True

# find location of the system task and config modules------------------
FILE = open( os.environ['HOME'] + '/.cylc/configured/' + system_name, 'r' )
line = FILE.read()
system_dir = line.rstrip() 
FILE.close()

# configure the execution environment for task scripts launched by cylc
print "Configuring your environment for system " + system_name
print system_dir
# add system scripts to $PATH
os.environ[ 'PATH' ] += ':' + system_dir + '/scripts'
# add system Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + system_dir

# add system dir to the module search path for this program------------
sys.path.append( system_dir )

# import system-specific cylc modules now------------------------------ 
import config        # loads system_config.py
import task_base     # loads system_tasks.py
import remote_switch # ditto

print_banner()

# load system configuration--------------------------------------------
system_config = config.config()

if options.system_name != system_config.get( 'system_name' ):
    # this should never happen
    raise SystemExit( 'ERROR: configured system and command line disagree' )

restart_from = None
restart = False
start_time = None
stop_time = None

if options.restart or options.restart_from:
    restart = True
    # cylc schedule --system=NAME --restart [STOP]
    # cylc schedule --system=NAME --restart-from=STATE [STOP]
    if len( args ) == 0:
        # default
        pass
    elif len( args ) == 1:
        stop_time = args[0]
    else:
        parser.error( "wrong number of arguments" )

else:
    # cylc schedule --system=NAME START [STOP]
    if len( args ) == 1:
        start_time = args[0]
    elif len( args ) == 2:
        start_time = args[0]
        stop_time = args[1]
    else:
        parser.error( "too many arguments" )
     
if start_time:
    if not cycle_time.is_valid( start_time ):
        parser.error( "invalid START time" )

if stop_time:
    if not cycle_time.is_valid( stop_time ):
        parser.error( "invalid STOP time" )

if not start_time and \
        not options.restart and \
        not options.restart_from: 
    parser.error( 'Either supply start time or restart' )
       
# set configured global (all tasks) environment variables
os.environ[ 'PNS_HOST' ] = str( pns_host )
os.environ[ 'SYSTEM_NAME' ] = str( system_name )
if dummy_mode:
    os.environ[ 'CLOCK_RATE' ] = str( options.clock_rate )
    # communicate failout_task_id to the dummy task program
    if options.failout_task_id:
        print "FAILOUT: " + options.failout_task_id
        os.environ[ 'FAILOUT_ID' ] = options.failout_task_id

env = system_config.get('environment')
for VAR in env.keys():
    os.environ[ VAR ] = env[ VAR ]

if dummy_mode:
    print "RUNNING IN DUMMY MODE"

# LOCATE THE PYRO NAMESERVER-------------------------------------------
nameserver = locate_pyro_nameserver()

# CREATE A UNIQUE NAMESERVER GROUPNAME FOR THIS SYSTEM-----------------
create_ns_groupname( nameserver, system_name )
 
# REQUIRE SINGLE THREADED PYRO (see documentation)
Pyro.config.PYRO_MULTITHREADED = 0
Pyro.core.initServer()

# CREATE A PYRO DAEMON FOR THIS SYSTEM
daemon = Pyro.core.Daemon()
daemon.useNameServer(nameserver)

# system clock for accelerated time in dummy mode
clock = accelerated_clock.clock( 
        int(options.clock_rate),
        int(options.clock_offset),
        dummy_mode ) 


daemon.connect( clock, ns_obj_name( 'clock', system_name ))

print "CREATING MAIN LOG......."
# create logging dirs
if not os.path.exists( system_config.get('logging_dir') ):
   os.makedirs( system_config.get('logging_dir') )
# top level logging
log = logging.getLogger( 'main' )
pimp_my_logger.pimp_it( log, 'main', system_config, dummy_mode, clock )

state_dump_dir = system_config.get('state_dump_dir')
state_dump_file = state_dump_dir + '/' + system_config.get('state_dump_file')

if os.path.exists( state_dump_file ):
    print "STATE DUMP BACKUP..."
    backup = state_dump_file + '.' + datetime.datetime.now().isoformat()
    print ' + ' + backup
    shutil.copyfile( state_dump_file, backup )

elif not os.path.exists( state_dump_dir ):
    print "STATE DUMP DIR..."
    os.makedirs( state_dump_dir )

# remotely accessible system state summary
system_state = state_summary.state_summary( system_config, dummy_mode )
daemon.connect( system_state, ns_obj_name( 'state_summary', system_name ))

# dead letter box for remote use
dead_letter_box = dead_letter.letter_box()
daemon.connect( dead_letter_box, ns_obj_name( 'dead_letter_box', system_name))

# load some command line options and dynamic stuff into config
# module, for easy handling.
system_config.put( 'daemon', daemon )
system_config.put( 'system_name', system_name )
system_config.put( 'clock', clock )
system_config.put( 'restart', restart )
system_config.put( 'start_time', start_time )
system_config.put( 'stop_time', stop_time )
system_config.put( 'restart_from', restart_from )

# initialize the task manager
task_manager = manager.manager( system_config, dummy_mode )

# remote control switch
remote = remote_switch.remote_switch( system_config, task_manager.get_tasks() )
daemon.connect( remote, ns_obj_name( 'remote', system_name) )

print "\nBeginning task scheduling NOW\n"

try:
    # attempt a clean shutdown if anything goes wrong from here on

    count = 0
    task_base.state_changed = True
    system_halt = False
    system_halt_now = False

    while True: # MAIN LOOP
        [ halt, halt_now, process_tasks_remote ] = service_remote_requests( remote, task_manager, log, options.failout_task_id )
        if halt:
            system_halt = True
        if halt_now:
            system_halt_now = True

        process_tasks_contact = False
        if task_manager.waiting_contact_task_ready( clock.get_datetime() ):
            process_tasks_contact = True

        # PROCESS ALL TASKS whenever something has changed that might
        # require renegotiation of dependencies, etc.
        #--
        if task_base.state_changed or process_tasks_remote or process_tasks_contact:

            if options.task_proc_reason:
                # log reason for invoking task processing
                count = count + 1
                reasons = []
                if task_base.state_changed:
                    reasons.append( 'task message received' )
                if process_tasks_remote:
                    reasons.append( 'remote request serviced' )
                if process_tasks_contact:
                    reasons.append( 'waiting contact task ready' )
                msg = ', '.join( reasons )
                # should really be log.debug() but warnings go to stdout...
                log.warning( 'task processing, ' + str( count ) + ': ' + msg )

                # simulate the effect on monitoring etc. of long task
                # processing time (many many tasks...)
                #if count % 50 == 0:
                #    # every 50th time, sleep for 30s
                #    print 'SLEEPING 30s!'
                #    sleep(30)

            task_manager.regenerate_tasks()

            task_manager.negotiate_dependencies()

            task_manager.run_tasks()

            task_manager.kill_spent_tasks()

            task_manager.dump_state()

            system_state.update( task_manager.tasks, clock )

        if task_manager.all_tasks_finished():
            daemon.shutdown( True )
            nameserver.deleteGroup( system_name )
            msg = "ALL TASKS FINISHED" 
            print msg
            log.critical( msg )
            raise SystemExit

        if system_halt_now or system_halt and task_manager.no_tasks_running():
            daemon.shutdown( True )
            nameserver.deleteGroup( system_name )
            msg = "ALL RUNNING TASKS FINISHED" 
            print msg
            log.critical( msg )
            raise SystemExit

        # REMOTE METHOD HANDLING; with no timeout and single-
        # threaded pyro, handleRequests() returns after one or
        # more remote method invocations are processed (these 
        # are not just task messages, hence the use of the
        # state_changed variable above).
        #--

        # incoming task messages set this to True
        task_base.state_changed = False
        # handle all remote calls
        daemon.handleRequests( timeout = None )

     # END MAIN LOOP

except Exception:
    daemon.shutdown( True )
    nameserver.deleteGroup( system_name )
    msg = "ERROR OCCURED IN CYCL"
    print msg
    log.critical( msg )
    raise SystemExit( msg )
