#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


"""
Dump the current state of all suite tasks to stdout.
"""

import cylc_pyro_ns
from cycle_time import _rt_to_dt, is_valid
import os, re, sys
import Pyro.core
from time import sleep
from CylcOptionParsers import NoPromptOptionParser_u

parser = NoPromptOptionParser_u( """cylc dump [options] SUITE 

Print suite and task state information to stdout. All available
information is printed by default. Output is designed to be
grep-friendly. For small suites 'watch cylc dump SUITE' is an 
effective non-gui real time monitor.

For more information about a specific task, such as the current 
state of each registered prerequisite and output, see 'cylc show'.

Examples:
 Display the state of all running tasks, sorted by cycle time:
 % cylc dump -ts SUITE | grep running

 Display the state of all tasks in a particular cycle:
 % cylc dump -t SUITE | grep 2010082406""")

parser.add_option( "-g", "--global", help="Global information only.",
        action="store_true", default=False, dest="global_only" )

parser.add_option( "-t", "--tasks", help="Task states only.",
        action="store_true", default=False, dest="tasks_only" )

parser.add_option( "-s", "--sort", help="Task states only; "
        "sort by cycle instead of name.",
        action="store_true", default=False, dest="sort_by_cycle" )

( options, args ) = parser.parse_args()

# default: display all information
display_tasks = True
display_global = True
# check for restricted output
if options.global_only:
    display_tasks = False
if options.tasks_only:
    display_global = False

suite_name = parser.get_suite_name()
pns_host = parser.get_pns_host()
groupname = parser.get_groupname()

# get suites currently registered in the Pyro nameserver
ns_groups = cylc_pyro_ns.ns( pns_host )

#print 'SUITE INFORMATION'

if ns_groups.registered( groupname ):
    if display_global:
        print "suite name: " + suite_name
else:
    SystemExit( "No " + groupname + " group registered with the Pyro nameserver" )

# TO DO: BETTER EXCEPTION HANDLING FOR PYRO CONNECTIONS ETC HERE (e.g.
# see monitor, for example) TimeoutError, ConnectionClosedError,
# ProtocolError; and maybe use 'cylc ping' to check that the suite is
# running first.

# connect to remote suite state summary object
try:
    god = Pyro.core.getProxyForURI('PYRONAME://' + pns_host + '/' + groupname + '.state_summary')
    # timeout (sec) determines max wait for an answer from god.
    # god._setTimeout(60)
except Exception, x:
    print "ERROR: Failed to connect to suite"
    print x
    sys.exit(1)

try:
    # get state summary, task names, cycle times
    [glbl, states] = god.get_state_summary()
except Exception, x:
    print "ERROR: Failed to retrieve suite state summary"
    print x
    sys.exit(1)

if display_global:

    dummy_mode = glbl[ 'dummy_mode' ]
    if dummy_mode:
        print 'DUMMY MODE (clock rate: ', glbl[ 'dummy_clock_rate' ], ')'

    dt = glbl[ 'last_updated' ]
    print 'last summary update: ' +  dt.strftime( "%Y/%m/%d %H:%M:%S" )

    if glbl['paused']:
        print 'PAUSED'

    if glbl['stopping']:
        print 'STOPPING'

    pausing_at = glbl['will_pause_at']
    if pausing_at:
        print 'PAUSING AT ' + pausing_at

    stopping_at = glbl['will_stop_at']
    if stopping_at:
        print 'STOPPING AT ' + stopping_at

if display_tasks:
    lines = []
    #print 'TASK INFORMATION'
    task_ids = states.keys()
    #task_ids.sort()
 
    for id in task_ids:
        name = states[ id ][ 'name' ]
        short_name = states[ id ][ 'short_name' ]
        ctime = states[ id ][ 'label' ]
        state      = states[ id ][ 'state' ]

        if states[ id ][ 'spawned' ]:
            spawned = 'spawned'
        else:
            spawned = 'unspawned'

        if options.sort_by_cycle:
            lines.append( ctime + ', ' + name + ', ' + state + ', ' + spawned )
        else:
            lines.append( name + ', ' + ctime + ', ' + state + ', ' + spawned )

    lines.sort()
    for line in lines:
        print line
     
