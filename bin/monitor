#!/usr/bin/python

"""
Display the state of all existing tasks.

NOT SUITABLE FOR VERY LARGE TASK SETS.

ONLY DETECTS DUMMY VS REAL TIME AT STARTUP

For color terminal ASCII escape codes, see
http://ascii-table.com/ansi-escape-sequences.php
"""

import os
import re
import sys
import datetime
import Pyro.core
import Pyro.naming
from time import sleep
from optparse import OptionParser

# cyclon modules:
import pyrex
from reference_time import _rt_to_dt

compress = True

# construct a command line parser
parser = OptionParser( "%prog [options]" )

parser.add_option( "-c", "--configured", help="use configured system",
        action="store_true", default=False, dest="use_configured" )

parser.add_option( "-n", "--name", help="system name",
        metavar="SYSTEM-NAME", action="store", dest="system_name" )

parser.add_option( "-a", "--align", help="align columns",
        action="store_true", default=False, dest="align_columns" )

parser.add_option( "-p", "--print", help="print registered systems",
        action="store_true", default=False, dest="print_systems" )

parser.add_option( "-s", "--shortnames", help="display short tasknames",
        action="store_true", default=False, dest="shortnames" )

# get command line options and positional args
( options, args ) = parser.parse_args()

#if len( args ) != 0:
#    parser.print_help()
#    sys.exit(1)

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover()

if options.use_configured:
    # use the configured system
    import config
    config = config.config()
    config.load()
    system_name = config.get( 'system_name' )

elif options.system_name:
    # use the given system name
    system_name = options.system_name
    if ns_groups.registered( system_name ):
        print "system: " + system_name
    else:
        print "WARNING: no " + system_name + " registered yet ..." 

elif options.print_systems:
    # print registered systems
    ns_groups.print_info()
    sys.exit(0)

else:
    # print available systems and exit
    parser.print_help()
    print
    ns_groups.print_info()
    sys.exit(0)

print
print "here we go ..."
sleep(2)

while True:
    # keep try to connect to the chosen remote system

    try: 
        # connect to remote state summary object for the chosen system
        god = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.state_summary')
        god._setTimeout(10)

        # are we in dummy mode or not?
        dummy_mode = god.get_dummy_mode()
        if dummy_mode:
            # connect to the accelerated dummy mode clock
            remote_clock = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.dummy_clock' )
            remote_clock._setTimeout(10)
            rate = str( god.get_dummy_clock_rate() )

        while True:
            # continual redisplay loop

            if dummy_mode:
                # get current time from dummy clock
                dt = remote_clock.get_datetime()
            else:
                # get current real time
                dt = datetime.datetime.now()

            try:
                # get state summary, list of task names, and list of
                # reference times
                states = god.get_state_summary()

                if options.shortnames:
                    name_list = god.get_short_name_list()
                else:
                    name_list = god.get_name_list()

                ref_time_list = god.get_ref_time_list()
            except Exception,x:
                print ''.join(Pyro.util.getPyroTraceback(x))
                sys.exit(1)

            task_ids = states.keys()
            task_ids.sort()
            name_list.sort()
            ref_time_list.sort()
            catchup_info = {}

            # initialize a dict-of-dicts to store display information
            # for all tasks at each current reference time
            #   task_info[ ref_time ][ task_name ] = info
            task_info = {}
            for rt in ref_time_list:
                task_info[ rt ] = {}
                for name in name_list:
                    # initialise with blank string of the same size as
                    # the real info that we will use below
                    tmp = name + '*'  # name plus abdication indicator
                    tmp = re.sub( '.', ' ', tmp )
                    task_info[ rt ][name] = tmp

            ctrl_end = "\033[0m"

            # now loop through all tasks in the system and assign their
            # disply info to the correct place in the task_info structure
            for task_id in task_ids:

                if options.shortnames:
                    name     =      states[ task_id ][ 'short_name' ]
                else:
                    name     =      states[ task_id ][ 'name' ]

                reftime  =      states[ task_id ][ 'reference_time' ]
                state    =      states[ task_id ][ 'state' ]

                if not states[ task_id ][ 'abdicated' ]:
                    # identify any tasks that have not abdicated yet
                    abd = '*'
                else:
                    # space of same length
                    abd = ' '

                if 'catching_up' in states[ task_id ].keys():
                    # get catchup status for any contact tasks
                    # (this is a class variable for each task type,
                    # not stored for each individual task object).
                    catchup_info[ name ] = states[ task_id ][ 'catching_up' ]

                # color displayed info according to run status
                if state == "running":
                    ctrl_start = "\033[1;37;42m"
                elif state == "waiting":
                    ctrl_start = "\033[35m"
                elif state == "failed":
                    ctrl_start = "\033[1;37;41m"
                else:
                    # finished
                    ctrl_start = ""

                # construct the display string for this task
                task_info[ reftime ][ name ] = ctrl_start + name + ctrl_end + abd
                

            # construct an array of lines to blit to the screen

            # MONITOR HEADER
            blit = []
            blit.append( '\033[1;37;40m  cyclon  system  monitor  ' + ctrl_end )
            blit.append( "\033[0;35mwaiting\033[0m \033[1;37;42mrunning\033[0m done \033[1;37;41mfailed\033[0m")
            blit.append( '*' + ' => task not yet abdicated' )

            # DUMMY MODE, or not
            if dummy_mode:
                blit.append( 'DUMMY MODE: ' + rate + ' sec = 1 hr' )
            else:
                blit.append( 'REAL MODE' )
            
            # CURRENT SYSTEM TIME
            blit.append( "\033[1;37;46m" + system_name + ctrl_end + ' \033[1;37;31m' + dt.strftime( "%Y/%m/%d %H:%M:%S" ) + '\033[0m' )

            # CATCHUP INFO for any contact tasks
            for name in catchup_info.keys():
                if catchup_info[ name ]:
                    blit.append( name + ': catching up' )
                else:
                    blit.append( name + ': caught up' )

            blit.append("")

            # construct a line of text to display for each reference time
            for rt in ref_time_list:
                line = ''
                # colour reference time according to whether it has
                # caught up to the current clock time or not.
                rtdt = _rt_to_dt( rt )
                if dt > rtdt:
                    # behind
                    line = '\033[1;34m' + rt + ctrl_end
                else:
                    # caught up
                    line = '\033[1;31m' + rt + ctrl_end

                # add info for each task to the line
                for name in name_list:
                    disp = task_info[rt][name]
                    if not options.align_columns and re.match( '^\s+$', disp ): 
                        # don't add white space unless align_columns has
                        # been requested by the user
                        pass
                    else:
                        line = line + ' ' + disp

                blit.append( line )

            # clear screen and blit the new information up
            os.system( "clear" )
            for line in blit:
                print line
            sleep(0.5)

    except:
        # uncomment 'raise' to identify errors
        # raise
        print "failed..."
        sleep( 1 )
