#!/usr/bin/python

"""
Display the state of all existing tasks.

NOTE: ONLY DETECTS DUMMY MODE VS REAL TIME MODE AT STARTUP
(so restart this if you restart sequenz in different mode)

For color terminal ASCII escape codes, see
http://ascii-table.com/ansi-escape-sequences.php
"""

import os
import re
import sys
import datetime
import Pyro.core
import Pyro.naming
from time import sleep
from string import split
from optparse import OptionParser

# sequenz modules:
import pyrex
from reference_time import _rt_to_dt

# construct a command line parser
parser = OptionParser( "%prog [options]" )

parser.add_option( "-c", "--configured", help="use configured system",
        action="store_true", default=False, dest="use_configured" )

parser.add_option( "-n", "--name", help="system name",
        metavar="SYSTEM-NAME", action="store", dest="system_name" )

parser.add_option( "-p", "--print", help="print registered systems",
        action="store_true", default=False, dest="print_systems" )

parser.add_option( "-f", "--fraction", help="show completion fraction",
        action="store_true", default=False, dest="show_completion" )

# get command line options and positional args
( options, args ) = parser.parse_args()

#if len( args ) != 0:
#    parser.print_help()
#    sys.exit(1)

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover()

if options.use_configured:
    # use the configured system
    import config
    config = config.config()
    config.load()
    system_name = config.get( 'system_name' )

elif options.system_name:
    # use the given system name
    system_name = options.system_name
    if ns_groups.registered( system_name ):
        print "system: " + system_name
    else:
        print "WARNING: no " + system_name + " registered yet ..." 

elif options.print_systems:
    # print registered systems
    ns_groups.print_info()
    sys.exit(0)

else:
    # print available systems and exit
    parser.print_help()
    print
    ns_groups.print_info()
    sys.exit(0)

print
print "here we go ..."
sleep(2)

while True:

    try: 
        god = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.state_summary')
        god._setTimeout(10)

        dummy_mode = god.get_dummy_mode()

        if dummy_mode:
            remote_clock = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.dummy_clock' )
            remote_clock._setTimeout(10)
            rate = str( god.get_dummy_clock_rate() )

        while True:

            if dummy_mode:
                dt = remote_clock.get_datetime()
            else:
                dt = datetime.datetime.now()

            lines = {}
            # TO DO: wrap all remote calls like this, to get remote
            # traceback in case of error:
            try:
                states = god.get_state_summary()
            except Exception,x:
                print ''.join(Pyro.util.getPyroTraceback(x))
                sys.exit(1)

            task_ids = states.keys()
            task_ids.sort()
            catchup_info = {}

            for task_id in task_ids:
                name     =      states[ task_id ][ 'name' ]
                reftime  =      states[ task_id ][ 'reference_time' ]
                state    =      states[ task_id ][ 'state' ]
                complete = str( states[ task_id ][ 'n_completed_postrequisites' ] )
                total    = str( states[ task_id ][ 'n_total_postrequisites' ] )
                latest   =      states[ task_id ][ 'latest_message' ]

                if 'catching_up' in states[ task_id ].keys():
                    catchup_info[ name ] = states[ task_id ][ 'catching_up' ]

                if state == "running":
                    ctrl_start = "\033[1;37;42m"

                elif state == "waiting":
                    ctrl_start = "\033[35m"

                elif state == "failed":
                    ctrl_start = "\033[1;37;41m"

                else:
                    # finished
                    ctrl_start = ""

                ctrl_end = "\033[0m"

                if options.show_completion:
                    frac = "(" + str(complete) + "/" + str(total) + ")"
                    disp = name + frac
                else:
                    disp = name

                disp = ctrl_start + disp + ctrl_end

                if not states[ task_id ][ 'abdicated' ]:
                    # identify any tasks that have not abdicated yet
                    #disp = "\033[1;37;43m" + '*' + ctrl_end + disp
                    disp = disp + '*'
                else:
                    # space of same length
                    disp = disp + ' '

                hour = int( reftime[8:10] )

                if reftime in lines.keys():
                    lines[reftime] += ' ' + disp
                else:
                    lines[reftime] = reftime + "\033[0m " + disp
                
            # sort reference times using int( string )
            reftimes = lines.keys()
            reftimes.sort( key = int )

            blit = []
            blit.append( '\033[1;37;40m Sequenz  System  Monitor  ' + ctrl_end )
            blit.append( "\033[0;35mwaiting\033[0m \033[1;37;42mrunning\033[0m done \033[1;37;41mfailed\033[0m")
            blit.append( '*' + ' => task not yet abdicated' )

            if dummy_mode:
                blit.append( 'DUMMY MODE: ' + rate + ' sec = 1 hr' )
            else:
                blit.append( 'REAL MODE' )
            
            blit.append( "\033[1;37;46m" + system_name + ctrl_end + ' \033[1;37;31m' + dt.strftime( "%Y/%m/%d %H:%M:%S" ) + '\033[0m' )

            for name in catchup_info.keys():
                if catchup_info[ name ]:
                    blit.append( name + ': catching up' )
                else:
                    blit.append( name + ': caught up' )

            blit.append("")

            for rt in reftimes:
                # colour reference time relative to clock time
                rtdt = _rt_to_dt( rt )
                if dt > rtdt:
                    disp = '\033[1;34m'
                else:
                    disp = '\033[1;31m'
                blit.append( disp + lines[rt] )

            os.system( "clear" )
            for line in blit:
                print line
            sleep(0.5)

    except:
        # uncomment 'raise' to identify errors
        #raise
        print "failed..."
        sleep( 1 )
