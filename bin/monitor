#!/usr/bin/python

"""
Display the state of all existing tasks.

NOTE: ONLY DETECTS DUMMY MODE VS REAL TIME MODE AT STARTUP
(so restart this if you restart sequenz in different mode)

For color terminal ASCII escape codes, see
http://ascii-table.com/ansi-escape-sequences.php
"""

import os
import re
import sys
import pyrex
import datetime
import Pyro.core
import Pyro.naming
from time import sleep
from string import split
from optparse import OptionParser
from reference_time import _rt_to_dt

# construct a command line parser
parser = OptionParser( "%prog [options]" )

parser.add_option( "-c", "--configured", help="use configured system",
        action="store_true", default=False, dest="use_configured" )

parser.add_option( "-n", "--name", help="system name",
        metavar="SYSTEM-NAME", action="store", dest="system_name" )

parser.add_option( "-p", "--print", help="print registered systems",
        action="store_true", default=False, dest="print_systems" )

# get command line options and positional args
( options, args ) = parser.parse_args()

#if len( args ) != 0:
#    parser.print_help()
#    sys.exit(1)

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover()

if options.use_configured:
    # use the configured system
    import config
    config = config.config()
    config.load()
    system_name = config.get( 'system_name' )

elif options.system_name:
    # use the given system name
    system_name = options.system_name
    if ns_groups.registered( system_name ):
        print "system: " + system_name
    else:
        print "WARNING: no " + system_name + " registered yet ..." 

else:
    # print available systems and exit
    parser.print_help()
    print
    ns_groups.print_info()
    sys.exit(0)

print
print "here we go ..."
sleep(2)

while True:

    try: 
        god = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.state_summary')
        god._setTimeout(10)

        dummy_mode = god.get_dummy_mode()

        if dummy_mode:
            remote_clock = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.dummy_clock' )
            remote_clock._setTimeout(10)
            mode = 'dummy mode' 
        else:
            mode = 'real time'

        while True:

            if dummy_mode:
                dt = remote_clock.get_datetime()
            else:
                dt = datetime.datetime.now()

            lines = {}
            # TO DO: wrap all remote calls like this, to get remote
            # traceback in case of error:
            try:
                states = god.get_state_summary()
            except Exception,x:
                print ''.join(Pyro.util.getPyroTraceback(x))
                sys.exit(1)

            task_ids = states.keys()
            task_ids.sort()

            for task_id in task_ids:
                name     =      states[ task_id ][ 'name' ]
                reftime  =      states[ task_id ][ 'reference_time' ]
                state    =      states[ task_id ][ 'state' ]
                complete = str( states[ task_id ][ 'n_completed_postrequisites' ] )
                total    = str( states[ task_id ][ 'n_total_postrequisites' ] )
                latest   =      states[ task_id ][ 'latest_message' ]

                ctrl_end = "\033[0m"

                frac = "(" + str(complete) + "/" + str(total) + ")"

                if state == "running":
                    foo = "\033[1;37;42m" + name + frac + ctrl_end  # bold white on green

                elif state == "waiting":
                    foo = "\033[35m" + name + ctrl_end              # magenta

                elif state == "failed":
                    foo = "\033[1;37;41m" + name + ctrl_end         # bold white on red

                else:
                    foo = name

                # identify any tasks that have not abdicated yet
                if not states[ task_id ][ 'abdicated' ]:
                    foo = "\033[1;37;43m" + '*' + ctrl_end + foo

                hour = int( reftime[8:10] )

                if reftime in lines.keys():
                    lines[reftime] += ' ' + foo
                else:
                    lines[reftime] = reftime + "\033[0m " + foo
                
            # sort reference times using int( string )
            reftimes = lines.keys()
            reftimes.sort( key = int )

            blit = [ "\033[1;37;46m" + system_name + ctrl_end + ' ' + mode ]
            blit.append( '\033[1;37;34m ' + dt.strftime( "%Y/%m/%d %H:%M:%S" ) + '\033[0m' )
            blit.append( "\033[0;35mwaiting\033[0m \033[1;37;42mrunning\033[0m done \033[1;37;41mfailed\033[0m")
            blit.append( '\033[1;37;43m' + '*' + '\033[0m' + ' => task not yet abdicated' )
            blit.append( '============================' )
            blit.append("")
            for rt in reftimes:
                # colour reference time relative to clock time
                rtdt = _rt_to_dt( rt )
                if dt > rtdt:
                    foo = '\033[1;35m'
                else:
                    foo = '\033[1;34m'
                blit.append( foo + lines[rt] )

            os.system( "clear" )
            for line in blit:
                print line
            sleep(0.5)

    except:
        # uncomment 'raise' to identify errors
        #raise
        print "connection failed ..."
        sleep( 1 )
