#!/usr/bin/python

"""
Display the state of all existing tasks.

NOT SUITABLE FOR VERY LARGE TASK SETS.

ONLY DETECTS DUMMY VS REAL TIME AT STARTUP

For color terminal ASCII escape codes, see
http://ascii-table.com/ansi-escape-sequences.php
"""

import os
import re
import sys
import Pyro.core
import Pyro.naming
from Pyro.errors import PyroError,NamingError,ConnectionClosedError
from time import sleep
from optparse import OptionParser

# cyclon modules:
import pyrex
from reference_time import _rt_to_dt

compress = True

# construct a command line parser
parser = OptionParser( "%prog [options]" )

parser.add_option( "-c", "--configured", help="use configured system",
        action="store_true", default=False, dest="use_configured" )

parser.add_option( "-n", "--name", help="system name",
        metavar="SYSTEM-NAME", action="store", dest="system_name" )

parser.add_option( "-a", "--align", help="align columns",
        action="store_true", default=False, dest="align_columns" )

parser.add_option( "-p", "--print", help="print registered systems",
        action="store_true", default=False, dest="print_systems" )

parser.add_option( "-s", "--shortnames", help="display short tasknames",
        action="store_true", default=False, dest="shortnames" )

# get command line options and positional args
( options, args ) = parser.parse_args()

#if len( args ) != 0:
#    parser.print_help()
#    sys.exit(1)

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover()

if options.use_configured:
    # use the configured system
    import config
    config = config.config()
    config.load()
    system_name = config.get( 'system_name' )

elif options.system_name:
    # use the given system name
    system_name = options.system_name
    if ns_groups.registered( system_name ):
        print "system: " + system_name
    else:
        print "WARNING: no " + system_name + " registered yet ..." 

elif options.print_systems:
    # print registered systems
    ns_groups.print_info()
    sys.exit(0)

else:
    # print available systems and exit
    parser.print_help()
    print
    ns_groups.print_info()
    sys.exit(0)

ctrl_end = "\033[0m"

print
print "here we go ..."
sleep(2)

alerted = False
while True:
    # connect to remote state summary object for the chosen system
    try: 
        god = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.state_summary')
    except NamingError:
        if not alerted:
            print "\n\033[1;37;41mfailed to connect" + ctrl_end + ' to state summary object for "' + system_name + '"'
            alerted = True
        sleep(1)
        continue

    alerted = False
    god._setTimeout(10)

    while True:
        # continual redisplay loop

        # get state summary, task names, reference times
        try:
            [glbl, states] = god.get_state_summary()
        except ConnectionClosedError:
            print "\n\033[1;37;41mconnection closed" + ctrl_end + ' to state summary object for "' + system_name + '"'
            sleep(1)
            break

        dt = glbl[ 'last_updated' ]
        rate = glbl[ 'dummy_clock_rate' ]
        dummy_mode = glbl[ 'dummy_mode' ]

        task_ids = states.keys()
        task_ids.sort()

        seen_time = {}
        seen_name = {}
        ref_time_list = []
        name_list = []

        for task_id in task_ids:
            [ name, ref_time ] = task_id.split( '%' )

            if ref_time not in seen_time.keys():
                seen_time[ ref_time ] = True
                ref_time_list.append( ref_time )

            if name not in seen_name.keys():
                seen_name[ name ] = True
                if options.shortnames:
                    name_list.append( states[ task_id ][ 'short_name' ] )
                else:
                    name_list.append( name )

        n_tasks = len( name_list )
        name_list.sort()
        ref_time_list.sort()
        catchup_info = {}

        # initialize a dict-of-dicts to store display information
        # for all tasks at each current reference time
        #   task_info[ ref_time ][ task_name ] = info
        task_info = {}
        for rt in ref_time_list:
            task_info[ rt ] = {}
            for name in name_list:
                # initialise with blank string of the same size as
                # the real info that we will use below
                tmp = name + '*'  # name plus abdication indicator
                tmp = re.sub( '.', ' ', tmp )
                task_info[ rt ][name] = tmp

        # now loop through all tasks in the system and assign their
        # display info to the correct place in the task_info structure
        for task_id in task_ids:

            if options.shortnames:
                name     =      states[ task_id ][ 'short_name' ]
            else:
                name     =      states[ task_id ][ 'name' ]

            reftime  =      states[ task_id ][ 'reference_time' ]
            state    =      states[ task_id ][ 'state' ]

            if not states[ task_id ][ 'abdicated' ]:
                # identify any tasks that have not abdicated yet
                abd = '*'
            else:
                # space of same length
                abd = ' '

            if 'catching_up' in states[ task_id ].keys():
                # get catchup status for any contact tasks
                # (this is a class variable for each task type,
                # not stored for each individual task object).
                catchup_info[ name ] = states[ task_id ][ 'catching_up' ]

            # color displayed info according to run status
            if state == "running":
                ctrl_start = "\033[1;37;42m"
            elif state == "waiting":
                ctrl_start = "\033[1;35m"
            elif state == "failed":
                ctrl_start = "\033[1;37;41m"
            else:
                # finished
                ctrl_start = ""

            # construct the display string for this task
            task_info[ reftime ][ name ] = ctrl_start + name + ctrl_end + abd
               

        # construct an array of lines to blit to the screen
        
        # MONITOR HEADER and CURRENT TIME
        blit = []
        blit.append( '\033[1;37;40mCYCLON!' + ctrl_end + "\033[1;35m waiting\033[0m \033[1;37;42mrunning\033[0m done \033[1;37;41mfailed" + ctrl_end )
        blit.append( 'last updated: ' + '\033[1;38m' + dt.strftime( "%Y/%m/%d %H:%M:%S" ) + ctrl_end )

        # SYSTEM NAME, NUMBER OF TASKS, DUMMY MODE
        if dummy_mode:
            blit.append( '\033[1;37;45m"' + system_name + '" (' + str( n_tasks ) + ' tasks)' + ctrl_end + ' DUMMY MODE (' + str(rate) + ' sec = 1 hr)' )
        else:
            blit.append( '\033[1;37;45m"' + system_name + '" (' + str( n_tasks ) + ' tasks)' + ctrl_end + ' REAL MODE' )

          
        # CATCHUP INFO for any contact tasks
        for name in catchup_info.keys():
            if catchup_info[ name ]:
                blit.append( name + ': catching up' )
            else:
                blit.append( name + ': caught up' )

        blit.append('')

        # construct a line of text to display for each reference time
        for rt in ref_time_list:
            line = ''
            # colour reference time according to whether it has
            # caught up to the current clock time or not.
            rtdt = _rt_to_dt( rt )
            if dt > rtdt:
                # behind
                line = '\033[1;34m' + rt + ctrl_end
            else:
                # caught up
                line = '\033[1;31m' + rt + ctrl_end

            # add info for each task to the line
            for name in name_list:
                disp = task_info[rt][name]
                if not options.align_columns and re.match( '^\s+$', disp ): 
                    # don't add white space unless align_columns has
                    # been requested by the user
                    pass
                else:
                    line = line + ' ' + disp

            blit.append( line )
                        
        # clear screen and blit the new information up
        os.system( "clear" )
        print '\n'.join( blit )
        sleep(0.5)

    sleep( 1 )
