#!/usr/bin/python

""" 
This is a messaging interface between external tasks and the proxy
objects that represent them inside a cylc scheduler instance: the
message is sent by calling [proxy].incoming( PRIORITY, MESSAGE )
through the Pyro RPC mechanism. 
The task proxy is identified by its unique ID, NAME%YYYYMMDDHH

Cylc exports $SYSTEM_NAME, $CYCLE_TIME, and $TASK_NAME into 
the environment of each external task.
"""

import os
import sys
import Pyro.core
from Pyro.errors import NamingError, ProtocolError
from optparse import OptionParser
from time import sleep

# construct a command line parser
usage = """
cylc message [options] <message> 

Send a message to a task proxy object in a running cylc instance.
THIS IS MAINLY FOR USE BY EXTERNAL TASK SCRIPTS, but it can also
be used manually by the system operator. In contrast to other
cylc commands this one can get all of its inputs from the 
environment (this is how it is used by external tasks which
get their own cylc system name, task name, and cycle time from
the execution environment set up by cylc)."""
parser = OptionParser( usage )

parser.add_option( "-p",
        metavar="PRIORITY",
        help="message priority "
             "(NORMAL, WARNING, CRITICAL) "
             "defaults to NORMAL.",
        action="store", dest="priority" )

parser.add_option( "-t", 
        metavar='TASKNAME',
        help="task name, defaults to $TASK_NAME",
        action="store", dest="taskname" )

parser.add_option( "-s",
        metavar="SYSTEM",
        help="Name of the running cylc instance, defaults to $SYSTEM_NAME",
        action="store", dest="system_name" )

parser.add_option( "-n", 
        help="Hostname of the machine running the Pyro nameserver, "
            "defaults to $PNSHOST, then localhost",
        metavar="HOSTNAME", action="store", dest="pns_host" )

parser.add_option( "-c",
        metavar="YYYYMMDDHH",
        help="task cycle time, defaults to $CYCLE_TIME",
        action="store", dest="ctime" )

parser.add_option( "--all-restart-outputs-completed", 
        help="report all forecast model restart outputs completed at once",
        action="store_true", default=False, dest="all_restarts_completed" )

parser.add_option( "--all-outputs-completed", 
        help="report all task outputs completed at once "
             "EXCEPT for the special 'completed' and 'finished' outputs",
        action="store_true", default=False, dest="all_outputs_completed" )

# get command line options and positional args
( options, args ) = parser.parse_args()

#if not options.priority or not options.taskname or not options.ctime:
#    parser.error( "options -p, -t, -r are not optional!" )

if options.priority:
    priority = options.priority
else:
    # Default to NORMAL
    priority = 'NORMAL'

if options.taskname:
    taskname = options.taskname
else:
    # Default to $TASK_NAME
    if 'TASK_NAME' in os.environ.keys():
        taskname = os.environ[ 'TASK_NAME' ]
    else:
        print 'ERROR, cylc message: no task name provided!'
        sys.exit(1)

if options.system_name:
    system_name = options.system_name
else:
    # Default to $SYSTEM_NAME
    if 'SYSTEM_NAME' in os.environ.keys():
        system_name = os.environ[ 'SYSTEM_NAME' ]
    else:
        print 'ERROR, cylc message: no system name provided!'
        sys.exit(1)

if options.pns_host:
    pns_host = options.pns_host

elif 'PNS_HOST' in os.environ.keys():
   pns_host = os.environ[ 'PNS_HOST' ]

else:
    pns_host = 'localhost'
    print 'WARNING, cylc message: no Pyro nameserver hostname provided!'
    print 'will attempt to connect to a namerserver on localhost'
     
if options.ctime:
    ctime = options.ctime
else:
    # Default to $CYCLE_TIME
    if 'CYCLE_TIME' in os.environ.keys():
        ctime = os.environ[ 'CYCLE_TIME' ]
    else:
        print 'ERROR, cylc message: no cycle time provided!'
        sys.exit(1)
 
if len( args ) == 0:
    if not options.all_restarts_completed and not options.all_outputs_completed:
        parser.error( "no message supplied" )
elif len( args ) == 1:
    # user sent a quoted string
    message = args[0]
else:
    # user sent a bare string, so join all the words together
    message = ' '.join(args)

# connect to the task object inside the control program
count = 0
while True:
    count += 1
    try:
        task = Pyro.core.getProxyForURI('PYRONAME://' + pns_host + '/' + system_name + '.' + taskname + '%' + ctime )
       
    except ProtocolError:
        # retry if temporary network problems prevented connection

        # TO DO: do we need to single out just the 'connection failed error?'

        # http://pyro.sourceforge.net/manual/10-errors.html
        # Exception: ProtocolError,
        #    Error string: connection failed
        #    Raised by: bindToURI method of PYROAdapter
        #    Description: Network problems caused the connection to fail.
        #                 Also the Pyro server may have crashed.
        #                 (presumably after connection established - hjo)

        print 'cylc message [' + str( count ) + ']: Network Problems, RETRYING in 5 seconds'
        sleep(5)

    except NamingError:
        # can't find nameserver, or no such object registered ...
        print 'PYRO NAMESERVER ERROR'
        raise

    except Exception:
        # all other exceptions
        print 'ERROR'
        raise

    else:
        # successful connection; continue on.
        break

if options.all_restarts_completed:
    # set all forecast model restart outputs completed
    task.set_all_restarts_completed()

elif options.all_outputs_completed:
    # set all outputs completed (except for 'finished' and 'completed')
    task.set_all_outputs_completed()
else:
    # send the message

    if message == "finished" or message == "failed":
        # also send the 'completed' message in case of success or failure 
        task.incoming( priority, "completed" )

    task.incoming( priority, message )

#    # nameserver not found, or object not registered with it?
#    print "ERROR: failed to connect to " + task_name + "_" + ctime
#    print "Trying dead letter box"
#    try:
#        dead_box = Pyro.core.getProxyForURI('PYRONAME://' + system_name + '.' + 'dead_letter_box' )
#        dead_box.incoming( message )
#    except:
#        # nameserver not found, or object not registered with it?
#        print "ERROR: failed to connect to pyro nameserver"
#        sys.exit(1)
