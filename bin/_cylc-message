#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


""" 
This is a messaging interface between external tasks and the proxy
objects that represent them inside a cylc scheduler instance: the
message is sent by calling [proxy].incoming( PRIORITY, MESSAGE )
through the Pyro RPC mechanism. 
The task proxy is identified by its unique ID, NAME%YYYYMMDDHH

Cylc exports $CYLC_NS_HOST, $CYLC_NS_GROUP, $CYCLE_TIME, and 
$TASK_NAME into the environment of each external task.
"""

import os, sys
from time import sleep
from optparse import OptionParser
from connector import connector

# PARSE THE COMMAND LINE-----------------------------------------------
usage = """cylc message [options] [MESSAGE] 

Send a message to a task proxy object in a running cylc system.

THIS COMMAND IS USED BY EXTERNAL TASKS TO UPDATE THE STATE OF THE PROXY
OBJECTS THAT REPRESENT THEM IN A RUNNING CYLC SCHEDULER. It can also be
used to send messages manually for debugging or system intervention
purposes, in which case all inputs can be supplied on the command line.
If invoked by a task that does not belong to a cylc scheduler instance,
messages are simply directed to stdout.

arguments:
   MESSAGE              A quoted string."""

parser = OptionParser( usage )

parser.set_defaults( started=False, success=False, failure=False, 
        all_restarts_completed=False, all_outputs_completed=False,
        priority='NORMAL')

parser.add_option( "-t", "--task",
        metavar='TASK',
        help="Task name, defaults to $TASK_NAME.",
        action="store", dest="taskname" )

parser.add_option( "-s", "--system",
        metavar="SYSTEM",
        help="The name of the system hosting the target task proxy object.",
        action="store", dest="system_name" )

parser.add_option( "-u", "--user",
        help="Owner of the target system, defaults to $USER. Needed "
        "to infer the Pyro nameserver groupname",
        metavar="USERNAME", action="store", dest="username" )

parser.add_option( "--host",
        help="Hostname of the machine running the Pyro nameserver, "
            "defaults to $CYLC_NS_HOST, then localhost.",
        metavar="HOSTNAME", action="store", dest="pns_host" )

parser.add_option( "--started",
        help="Send an automatic message indicating a task has "
        "started executing.",
        action="store_true", dest="started" )

parser.add_option( "--succeeded",
        help="Send an automatic message indicating a task has "
        "completed successfully.",
        action="store_true", dest="succeeded" )

parser.add_option( "--failed",
        help="Send an automatic message indicating a task has "
        "failed to complete successfully.",
        action="store_true", dest="failed" )

parser.add_option( "-p",
        metavar="PRIORITY",
        type="choice",
        choices=[ 'NORMAL', 'WARNING', 'CRITICAL' ],
        help="message logging priority: NORMAL, WARNING, or CRITICAL; default NORMAL.",
        action="store", dest="priority" )

parser.add_option( "-c",
        metavar="CYCLE",
        help="Task cycle time (YYYYMMDDHH) defaults to $CYCLE_TIME.",
        action="store", dest="ctime" )

parser.add_option( "--next-restart-completed",
        help="Report next restart file(s) completed",
        action="store_true", dest="next_restart_completed" )

parser.add_option( "--all-restart-outputs-completed", 
        help="Report all restart outputs completed at once.",
        action="store_true", dest="all_restarts_completed" )

parser.add_option( "--all-outputs-completed", 
        help="Report all internal outputs completed at once.",
        action="store_true", dest="all_outputs_completed" )

( options, args ) = parser.parse_args()

# GET TASK NAME--------------------------------------------------------
if options.taskname:
    # command line
    taskname = options.taskname

    commandline_invocation = True

else:
    # Default to $TASK_NAME
    if 'TASK_NAME' in os.environ.keys():
        taskname = os.environ[ 'TASK_NAME' ]
    else:
        print 'ERROR, cylc message: no task name provided'
        sys.exit(1)

    commandline_invocation = False

# GET TASK CYCLE TIME--------------------------------------------------
if options.ctime:
    # command line
    ctime = options.ctime
else:
    # Default to $CYCLE_TIME
    if 'CYCLE_TIME' in os.environ.keys():
        ctime = os.environ[ 'CYCLE_TIME' ]
    else:
        print 'ERROR, cylc message: no cycle time provided!'
        sys.exit(1)

# get priority----------------------------
PRIORITY='NORMAL'
if options.priority:
    priority=options.priority

if 'CYLC_ON' not in os.environ.keys() and not commandline_invocation:

    # DIVERT MESSAGES TO STDOUT UNLESS THIS SCRIPT WAS INVOKED FROM:
    # (a) A TASK SPAWNED BY 'cylc run-task', OR 
    # (b) BY MANUAL INVOCATION ON THE COMMANDLINE. 

    task_id = taskname + '%' + ctime

    if options.next_restart_completed:
        print task_id, " next restart completed"

    elif options.all_restarts_completed:
        print task_id, " all restarts completed"

    elif options.all_outputs_completed:
        print task_id, " all outputs completed"

    elif options.started:
        print task_id, " started"

    elif options.succeeded:
        print task_id, " completed (success)"

    elif options.failed:
        print task_id, " completed (failure)"

    else:
        print task_id, args

    sys.exit(0)


# GET SYSTEM NAME------------------------------------------------------

if 'CYLC_NS_GROUP' in os.environ.keys():
    groupname = os.environ[ 'CYLC_NS_GROUP' ]

else:
    if options.username:
        username = options.username
    else:
        username = os.environ[ 'USER' ] 

    if options.system_name:
        groupname = username + '_' + options.system_name
    else:
        raise SystemExit( 'Cannot get Pyro groupname from input' )

# GET PYRO NAMESERVER HOST---------------------------------------------
if options.pns_host:
    # command line
    pns_host = options.pns_host

elif 'CYLC_NS_HOST' in os.environ.keys():
    # environment
   pns_host = os.environ[ 'CYLC_NS_HOST' ]

else:
    # Default to localhost
    pns_host = 'localhost'
    print 'WARNING, cylc message: no Pyro nameserver hostname provided!'
    print 'will attempt to connect to a namerserver on localhost'
     

# CHECK ARGS AND OPTIONS-----------------------------------------------

# the automatic messaging options must be used alone
if options.started or options.succeeded or options.failed \
        or options.next_restart_completed \
        or options.all_restarts_completed \
        or options.all_outputs_completed:
            # automatic message
            pass

elif len( args ) == 0:
    parser.error( "no message supplied" )

elif len( args ) == 1:
    # quoted string supplied
    message = args[0]

else:
    # bare string supplied
    message = ' '.join(args)

# CONNECT TO THE CORRECT TASK PROXY OBJECT-----------------------------

task_id = taskname + '%' + ctime
task = connector( pns_host, groupname, task_id ).get()

# DO THE MESSAGING----------------------------------------------------

# the "all completed" special options are implemented as short cut
# functions in the task proxy objects


if options.next_restart_completed:
    task.set_next_restart_completed()
    sys.exit(0)

if options.all_restarts_completed:
    task.set_all_restarts_completed()
    sys.exit(0)

if options.all_outputs_completed:
    task.set_all_internal_outputs_completed()
    sys.exit(0)

if options.started:
    task.incoming( 'NORMAL', task_id + " started" )

elif options.succeeded:
    task.incoming( 'NORMAL', task_id + " completed" )
    task.incoming( 'NORMAL', task_id + " finished" )

elif options.failed:
    task.incoming( 'NORMAL', task_id + " completed" )
    task.incoming( 'CRITICAL', task_id + " failed" )

else:
    task.incoming( priority, message )

#    # nameserver not found, or object not registered with it?
#    print "ERROR: failed to connect to " + task_name + "_" + ctime
#    print "Trying dead letter box"
#    try:
#        dead_box = Pyro.core.getProxyForURI('PYRONAME://' + groupname + '.' + 'dead_letter_box' )
#        dead_box.incoming( message )
#    except:
#        # nameserver not found, or object not registered with it?
#        print "ERROR: failed to connect to pyro nameserver"
#        sys.exit(1)
