#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


""" 
This is a messaging interface between external tasks and the proxy
objects that represent them inside a cylc scheduler instance: the
message is sent by calling [proxy].incoming( PRIORITY, MESSAGE )
through the Pyro RPC mechanism. 
The task proxy is identified by its unique ID:
  NAME%YYYYMMDDHH (cycling tasks)
  NAME%TAG        (asynchronous tasks)

Cylc exports $CYLC_NS_HOST, $CYLC_NS_GROUP, $TASK_ID, $TASK_NAME, and
$CYCLE_TIME into the environment of each external task.
"""

# SEND MESSAGES TO A CYLC SCHEDULER VIA PYRO IF THIS SCRIPT WAS:
#  (a) called by a task that was invoked by a cylc scheduler
#  (b) invoked manually on the command line
# OTHERWISE DIVERT MESSAGES TO STDOUT, i.e. IF THIS SCRIPT WAS:
#  (a) called by a task that was invoked by 'cylc run-task'
#  (b) called by a task that was run manually on the command line


import os, sys
import socket
from time import sleep
from optparse import OptionParser
from connector import connector

# PARSE THE COMMAND LINE-----------------------------------------------
usage = """cylc message [options] [MESSAGE] 

Send a message to a task proxy object in a running cylc system.

THIS COMMAND IS FOR USE BY EXTERNAL TASKS TO UPDATE THE STATE OF THE
PROXY OBJECTS THAT REPRESENT THEM IN A RUNNING CYLC SCHEDULER, in which 
case it gets most of its inputs from the task execution environment.

If invoked by a task that does not belong to a cylc scheduler (e.g. by
'cylc run-task') messages are directed to stdout instead of via the Pyro
nameserver to task proxy objects in a running scheduler.

It can also be used to send messages manually to tasks in a running
system, in which case most of its inputs can be supplied on the
command line. This command currently does not respect the system
lock and is not aware of practice mode, but there should be no need to
for manual invocation of cylc message if you are not a cylc developer. 

arguments:
   MESSAGE              A quoted string."""

parser = OptionParser( usage )

parser.set_defaults( started=False, success=False, failure=False, 
        all_restarts_completed=False, all_outputs_completed=False,
        priority='NORMAL')

parser.add_option( "-t", "--task-identity",
        metavar='TASK-ID',
        help="Task identity, defaults to $TASK_ID.",
        action="store", dest="task_id" )

parser.add_option( "-s", "--system",
        metavar="SYSTEM",
        help="The name of the system hosting the target task proxy object.",
        action="store", dest="system_name" )

parser.add_option( "-u", "--user",
        help="Owner of the target system, defaults to $USER. Needed "
        "to infer the Pyro nameserver groupname",
        metavar="USERNAME", action="store", dest="username" )

parser.add_option( "--host",
        help="Hostname of the machine running the Pyro nameserver, "
            "defaults to $CYLC_NS_HOST, then the local hostname.",
        metavar="HOSTNAME", action="store", dest="pns_host" )

parser.add_option( "--started",
        help="Send an automatic message indicating a task has "
        "started executing.",
        action="store_true", dest="started" )

parser.add_option( "--succeeded",
        help="Send an automatic message indicating a task has "
        "completed successfully.",
        action="store_true", dest="succeeded" )

parser.add_option( "--failed",
        help="Send an automatic message indicating a task has "
        "failed to complete successfully.",
        action="store_true", dest="failed" )

parser.add_option( "-p",
        metavar="PRIORITY",
        type="choice",
        choices=[ 'NORMAL', 'WARNING', 'CRITICAL' ],
        help="message logging priority: NORMAL, WARNING, or CRITICAL; default NORMAL.",
        action="store", dest="priority" )

parser.add_option( "--next-restart-completed",
        help="Report next restart file(s) completed",
        action="store_true", dest="next_restart_completed" )

parser.add_option( "--all-restart-outputs-completed", 
        help="Report all restart outputs completed at once.",
        action="store_true", dest="all_restarts_completed" )

parser.add_option( "--all-outputs-completed", 
        help="Report all internal outputs completed at once.",
        action="store_true", dest="all_outputs_completed" )

( options, args ) = parser.parse_args()

# MODE OF OPERATION ---------------------------------------------------
# have we been invoked from a script that was launched by 'cylc start',
# 'cylc run-task', or a raw task script?
mode = 'raw'
if 'CYLC_MODE' in os.environ:
    mode = os.environ[ 'CYLC_MODE' ]
    # 'scheduler' or 'run-task'

# TASK IDENTITY ---------------------------------------------------
if options.task_id:
    # command line
    task_id = options.task_id
else:
    # Default to $TASK_ID
    if 'TASK_ID' in os.environ.keys():
        task_id = os.environ[ 'TASK_ID' ]
    else:
        if mode == 'raw':
            #print 'cylc message: you appear to have invoked a raw task script'
            task_id = 'NAME%TAG'
        else:
            print >> sys.stderr, 'cylc message ERROR: no task id provided!'
            sys.exit(1)

# PRIORITY----------------------------
if options.priority:
    priority=options.priority
else:
    priority = 'NORMAL'

# USER NAME------------------------------------------------------
if options.username:
    username = options.username
else:
    username = os.environ[ 'USER' ] 

# NAMESERVER GROUP NAME-------------------------------------------------
if options.system_name:
    groupname = username + '^' + options.system_name
elif 'CYLC_NS_GROUP' in os.environ.keys():
    groupname = os.environ[ 'CYLC_NS_GROUP' ]

# PYRO NAMESERVER HOSTNAME---------------------------------------------
if options.pns_host:
    pns_host = options.pns_host

elif 'CYLC_NS_HOST' in os.environ.keys():
    pns_host = os.environ[ 'CYLC_NS_HOST' ]

else:
    pns_host = socket.getfqdn()
    #print 'WARNING, cylc message: no Pyro nameserver hostname provided!'
    #print 'will attempt to connect to a namerserver on local host'
 
# MESSAGE--------------------------------------------------------------
if options.started or options.succeeded or options.failed \
        or options.next_restart_completed \
        or options.all_restarts_completed \
        or options.all_outputs_completed:
            # automatic message
            pass

elif len( args ) == 0:
    parser.error( "no message supplied" )

elif len( args ) == 1:
    # quoted string supplied
    message = args[0]

else:
    # bare string supplied
    message = ' '.join(args)


# CHECK ARGS AND OPTIONS-----------------------------------------------

if options.next_restart_completed:
    message = "next restart completed"

elif options.all_restarts_completed:
    message = "all restarts completed"

elif options.all_outputs_completed:
    message = "all outputs completed"

elif options.started:
    message = "started"

elif options.succeeded:
    message = "completed (success)"

elif options.failed:
    message = "completed (failure)"

else:
    # message = message
    pass

print_message = 'cylc message (' + mode + '): ' + task_id + ' ' + message
if options.failed or priority == 'WARNING' or priority == 'CRITICAL':
    # print to stderr as well as stdout
    print >> sys.stderr, print_message
print print_message

if mode != 'scheduler':
    sys.exit(0)

# CONNECT TO THE CORRECT TASK PROXY OBJECT-----------------------------
try:
    task = connector( pns_host, groupname, task_id ).get()
except:
    print >> sys.stderr, "ERROR: failed to connect to " + task_id + " in " + groupname
    sys.exit(1)

# DO THE MESSAGING----------------------------------------------------

# the "all completed" special options are implemented as short cut
# functions in the task proxy objects

if options.next_restart_completed:
    task.set_next_restart_completed()
    sys.exit(0)

if options.all_restarts_completed:
    task.set_all_restarts_completed()
    sys.exit(0)

if options.all_outputs_completed:
    task.set_all_internal_outputs_completed()
    sys.exit(0)

if options.started:
    task.incoming( 'NORMAL', task_id + " started" )

elif options.succeeded:
    task.incoming( 'NORMAL', task_id + " completed" )
    task.incoming( 'NORMAL', task_id + " finished" )

elif options.failed:
    task.incoming( 'NORMAL', task_id + " completed" )
    task.incoming( 'CRITICAL', task_id + " failed" )

else:
    task.incoming( priority, message )

#    # nameserver not found, or object not registered with it?
#    print "ERROR: failed to connect to " + task_id
#    print "Trying dead letter box"
#    try:
#        dead_box = Pyro.core.getProxyForURI('PYRONAME://' + groupname + '.' + 'dead_letter_box' )
#        dead_box.incoming( message )
#    except:
#        # nameserver not found, or object not registered with it?
#        print "ERROR: failed to connect to pyro nameserver"
#        sys.exit(1)
