#!/usr/bin/python

""" 
This is a messaging interface between external tasks and the proxy
objects that represent them inside a cylc scheduler instance: the
message is sent by calling [proxy].incoming( PRIORITY, MESSAGE )
through the Pyro RPC mechanism. 
The task proxy is identified by its unique ID, NAME%YYYYMMDDHH

Cylc exports $CYLC_NS_HOST, $CYLC_NS_GROUP, $CYCLE_TIME, and 
$TASK_NAME into the environment of each external task.
"""

import os
import sys
import Pyro.core
from Pyro.errors import NamingError, ProtocolError
from optparse import OptionParser
from time import sleep

# PARSE THE COMMAND LINE-----------------------------------------------
usage = """cylc message [options] [MESSAGE] 

Send a message to a task proxy object in a running cylc system.

THIS COMMAND IS USED BY EXTERNAL TASKS TO UPDATE THE STATE OF THE PROXY
OBJECTS THAT REPRESENT THEM IN A RUNNING CYLC SCHEDULER. Task proxy
objects are uniquely identified by their name and cycle time, which must
be known by this script in order to target the right object. Cylc
exports these variables into the environment as $TASK_NAME and
$CYCLE_TIME when it submits an external task, so the external task can
simply call 'cylc message MESSAGE' and this script will read the right
name and cycle time from the environment (i.e. the task itself does not
need to know the name by which cylc refers to it, although it too can
get the name from the environment if it wants to).

Note that where other cylc commands need to be given a registered system
name, this one needs the group name under which the system's task proxy
objects are registered in the Pyro nameserver. Depending on network
configuration, the Pyro nameserver hostname may also be required. Cylc
puts these in the task execution environment as $CYLC_NS_GROUP and
$CYLC_NS_HOST. 

This command can also be used to "fake" task messages, for debugging or
system intervention purposes, in which case all input can be taken from 
the command line. You need to use --system and, if the target system is
not running under your username, --user, so that the right Pyro
nameserver group name can be inferred (cylc uses USERNAME_SYSTEM).

arguments:
   MESSAGE              A quoted string."""

parser = OptionParser( usage )

parser.set_defaults( started=False, success=False, failure=False, 
        all_restarts_completed=False, all_outputs_completed=False,
        priority='NORMAL')

parser.add_option( "-t", 
        metavar='TASK',
        help="Task name, defaults to $TASK_NAME.",
        action="store", dest="taskname" )

parser.add_option( "-s", "--system",
        metavar="SYSTEM",
        help="The name of the system hosting the target task proxy object.",
        action="store", dest="system_name" )

parser.add_option( "-u", "--user",
        help="Owner of the target system (i.e. the username under which "
        "the scheduler is running). Defaults to your username, $USER.",
        metavar="USERNAME", action="store", dest="username" )

parser.add_option( "-n", "--hostname",
        help="Hostname of the machine running the Pyro nameserver, "
            "defaults to $CYLC_NS_HOST, then localhost.",
        metavar="HOSTNAME", action="store", dest="pns_host" )

parser.add_option( "--started",
        help="Send an automatic message indicating a task has "
        "started executing.",
        action="store_true", dest="started" )

parser.add_option( "--succeeded",
        help="Send an automatic message indicating a task has "
        "completed successfully.",
        action="store_true", dest="succeeded" )

parser.add_option( "--failed",
        help="Send an automatic message indicating a task has "
        "failed to complete successfully.",
        action="store_true", dest="failed" )

parser.add_option( "-p",
        metavar="PRIORITY",
        type="choice",
        choices=[ 'NORMAL', 'WARNING', 'CRITICAL' ],
        help="message logging priority: NORMAL, WARNING, or CRITICAL; default NORMAL.",
        action="store", dest="priority" )

parser.add_option( "-c",
        metavar="CYCLE",
        help="Task cycle time (YYYYMMDDHH) defaults to $CYCLE_TIME.",
        action="store", dest="ctime" )

parser.add_option( "--next-restart-completed",
        help="Report next restart file(s) completed",
        action="store_true", dest="next_restart_completed" )

parser.add_option( "--all-restart-outputs-completed", 
        help="Report all restart outputs completed at once.",
        action="store_true", dest="all_restarts_completed" )

parser.add_option( "--all-outputs-completed", 
        help="Report all internal outputs completed at once.",
        action="store_true", dest="all_outputs_completed" )

( options, args ) = parser.parse_args()

# GET TASK NAME--------------------------------------------------------
if options.taskname:
    # command line
    taskname = options.taskname
else:
    # Default to $TASK_NAME
    if 'TASK_NAME' in os.environ.keys():
        taskname = os.environ[ 'TASK_NAME' ]
    else:
        print 'ERROR, cylc message: no task name provided'
        sys.exit(1)

# GET TASK CYCLE TIME--------------------------------------------------
if options.ctime:
    # command line
    ctime = options.ctime
else:
    # Default to $CYCLE_TIME
    if 'CYCLE_TIME' in os.environ.keys():
        ctime = os.environ[ 'CYCLE_TIME' ]
    else:
        print 'ERROR, cylc message: no cycle time provided!'
        sys.exit(1)

# get priority----------------------------
PRIORITY='NORMAL'
if options.priority:
    priority=options.priority

if 'CYLC_ON' not in os.environ.keys():

    # IF CYLC_ON IS NOT IN THE ENVIRONMENT THEN WHEN HAVEN'T BEEN CALLED
    # BY A TASK SPAWNED BY THE SCHEDULER (PROBABLY A STANDALONE TASK RUN
    # BY 'cylc run-task', SO DIVERT THE MESSAGE TO STDOUT.
    task_id = taskname + '%' + ctime

    if options.next_restart_completed:
        print task_id, "--next-restart-completed"

    elif options.all_restarts_completed:
        print task_id, "--all-restarts-completed"

    elif options.all_outputs_completed:
        print task_id, "--all-outputs-completed"

    elif options.started:
        print task_id, " started"

    elif options.succeeded:
        print task_id, " completed, finished"

    elif options.failed:
        print task_id, " completed, failed"

    else:
        print task_id, args

    sys.exit(0)


# GET SYSTEM NAME------------------------------------------------------

if 'CYLC_NS_GROUP' in os.environ.keys():
    groupname = os.environ[ 'CYLC_NS_GROUP' ]

else:
    if options.username:
        username = options.username
    else:
        username = os.environ[ 'USER' ] 

    if options.system_name:
        groupname = username + '_' + options.system_name
    else:
        raise SystemExit( 'Cannot get Pyro groupname from input' )

# GET PYRO NAMESERVER HOST---------------------------------------------
if options.pns_host:
    # command line
    pns_host = options.pns_host

elif 'CYLC_NS_HOST' in os.environ.keys():
    # environment
   pns_host = os.environ[ 'CYLC_NS_HOST' ]

else:
    # Default to localhost
    pns_host = 'localhost'
    print 'WARNING, cylc message: no Pyro nameserver hostname provided!'
    print 'will attempt to connect to a namerserver on localhost'
     

# CHECK ARGS AND OPTIONS-----------------------------------------------

# the automatic messaging options must be used alone
if options.started or options.succeeded or options.failed \
        or options.next_restart_completed \
        or options.all_restarts_completed \
        or options.all_outputs_completed:
   if len( sys.argv ) != 2:
       print "cylc message ERROR: automatic message options are mutually exclusive"
       sys.exit(1)

elif len( args ) == 0:
    parser.error( "no message supplied" )

elif len( args ) == 1:
    # quoted string supplied
    message = args[0]

else:
    # bare string supplied
    message = ' '.join(args)

# CONNECT TO THE CORRECT TASK PROXY OBJECT-----------------------------
count = 0
while True:
    count += 1
    try:
        task = Pyro.core.getProxyForURI('PYRONAME://' + pns_host + '/' + groupname + '.' + taskname + '%' + ctime )
       
    except ProtocolError:
        # retry if temporary network problems prevented connection

        # TO DO: do we need to single out just the 'connection failed error?'

        # http://pyro.sourceforge.net/manual/10-errors.html
        # Exception: ProtocolError,
        #    Error string: connection failed
        #    Raised by: bindToURI method of PYROAdapter
        #    Description: Network problems caused the connection to fail.
        #                 Also the Pyro server may have crashed.
        #                 (presumably after connection established - hjo)

        print 'cylc message [' + str( count ) + ']: Network Problems, RETRYING in 5 seconds'
        sleep(5)

    except NamingError:
        # can't find nameserver, or no such object registered ...
        print 'PYRO NAMESERVER ERROR'
        raise

    except Exception:
        # all other exceptions
        print 'ERROR'
        raise

    else:
        # successful connection
        break

# DO THE MESSAGING----------------------------------------------------

# the "all completed" special options are implemented as short cut
# functions in the task proxy objects

task_id = taskname + '%' + ctime

if options.next_restart_completed:
    task.set_next_restart_completed()
    sys.exit(0)

if options.all_restarts_completed:
    task.set_all_restarts_completed()
    sys.exit(0)

if options.all_outputs_completed:
    task.set_all_internal_outputs_completed()
    sys.exit(0)

if options.started:
    task.incoming( 'NORMAL', task_id + " started" )

elif options.succeeded:
    task.incoming( 'NORMAL', task_id + " completed" )
    task.incoming( 'NORMAL', task_id + " finished" )

elif options.failed:
    task.incoming( 'NORMAL', task_id + " completed" )
    task.incoming( 'CRITICAL', task_id + " failed" )

else:
    task.incoming( priority, message )

#    # nameserver not found, or object not registered with it?
#    print "ERROR: failed to connect to " + task_name + "_" + ctime
#    print "Trying dead letter box"
#    try:
#        dead_box = Pyro.core.getProxyForURI('PYRONAME://' + groupname + '.' + 'dead_letter_box' )
#        dead_box.incoming( message )
#    except:
#        # nameserver not found, or object not registered with it?
#        print "ERROR: failed to connect to pyro nameserver"
#        sys.exit(1)
