#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC SUITE ENGINE.
#C: Copyright (C) 2008-2013 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
if '--use-ssh' in sys.argv[1:]: 
    sys.argv.remove( '--use-ssh' )
    from cylc.remote import remrun
    if remrun().execute( force_required=True ):
        sys.exit(0)

import os, re
from cylc.CylcOptionParsers import cop
from cylc.task_message import message
from cylc import cylc_pyro_client
from cylc.command_prep import prep_pyro
from cylc.cycle_time import ct, CycleTimeError
from cylc.print_tree import print_tree
from cylc.TaskID import TaskID
from cylc.config import coerce_runtime_values

def get_padding( settings, level=0, padding=0 ):
    level += 1
    for key,val in settings.items():
        tmp = level*2 + len(key)
        if tmp > padding:
            padding = tmp
        if isinstance( val, dict ):
            padding = get_padding( val, level, padding )
    return padding

def get_rdict( left, right=None ): 
    # left is [section]item, or just item
    rdict = {}
    m = re.match( '^\[(.*)\](.*)$', left )
    if m:
        # [sect]item = right
        sect, var = m.groups()
        if not var:
            rdict = { sect : right }
        else:
            rdict = { sect : { var : right }}
    else:
        # item = right
        rdict = { left : right }
    return rdict
 
usage = """cylc [control] broadcast|bcast [OPTIONS] REG

Override [runtime] namespace config items in a running suite.

Broadcasts can target any task or family (including root), at specific
cycle times, or all all cycle times. Item override occurs just before
job submission.

Uses include: temporary manual changes to task behaviour at run time;
tasks communicating to other downstream tasks via environment variables.

Broadcasts persist across suite restarts, but they can be unset,
cleared, or expired using this command, and cylc automatically expires
any that target cycle times beyond the oldest current in the suite.

For config items affected by multiple broadcasts the precedence is:
 1) specific cycle broadcasts override all-cycle broadcasts; then
 2) the most specific namespace (farthest from root) takes precedence.

The -s/--set and -u/--unset options target named config items for all
tasks in all cycles, more specifically with -t/--tag or -n/--namespace.

The -c/--clear option by itself clears *all* broadcasts to the suite, or 
more specifically with -t/--tag or -n/--namespace. Use with --tag=all to
clear all specific-cycle and all-cycle broadcasts.

Items with internal spaces must be quoted, e.g.:
  % cylc broadcast -s "[environment]VERSE = the quick brown fox" REG
  
To view current active broadcasts:
  % cylc broadcast --display REG
  % cylc broadcast --display-task=TASKID REG
 
To unset active broadcasts:
  % cylc broadcast -n NAME -u 'command scripting' REG
  % cylc broadcast --clear REG # clear all broadcast settings
  
LIMITATIONS:
 1) Broadcast cannot change [runtime] inheritance (use "cylc reload").
 2) Clearing an item from a specific cycle does not result in its
    exclusion from an all-cycles broadcast of the same item.
 3) Clearing an item from a specific namespace does not result in
    its exclusion from broadcasts of the same item to descendent
    namespaces (this is arguably desirable and not a limitation).

See also 'cylc reload' - reload a modified suite definition at run time."""

parser = cop( usage, pyro=True )

parser.add_option( "-n", "--namespace", metavar="NAME", 
        help="The target [runtime] namespace (default 'root'). "
        "Use multiple times to target multiple namespaces at once.", 
        action="append", dest="namespaces", default=[] )

parser.add_option( "-t", "--tag", metavar="TAG",
        help="The target cycle time or integer tag (default 'all'). "
        "Use multiple times to target multiple cycles at once.", 
        action="append", dest="tags", default=[] )

parser.add_option( "-s", "--set", metavar="[SEC]ITEM=VALUE", 
        help="The [runtime] config item to override by broadcast. "
        "Use multiple times to set multiple items at once.",
        action="append", dest="set", default=[] )

parser.add_option( "-u", "--unset", metavar="[SEC]ITEM", 
        help="The [runtime] config item to clear of broadcasts. "
        "Use multiple times to unset multiple items at once.",
        action="append", dest="unset", default=[] )

parser.add_option( "-c", "--clear", 
        help="Clear current broadcast settings globally or, with "
        "-t/--tag and/or -n/--namespace, more specifically.",
        action="store_true", dest="clear", default=False )

parser.add_option( "-e", "--expire", metavar="CYCLE",
        help="Clear any broadcasts that target cycle "
        "times earlier than, but not inclusive of, CYCLE.",
        action="store", default=None, dest="expire" )

parser.add_option( "-d", "--display", 
        help="Display current active broadcast settings.",
        action="store_true", default=False, dest="show" )

parser.add_option( "-k", "--display-task", metavar="TASKID",
        help="Print current active broadcast for a given task "
        "(NAME"+TaskID.DELIM+"TAG).",
        action="store", default=None, dest="showtask" )

parser.add_option( "-b", "--box",
        help="Use unicode box characters with -d, -k.",
        action="store_true", default=False, dest="unicode" )

parser.add_option( "-r", "--raw",
        help="With -d/--display or -k/--display-task, write out "
        "the broadcast config structure in raw Python form.",
        action="store_true", default=False, dest="raw" )

( options, args ) = parser.parse_args()

suite = args[0]

suite, pphrase = prep_pyro( suite, options ).execute()

debug = False
if options.debug:
    debug = True
else:
    try:
        # from task execution environment
        if os.environ['CYLC_DEBUG'] == 'True':
            debug = True
    except KeyError:
        pass

try:
    proxy = cylc_pyro_client.client( suite, pphrase, options.owner,
            options.host, options.pyro_timeout, options.port,
            options.verbose ).get_proxy( 'broadcast_receiver' )
except Exception, x:
    if debug:
        raise
    raise SystemExit(x)

if options.show or options.showtask:
    if options.showtask:
        try:
            name, tag = options.showtask.split(TaskID.DELIM)
        except ValueError:
            parser.error( "TASKID must be NAME"+TaskID.DELIM+"TAG" )
    try:
        settings = proxy.get( options.showtask )
    except Exception,x:
        if options.debug:
            raise
        sys.exit(x)
    padding = get_padding(settings) * ' '
    if options.raw:
        print str( settings )
    else:
        print_tree( settings, padding, options.unicode )
    sys.exit(0)

if options.clear:
    try:
        settings = proxy.clear( options.namespaces, options.tags )
    except Exception,x:
        if options.debug:
            raise
        sys.exit(x)
    else:
        sys.exit(0)

if options.expire:
    try:
        settings = proxy.expire( options.expire )
    except Exception,x:
        if options.debug:
            raise
        sys.exit(x)
    else:
        sys.exit(0)

namespaces = options.namespaces
if not namespaces:
    namespaces = ["root"]

tags = options.tags
if not tags:
    tags = ["all"]

settings = []
for s in options.set:
    try:
        # left = val
        left, val = s.split('=')
        left = left.strip()
        val = val.strip()
        if left == 'inherit':
            raise SystemExit( "ERROR: Inheritance cannot be changed by broadcast" )
    except ValueError:
        raise SystemExit( "ERROR: --set requires a value" )
    rdict = get_rdict( left, val )
    coerce_runtime_values( rdict )
    settings.append( rdict )

for u in options.unset:
    if u == 'inherit':
        raise SystemExit( "ERROR: Inheritance cannot be changed by broadcast" )
    if '=' in u:
        raise SystemExit( "ERROR: --unset does not take a value" )
    settings.append( get_rdict( u ) )

try:
    success, msg = proxy.put( namespaces, tags, settings )
except Exception, x:
    if options.debug:
        raise
    sys.exit(x)
else:
    if not success:
        sys.exit(msg)

