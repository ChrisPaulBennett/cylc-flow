#!/usr/bin/env python

import os, re, sys
from config import config
from optparse import OptionParser
from shutil import copy
import tempfile
import subprocess
from registration import unqualify, RegistrationError
 
parser = OptionParser( """cylc control log [options] SUITE 
Print, or view in $EDITOR, local suite log files, with optional
filtering. This command is a convenience: you don't need to
know the log file location on disk.

Arguments:
  SUITE - access the cylc logs from the suite of this name.""")

parser.add_option( "-p", "--print", 
        help="Print the suite log file location and exit.",
        action="store_true", default=False, dest="print_location" )

parser.add_option( "-t", "--task", 
        help="Filter the log for messages from a specific task",
        metavar="TASK", action="store", default=None, dest="taskfilter" )

parser.add_option( "-f", "--filter", 
        help="Filter the log with a Python-style regular expression "
        "e.g. '\[(foo|bar).*(started|finished)'",
        metavar="RE", action="store", default=None, dest="regexfilter" )

parser.add_option( "-r", "--rotation", 
        help="Rotation number (to view older, rotated logs)",
        metavar="INT", action="store", default="0", dest="rotation" )

parser.add_option( "-e", "--edit",
        help="View a temporary copy of the (filtered) log file in $EDITOR "
        "instead of printing it to stdout.",
        action="store_true", default=False, dest="edit" )

( options, args ) = parser.parse_args()

if len(args) != 1:
    parser.error( "wrong number of arguments" )

try:
    suite = unqualify(args[0])
except RegistrationError, x:
    raise SystemExit(x)

filename = os.path.join( config( suite )['top level logging directory'], suite, 'log' )
 
if options.rotation != "0":
    filename = filename + options.rotation

if options.print_location:
    print filename
    sys.exit(0)

filter = None
if options.taskfilter:
    filter = re.compile( '\\[' + options.filter + '%\d{10}\\]' )
elif options.regexfilter:
    filter = re.compile( options.regexfilter )

# TO DO: exception handling for large files that exceed memory capacity?
# apparently readline() one line at a time is much slower than readlines()
try:
    LOG = open( filename )
except IOError:
    raise SystemExit( "ERROR: file not found: " + filename )

lines = LOG.readlines()
LOG.close()

if filter:
    filtered = []
    for line in lines:
        if re.search( filter, line ):
            filtered.append(line)
else:
    filtered = lines

if not options.edit:
    for line in filtered:
        print line.rstrip()
    sys.exit(0)

try:
    editor = os.environ['EDITOR']
except KeyError:
    raise SystemExit( 'export $EDITOR before using this command' )

try:
    tmpdir = os.environ['TMPDIR']
except KeyError:
    raise SystemExit( 'export $TMPDIR before using this command' )

tmpfile = tempfile.mktemp( suffix = ".tmp", prefix = suite+'-log', dir = tmpdir )
tmp = open( tmpfile, 'wb' )
tmp.writelines( filtered )
tmp.close()

command_list = [ editor, tmpfile ]
try:
    # THIS BLOCKS UNTIL THE COMMAND COMPLETES
    retcode = subprocess.call( command_list )
    if retcode != 0:
        # the command returned non-zero exist status
        print >> sys.stderr, ' '.join( command_list ), ' failed: ', retcode
        sys.exit(1)

except OSError:
    # the command was not invoked
    print >> sys.stderr, 'ERROR: unable to execute ', ' '.join(command_list)
    #print >> sys.stderr, ' * Have you sourced $CYLC_DIR/cylc-env.sh?'
    #print >> sys.stderr, " * Are all cylc scripts executable?"
    sys.exit(1)
