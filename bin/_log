#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, re, sys
from optparse import OptionParser
import tempfile
import subprocess
from cylc.registration import dbgetter, RegistrationError
from cylc.config import config, SuiteConfigError
from cylc.mkdir_p import mkdir_p
 
parser = OptionParser( """cylc [info] log [options] SUITE 
Print, or view in $EDITOR, local suite log files, with optional
filtering. This command is a convenience: you don't need to
know the log file location on disk.

Arguments:
  SUITE - Target suite.""")

parser.add_option( "-p", "--print", 
        help="Print the suite log file location and exit. This is "
        "equivalent to 'cylc get-config SUITE cylc logging directory'.",
        action="store_true", default=False, dest="print_location" )

parser.add_option( "-t", "--task", 
        help="Filter the log for messages from a specific task",
        metavar="TASK", action="store", default=None, dest="taskfilter" )

parser.add_option( "-f", "--filter", 
        help="Filter the log with a Python-style regular expression "
        "e.g. '\[(foo|bar).*(started|succeeded)'",
        metavar="RE", action="store", default=None, dest="regexfilter" )

parser.add_option( "-r", "--rotation", 
        help="Rotation number (to view older, rotated logs)",
        metavar="INT", action="store", default="0", dest="rotation" )

parser.add_option( "-e", "--edit",
        help="View a temporary copy of the (filtered) log file in $EDITOR "
        "instead of printing it to stdout.",
        action="store_true", default=False, dest="edit" )

( options, args ) = parser.parse_args()

if len(args) != 1:
    parser.error( "wrong number of arguments" )

reg = args[0]

dbg = dbgetter()
try:
    suite, suiterc = dbg.get_suite(reg)
except RegistrationError, x:
    raise SystemExit(x)

try:
    filename = os.path.join( config( suite, suiterc )['cylc']['logging']['directory'], 'log' )
except SuiteConfigError, x:
    raise SystemExit(x)
 
if options.rotation != "0":
    filename = filename + options.rotation

if options.print_location:
    print filename
    sys.exit(0)

filter = None
if options.taskfilter:
    filter = re.compile( '\\[' + options.taskfilter + '%\d{10}\\]' )
elif options.regexfilter:
    filter = re.compile( options.regexfilter )

# TO DO: exception handling for large files that exceed memory capacity?
# apparently readline() one line at a time is much slower than readlines()
try:
    LOG = open( filename )
except IOError:
    raise SystemExit( "ERROR: file not found: " + filename )

lines = LOG.readlines()
LOG.close()

if filter:
    filtered = []
    for line in lines:
        if re.search( filter, line ):
            filtered.append(line)
else:
    filtered = lines

if not options.edit:
    for line in filtered:
        print line.rstrip()
    sys.exit(0)

try:
    editor = os.environ['EDITOR']
except KeyError:
    raise SystemExit( 'export $EDITOR before using this command' )

if 'TMPDIR' in os.environ:
    tmpdir = os.environ['TMPDIR']
elif 'SCRATCH' in os.environ:
    tmpdir = os.environ['SCRATCH']
else:
    raise SystemExit( "ERROR: export $TMPDIR or $SCRATCH before 'cylc log'" )

# create $TMPDIR if necessary
try:
    mkdir_p( tmpdir )
except Exception,x:
    print >> sys.stderr, x
    print >> sys.stderr, 'ERROR, illegal tmpdir?', tmpdir
    sys.exit(1)

tmpfile = tempfile.mktemp( suffix = ".tmp", prefix = suite+'-log', dir = tmpdir )
tmp = open( tmpfile, 'wb' )
tmp.writelines( filtered )
tmp.close()

command_list = [ editor, tmpfile ]
try:
    # THIS BLOCKS UNTIL THE COMMAND COMPLETES
    retcode = subprocess.call( command_list )
    if retcode != 0:
        # the command returned non-zero exist status
        print >> sys.stderr, ' '.join( command_list ), ' failed: ', retcode
        sys.exit(1)

except OSError:
    # the command was not invoked
    print >> sys.stderr, 'ERROR: unable to execute ', ' '.join(command_list)
    sys.exit(1)
