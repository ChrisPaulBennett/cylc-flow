#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, re, sys
from shutil import move
import subprocess
import tempfile
from optparse import OptionParser
from collections import deque
from registration import getdb, RegistrationError
from mkdir_p import mkdir_p

done = []

def continuation_lines( inf ):
    outf = []
    cline = ''
    for line in inf:
        # detect continuation line endings
        m = re.match( '(.*)\\\$', line )
        if m:
            # add line to cline instead of appending to outf.
            cline += m.groups()[0]
        else:
            outf.append( cline + line )
            # reset cline 
            cline = ''
    return outf

def include_files( suitedir, inf, mark=False, single=False, label=False, level=None ):
    if level == None:
        level = ''
    else:
        if mark:
            level += '!'

    global done
    outf = []
    for line in inf:
        m = re.match( '\s*%include\s+([\w/\-\.]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if inc not in done:
                if single:
                    done.append(inc)
                if os.path.isfile(inc):
                    print " + inlining", inc
                    if single or label:
                        outf.append('++++ START INLINED INCLUDE FILE ' + match + '\n' )
                    h = open(inc, 'rb')
                    inc = h.readlines()
                    h.close()
                    # recursive inclusion
                    outf.extend( include_files( suitedir, inc, mark, single, label, level ))
                    if single or label:
                        outf.append('---- END INLINED INCLUDE FILE ' + match + '\n' )
                else:
                    raise SystemExit( "File not found: " + inc )
            else:
                outf.append(level + line)
        else:
            # no match
            outf.append(level + line)
    return outf

parser = OptionParser( """cylc [prep] inline [options] SUITE 

View a temporary copy of a suite config (suite.rc) file in your $EDITOR
(or GUI $GEDITOR) exactly as the config file parser sees it: with
include-files inlined and continuation lines joined. This can be used to
get a quick global view of a suite that uses include-files, or to trace
parsing errors by line number (suite validation is sufficiently
informative, however, that you should not need to do this).

If you want to edit the suite, in inlined form or not, or to view it
without inlined include-files, use the 'cylc prep edit' command.

The read-only edit process is spawned in the foreground as follows:
  $(G)EDITOR <temporary-inlined-file-in-$TMPDIR>
$GEDITOR or $EDITOR, and $TMDPIR, must be defined in your environment. 
Examples:
   export EDITOR=vim
   export GEDITOR='gvim -f'       # -f: do not detach from parent shell!!
   export EDITOR='xterm -e vim'  # for gcylc, if gvim is not available
   export GEDITOR=emacs
   export EDITOR='emacs -nw'
You can set both $GEDITOR and $EDITOR to a GUI editor if you like, but
$GEDITOR at least *must* be a GUI editor, or an in-terminal invocation 
of a non-GUI editor, if you want to spawn editing sessions via gcylc.

See also:
    cylc prep search
    cylc prep edit
    cylc prep validate

Arguments:
  SUITE   - suite registration [OWNER:]GROUP:NAME
            (user OWNER: to access the central database)""")

parser.add_option( "--mark", "-m", 
        help="Mark inclusions in the left margin (line numbers will "
        "still correspond to those reported by the parser).",
        action="store_true", default=False, dest="mark" )

parser.add_option( "--label", "-l", 
        help="Label file inclusion boundaries with the file name "
        "(line numbers will not correspond to those reported by the parser).",
        action="store_true", default=False, dest="label" )

parser.add_option( "--nojoin", "-n", 
        help="Do not join continuation lines (line numbers will "
        "not correspond to those reported by the parser).",
        action="store_true", default=False, dest="nojoin" )

parser.add_option( "--single", "-s", 
        help="Inline and label just the first instance of any "
        "multiply-included file (line numbers will not correspond to "
        "those reported by the parser).",
        action="store_true", default=False, dest="single" )

parser.add_option( "--gui", "-g", 
        help="Use GUI editor $GEDITOR instead of $EDITOR. This option is "
        "automatically used when an editing session is spawned by gcylc.",
        action="store_true", default=False, dest="geditor" )

( options, args ) = parser.parse_args()

if len(args) != 1:
    parser.error( "wrong number of arguments" )

suite = args[0]

if 'TMPDIR' in os.environ:
    tmpdir = os.environ['TMPDIR']
elif 'SCRATCH' in os.environ:
    tmpdir = os.environ['SCRATCH']
else:
    raise SystemExit( "ERROR: export $TMPDIR or $SCRATCH before 'cylc inline'" )
try:
    # create $TMPDIR if necessary
    mkdir_p( tmpdir )
except Exception,x:
    raise SystemExit(x)

if options.geditor:
    edvar = 'GEDITOR'
else:
    edvar = 'EDITOR'

try:
    editor = os.environ[edvar]
except KeyError:
    raise SystemExit( 'export $' + edvar + ' before using this command' )

# find location of the suite definition directory
try:
    reg = getdb(suite)
    reg.load_from_file()
    suitedir,descr = reg.get( suite )
except RegistrationError,x:
    raise SystemExit(x)

suiterc = os.path.join( suitedir, 'suite.rc' )

if not os.path.isfile( suiterc ):
    parser.error("Suite " + suite + " config file not found: " + suiterc )

h = open( suiterc, 'rb' )
lines = h.readlines()
h.close()

# inline any include files
lines = include_files( suitedir, lines, options.mark, options.single, options.label )

if not options.nojoin:
    # join any continuation lines
    lines = continuation_lines( lines )

inlined = tempfile.mktemp( suffix = ".rc", prefix = suite + '.', dir = tmpdir )
h = open( inlined, 'wb' )
h.writelines( lines )
h.close()

# set the file to be read only
os.chmod( inlined, 0444 )

# capture the temp file's mod time in case the user edits it
# and overrides the readonly mode.
modtime1 = os.stat( inlined ).st_mtime
 
# in case $EDITOR has options, e.g. 'emacs -nw':
command_list = re.split( ' ', editor )
command_list.append( inlined )
command = ' '.join( command_list )
try:
    # THIS BLOCKS UNTIL THE COMMAND COMPLETES
    retcode = subprocess.call( command_list )
    if retcode != 0:
        # the command returned non-zero exist status
        print >> sys.stderr, command, ' failed:', retcode
        sys.exit(1)
except OSError:
    # the command was not invoked
    print >> sys.stderr, 'ERROR: unable to execute:', command
    sys.exit(1)
 
# did the user edit the file
modtime2 = os.stat( inlined ).st_mtime

if modtime2 > modtime1:
    print
    print >> sys.stderr, 'WARNING: YOU HAVE EDITED THE TEMPORARY READ-ONLY SUITE.RC COPY, IF'
    print >> sys.stderr, 'YOU WANT TO RETAIN THE CHANGES, EXTRACT THEM FROM THE FILE HERE:'
    print >> sys.stderr, inlined
    print >> sys.stderr, 'In future, to *edit* a suite use \'cylc prep edit\', not \'cylc prep inline\'.'
    print
