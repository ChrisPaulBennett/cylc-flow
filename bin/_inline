#!/usr/bin/env python

import os, re, sys
from shutil import move
import subprocess
import tempfile
from optparse import OptionParser
from collections import deque
from registration import registrations

done = []

def include_files( suitedir, inf, single=False ):
    global done
    outf = []
    for line in inf:
        m = re.match( '\s*%include\s+([\w/\-\.]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if inc not in done:
                if single:
                    done.append( inc )
                if os.path.isfile(inc):
                    print " + inlining", inc
                    if single:
                        outf.append('++++ START INLINED INCLUDE FILE ' + match + '\n' )
                    h = open(inc, 'rb')
                    inc = h.readlines()
                    h.close()
                    # recursive inclusion
                    outf.extend( include_files( suitedir, inc, single ))
                    if single:
                        outf.append('------ END INLINED INCLUDE FILE ' + match + '\n' )
                else:
                    raise SystemExit( "File not found: " + inc )
            else:
                outf.append(line)
        else:
            # no match
            outf.append(line)
    return outf

parser = OptionParser( """cylc inline SUITE 

View a temporary copy of a suite config (suite.rc) file in your $EDITOR
with include-files inlined (this is how the cylc config file parser sees
the file, so can be useful in following up on errors reported by the
parser).

The editing process is spawned in the foreground as follows:
  $EDITOR <temporary inlined include-file>
(You must have $EDITOR defined in your shell environment). 

See also 'cylc search', an include-file aware suite search command.

Arguments:
  SUITE   - registered name of the suite.""")

parser.add_option( "--single", "-s", 
        help="Inline just the first instance of any multiply-included files, "
        "mark the inclusion, and leave subsequent %include commands alone. "
        "(note that this will invalidate config parser error line numbers)",
        action="store_true", default=False, dest="single" )

( options, args ) = parser.parse_args()

if len(args) != 1:
    parser.error( "wrong number of arguments" )

suite = args[0]

try:
    editor = os.environ['EDITOR']
except KeyError:
    raise SystemExit( 'export $EDITOR before using this command' )

try:
    tmpdir = os.environ['TMPDIR']
except KeyError:
    raise SystemExit( 'export $TMPDIR before using this command' )

# find location of the suite definition directory
reg = registrations()
if reg.is_registered( suite ):
    suitedir = reg.get( suite )
else:
    reg.print_all()
    raise SystemExit( "suite " + suite + " is not registered!" )

suiterc = os.path.join( suitedir, 'suite.rc' )

if os.path.isfile( suiterc ):
    h = open( suiterc, 'rb' )
    lines0 = h.readlines()
    h.close()
    # inline any include files
    lines = include_files( suitedir, lines0, options.single )
else:
    parser.error("Suite " + suite + " config file not found: " + suiterc )

inlined = tempfile.mktemp( suffix = ".rc", prefix = suite + '.', dir = tmpdir )
h = open( inlined, 'wb' )
h.writelines( lines )
h.close()

command_list = [ editor, inlined ]
 
try:
    # THIS BLOCKS UNTIL THE COMMAND COMPLETES
    retcode = subprocess.call( command_list )
    if retcode != 0:
        # the command returned non-zero exist status
        print >> sys.stderr, ' '.join( command_list ), ' failed: ', retcode
        sys.exit(1)
except OSError:
    # the command was not invoked
    print >> sys.stderr, 'ERROR: unable to execute ', ' '.join(command_list)
    sys.exit(1)
 
#print '\nRemoving temporary inlined file.'
#os.unlink( inlined )
