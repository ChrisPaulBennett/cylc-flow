#!/usr/bin/env python

import os, re, sys
from shutil import move
import subprocess
import tempfile
from optparse import OptionParser
from collections import deque
from registration import registrations

done = []

def include_files( suitedir, inf, single=False, label=False, level=None ):
    if level == None:
        level = ''
    else:
        level += '>'

    global done
    outf = []
    for line in inf:
        m = re.match( '\s*%include\s+([\w/\-\.]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if inc not in done:
                if single:
                    done.append(inc)
                if os.path.isfile(inc):
                    print " + inlining", inc
                    if single or label:
                        outf.append('++++ START INLINED INCLUDE FILE ' + match + '\n' )
                    h = open(inc, 'rb')
                    inc = h.readlines()
                    h.close()
                    # recursive inclusion
                    outf.extend( include_files( suitedir, inc, single, label, level ))
                    if single or label:
                        outf.append('------ END INLINED INCLUDE FILE ' + match + '\n' )
                else:
                    raise SystemExit( "File not found: " + inc )
            else:
                outf.append(level + line)
        else:
            # no match
            outf.append(level + line)
    return outf

parser = OptionParser( """cylc inline SUITE 

View a temporary copy of a suite config (suite.rc) file in your $EDITOR
with include-files inlined and marked in the left margin. The cylc
config file parser sees the file inlined so this is useful, if you use
include-files, in tracking errors reported by the parser).

The editing process is spawned in the foreground as follows:
  $EDITOR <temporary inlined file in $TMPDIR>
(You must have $EDITOR and $TMDPIR defined in your shell environment). 

See also 'cylc search' and 'cylc edit'.

Arguments:
  SUITE   - registered name of the suite.""")

parser.add_option( "--label", "-l", 
        help="Label inclusion boundaries with the include-file name"
        "(line numbers will no longer correspond to those reported by the parser).",
        action="store_true", default=False, dest="label" )

parser.add_option( "--single", "-s", 
        help="Inline and label just the first instance of any multiply-included file "
        "(line numbers will no longer correspond to those reported by the parser).",
        action="store_true", default=False, dest="single" )

( options, args ) = parser.parse_args()

if len(args) != 1:
    parser.error( "wrong number of arguments" )

suite = args[0]

try:
    editor = os.environ['EDITOR']
except KeyError:
    raise SystemExit( 'export $EDITOR before using this command' )

try:
    tmpdir = os.environ['TMPDIR']
except KeyError:
    raise SystemExit( 'export $TMPDIR before using this command' )

# find location of the suite definition directory
reg = registrations()
if reg.is_registered( suite ):
    suitedir = reg.get( suite )
else:
    reg.print_all()
    raise SystemExit( "suite " + suite + " is not registered!" )

suiterc = os.path.join( suitedir, 'suite.rc' )

if os.path.isfile( suiterc ):
    h = open( suiterc, 'rb' )
    lines0 = h.readlines()
    h.close()
    # inline any include files
    lines = include_files( suitedir, lines0, options.single, options.label )
else:
    parser.error("Suite " + suite + " config file not found: " + suiterc )

inlined = tempfile.mktemp( suffix = ".rc", prefix = suite + '.', dir = tmpdir )
h = open( inlined, 'wb' )
h.writelines( lines )
h.close()

# in case $EDITOR has options, e.g. 'emacs -nw':
command_list = re.split( ' ', editor )
command_list.append( inlined )
command = ' '.join( command_list )
try:
    # THIS BLOCKS UNTIL THE COMMAND COMPLETES
    retcode = subprocess.call( command_list )
    if retcode != 0:
        # the command returned non-zero exist status
        print >> sys.stderr, command, ' failed:', retcode
        sys.exit(1)
except OSError:
    # the command was not invoked
    print >> sys.stderr, 'ERROR: unable to execute:', command
    sys.exit(1)
 
#print '\nRemoving temporary inlined file.'
#os.unlink( inlined )
