#!/usr/bin/env python

import sys
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

global debug
debug = True

class warmstart( scheduler ):
    def __init__( self ):
        usage = """cylc control warmstart [options] SUITE YYYYMMDDHH

WARM START a suite at a specified cycle time. This assumes that there
was a previous cycle (from a previous suite run - in which case a
restart may be more appropriate) or that files required from previous
cycles have been put in place by some other means. For a suite with no
intercycle dependencies (=> no warm cycled forecast models) there is no
distinction between the cold, warm, and raw start methods.

Startup is as for a cold start, except that designated cold start tasks
are inserted in the 'finished' state (i.e. outputs completed). The cold
start task list must be defined in the suite config file:
  SUITE.RC: [special tasks] -> coldstart = task1, task2, ...
  
NOTE: to prevent a suite being killed when you log out: 
  $  export PYTHONUNBUFFERED=true   # (*)
  $  nohup cylc con warmstart SUITE YYYYMMDDHH
(*) with nohup, stdout buffering can result in no output until shutdown.

See also:
    cylc con coldstart
    cylc con rawstart
    cylc con restart

Arguments:
   SUITE                Registered name of the suite to start.
   YYYYMMDDHH           Initial cycle time.""" 

        self.parser = OptionParser( usage )
        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        if len( self.args ) != 2:
            self.parser.error( "Please supply a suite name and initial cycle time." )

        if cycle_time.is_valid( self.args[1] ):
            self.start_time = self.args[1]
        else:
            self.parser.error( "Invalid cycle time: " + self.args[1])

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug

        self.banner[ "WARM START" ] = self.start_time

    def load_tasks( self ):
        self.log.info( 'Warm Start ' + self.start_time )

        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'coldstart task list' CONFIG ITEM" )

        for name in task_list:
            # (startup=True is only for coldstart)
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', startup=False )
            if name in coldstart_tasks:
                itask.log( 'WARNING', "warm start: starting in finished state" )
                itask.state.set_status( 'finished' )
                itask.prerequisites.set_all_satisfied()
                itask.outputs.set_all_complete()
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.insert( itask )

if __name__ == '__main__':
    try:
        server = warmstart()
    except Exception, x:
        if debug:
            raise
        else:
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print "ERROR CAUGHT, will clean up before exit"
        # this assumes no exceptions in shutdown()
        server.shutdown()

        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print "ERROR CAUGHT; will clean up before exit"
        server.shutdown()
        raise
