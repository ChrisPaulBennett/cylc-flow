#!/usr/bin/env python

import sys
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

global debug
debug = True

class warmstart( scheduler ):
    def __init__( self ):
        usage = """cylc warmstart [options] SUITE CYCLE

WARM START a suite at a given cycle time. This assumes that the restart
dependencies of any forecast models in the suite have already been
satisfied, i.e. it assumes the existence of a previous cycle. This could
mean there was literally a previous suite run, or that the relevant
restart files have been put in place by some external means.

Each task proxy is inserted in the 'waiting' state (i.e. prerequisites
not satisfied) at the initial cycle time, or at the next valid cycle
time for the task, except for designated cold start tasks (see suite.rc
documentation) which are inserted in the 'finished' state (i.e. outputs
completed).

IMPORTANT: To do a warmstart the 'coldstart task list' suite config item
must be set - these tasks will be inserted in the 'finished' state.

WARNING: when you start an important suite use the 'nohup' command to
detach the suite from its parent shell, to prevent it being killed when
you log out. Also, when using nohup, 
    export PYTHONUNBUFFERED=true
so that cylc stdout will be written to nohup.out as the suite runs.

See also:
    cylc coldstart SUITE
    cylc rawstart SUITE

Arguments:
   SUITE                Registered name of the suite to start.
   CYCLE                Initial cycle time (YYYYMMDDHH).""" 

        self.parser = OptionParser( usage )
        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        if len( self.args ) != 2:
            self.parser.error( "Please supply a suite name and initial cycle time." )

        if cycle_time.is_valid( self.args[1] ):
            self.start_time = self.args[1]
        else:
            self.parser.error( "Invalid cycle time: " + self.args[1])

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug

        self.banner[ "WARM START" ] = self.start_time

    def load_tasks( self ):
        self.log.info( 'Warm Start ' + self.start_time )

        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'coldstart task list' CONFIG ITEM" )

        for name in task_list:
            # (startup=True is only for coldstart)
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', startup=False )
            if name in coldstart_tasks:
                itask.log( 'WARNING', "warm start: starting in finished state" )
                itask.state.set_status( 'finished' )
                itask.prerequisites.set_all_satisfied()
                itask.outputs.set_all_complete()
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.insert( itask )

if __name__ == '__main__':
    try:
        server = warmstart()
    except Exception, x:
        if debug:
            raise
        else:
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print "ERROR CAUGHT, will clean up before exit"
        # this assumes no exceptions in shutdown()
        server.shutdown()

        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print "ERROR CAUGHT; will clean up before exit"
        server.shutdown()
        raise
