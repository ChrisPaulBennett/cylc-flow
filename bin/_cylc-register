#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# This command used to check the pyro nameserver to make sure a suite
# was not in use before deleting a registration. However, this just
# gives a false sense of security because it won't work if the user
# deliberately or otherwise gives the wrong pyro nameserver host to
# check.

import os, sys
import socket
from optparse import OptionParser
from registration import registrations

#----------------------------------------
def check_dir( dir ):
    if not os.path.exists( dir ):
        print "ERROR, dir not found: " + dir
        return False

    files = [\
            dir + '/suite_config.py',
            dir + '/task_classes.py',
            dir + '/task_list.py',
            ]

    good = True
    for file in files:
        if not os.path.exists( file ):
            print "file not found: " + file
            good = False

    return good
 
#----------------------------------------

parser = OptionParser( usage = """cylc register [options] [PATH] [SUITE]

Use this command to create and manage cylc suite registrations, which 
are associations between suite names and suite definition directories.
Registrations are stored in $HOME/.cylc/registrations.

1/ Create a new registration:
     $ cylc register PATH SUITE

2/ Retrieve or delete an existing registration:
     $ cylc register [--get] [--delete] SUITE

3/ List all of your registrations:
     $ cylc register --list

4/ Delete all registrations, or just those that are no longer valid
  (i.e. that don't point to a configured suite definition directory):
     $ cylc register [--wipe] [--check]

Most cylc commands require a registered suite name argument in order to
identify the target suite. Registered names are also used, by default,
in suite logging and state dump directory paths, which allows you to
run multiple suites at once without interference between them. 

If you register a single suite under several different names you can
also run real and dummy mode instances of that suite simultaneously
(but see also 'cylc restart --practice-mode' which automates this
without requiring a new registration).

The registered name is also exported into the execution environment of
all suite tasks as $CYLC_SUITE_NAME. If all tasks use this in all I/O
directory and file paths, you can even run multiple simultaneous real
mode instances of a single suite (e.g. over different time periods). 
The cylc Userguide example suite is capable of this.

Deletion of a suite registration does not delete the suite, just the
assocation between the name and the suite definition directory. If you
delete the registration of a running suite you will not be able to
access the suite with cylc commands until you re-register it under the
same name.

Arguments:
  PATH            Path to a configured cylc suite definition directory.
  SUITE           Suite name.""" )

parser.add_option( "-g", "--get",
        help="Get the suite definition directory for SUITE.",
        action="store_true", default=False, dest="get" )

parser.add_option( "-p", "--print",
        help="Print current suite registrations (same as --list).",
        action="store_true", default=False, dest="listall" )

parser.add_option( "-l", "--list",
        help="List current suite registrations.",
        action="store_true", default=False, dest="listall" )

parser.add_option( "-u", "--user",
        help="Read another user's suite registrations.", 
        metavar="USER", action="store", default=None, dest="user" )

parser.add_option( "-d", "--delete",
        help="Delete the registration with name SUITE.",
        action="store_true", default=False, dest="delete" )

parser.add_option( "-c", "--check",
        help="Delete any registrations that are not valid.",
        action="store_true", default=False, dest="check" )

parser.add_option( "-w", "--wipe",
        help="Delete all of your suite registrations.",
        action="store_true", default=False, dest="wipe" )

( options, args ) = parser.parse_args()

new_reg = False
get_reg = False
del_reg = False
lst_reg = False
chk_reg = False
wpe_reg = False

if len(args) == 2:
    # + cylc register PATH SUITE
    new_reg = True

    dir = os.path.abspath( args[0] )
    name = args[1]

elif len(args) == 1:
    # + cylc register --get SUITE
    # + cylc register --delete SUITE
    name = args[0]
    if options.get:
        get_reg = True
    elif options.delete:
        del_reg = True
    else:
        parser.error( "Please specify what to do with '" + name + "'" )

elif len(args) == 0:
    # + cylc register --check
    # + cylc register --wipe
    # + cylc register --list
    if options.check:
        chk_reg = True
    elif options.wipe:
        wpe_reg = True
    elif options.listall:
        lst_reg = True
    else:
        parser.print_usage()
        sys.exit(0)
else:
    parser.error( "Wrong number of arguments")

if [ new_reg, get_reg, del_reg, lst_reg, chk_reg, wpe_reg ].count( True ) != 1:
    parser.error( "Choose one option only" )

# load registration file
reg = registrations( options.user )

#---------------------------------------
if new_reg:
    if not os.path.exists( dir ):
        raise SystemExit( "ERROR, directory not found: " + dir )

    if not check_dir( dir ):
        raise SystemExit( "ERROR, " + dir + " has not been configured" )

    reg.register( name, dir )
    reg.dump_to_file()
    sys.exit(0)

if options.user:
    if options.user != os.environ[ 'USER' ]:
        if del_reg or chk_reg or wpe_reg:
            parser.error( "You cannot delete, wipe, or check another user's registrations" )

#---------------------------------------
if get_reg:
    # print one registration and exit
    if reg.is_registered( name ):
        print reg.get( name )
        sys.exit(0)
    else:
        print name + " is not registered"
        sys.exit(1)

#---------------------------------------
if lst_reg:
    # print all registrations and exit
    reg.print_all()
    sys.exit(0)

#----------------------------------------
twatted = []

if chk_reg:
    if chk_reg:
        count = 0
        for name in reg.get_all():
            count += 1
            rdir = reg.get(name)
            if not check_dir( rdir ):
                post = ' ... INVALID'
                twatted.append( name )

            else:
                post = ' ... OK'
            reg.print_reg( name, pre=' [' + str(count) + '] ', post=post )

elif wpe_reg:
    twatted = reg.get_all() 

elif del_reg:
    twatted = [ args[0] ] 

if len(twatted) == 0:
    print "No suites to unregister"
    sys.exit(0)

count = 0
print "Unregistering " + str( len(twatted) ) + " suites:"
for twat in twatted:
    count += 1
    print ' [' + str( count ) + '] ' + twat
    reg.unregister( twat )

# record registration changes
reg.dump_to_file()
