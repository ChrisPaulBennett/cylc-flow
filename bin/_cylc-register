#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# This command used to check the pyro nameserver to make sure a system
# was not in use before deleting a registration. However, this just
# gives a false sense of security because it won't work if the user
# deliberately or otherwise gives the wrong pyro nameserver host to
# check.

import os, sys
import socket
from optparse import OptionParser
from registration import registrations

#----------------------------------------
def check_dir( dir ):
    if not os.path.exists( dir ):
        print "ERROR, dir not found: " + dir
        return False

    files = [\
            dir + '/system_config.py',
            dir + '/task_classes.py',
            dir + '/task_list.py',
            ]

    good = True
    for file in files:
        if not os.path.exists( file ):
            print "file not found: " + file
            good = False

    return good
 
#----------------------------------------

parser = OptionParser( usage = """1/ Create a new system registration:
$ cylc register [options] [PATH] [SYSTEM]

Use this command to manage your cylc system registrations, which are
stored under your cylc config directory ($HOME/.cylc).

Cylc commands target a particular system via its registered name, and it
is also used in system logging and state dump directory paths to allow
you to run multiple systems at once. 

If you register a single system under several different names you can
run real and dummy mode instances of the system simultaneously without
any interference between them (but see also 'cylc start --practice-mode'
which automates this without requiring a new registration). 

The registered name is also exported into the execution environment of
all system tasks as $CYLC_SYSTEM_NAME. If tasks use this to dynamically
configure their I/O directories it is even possible to run multiple
simultaneous real mode instances of a single system. 

Deletion of a system registration does not delete the system, just the
assocation between the name and the system definition directory.

If you delete the registration of a running system you will not be able
to access the system with cylc commands until you re-register the system
under the same name.

Arguments:
  PATH            A configured cylc system definition directory.
  SYSTEM          Name to associate with the configured system directory.""" )

parser.add_option( "-g", "--get",
        help="Print the system directory registered under NAME.",
        action="store_true", default=False, dest="get" )

parser.add_option( "-l", "--list",
        help="Print all current system registrations.",
        action="store_true", default=False, dest="listall" )

parser.add_option( "--user",
        help="Attempt read-access to another user's system registrations.", 
        metavar="USER", action="store", default=None, dest="user" )

parser.add_option( "-d", "--delete",
        help="Delete the registered system name SYSTEM.",
        action="store_true", default=False, dest="delete" )

parser.add_option( "-c", "--check",
        help="Check all your current system registrations, and "
        "delete any found to be invalid.",
        action="store_true", default=False, dest="check" )

parser.add_option( "-w", "--wipe",
        help="Delete all of your current system registrations.",
        action="store_true", default=False, dest="wipe" )

( options, args ) = parser.parse_args()

new_reg = False
get_reg = False
del_reg = False
lst_reg = False
chk_reg = False
wpe_reg = False

if len(args) == 2:
    # + cylc register PATH SYSTEM
    new_reg = True

    dir = os.path.abspath( args[0] )
    name = args[1]

elif len(args) == 1:
    # + cylc register --get SYSTEM
    # + cylc register --delete SYSTEM
    name = args[0]
    if options.get:
        get_reg = True
    elif options.delete:
        del_reg = True
    else:
        parser.error( "Please specify what to do with '" + name + "'" )

elif len(args) == 0:
    # + cylc register --check
    # + cylc register --wipe
    # + cylc register --list
    if options.check:
        chk_reg = True
    elif options.wipe:
        wpe_reg = True
    elif options.listall:
        lst_reg = True
    else:
        parser.print_usage()
        sys.exit(0)
else:
    parser.error( "Wrong number of arguments")

if [ new_reg, get_reg, del_reg, lst_reg, chk_reg, wpe_reg ].count( True ) != 1:
    parser.error( "Choose one option only" )

#---------------------------------------
if new_reg:
    if not os.path.exists( dir ):
        raise SystemExit( "ERROR, directory not found: " + dir )

    if not check_dir( dir ):
        raise SystemExit( "ERROR, " + dir + " has not been configured" )

    reg.register( name, dir )
    reg.dump_to_file()
    sys.exit(1)

if options.user:
    if options.user != os.environ[ 'USER' ]:
        if del_reg or chk_reg or wpe_reg:
            parser.error( "You cannot delete, wipe, or check another user's registrations" )

# load registration file
reg = registrations( options.user )

#---------------------------------------
if get_reg:
    # print one registration and exit
    if reg.is_registered( name ):
        print reg.get( name )
        sys.exit(0)
    else:
        print name + " is not registered"
        sys.exit(1)

#---------------------------------------
if lst_reg:
    # print all registrations and exit
    reg.print_all()
    sys.exit(0)

#----------------------------------------
twatted = []

if chk_reg:
    if chk_reg:
        count = 0
        for name in reg.get_all():
            count += 1
            rdir = reg.get(name)
            if not check_dir( rdir ):
                post = ' ... INVALID'
                twatted.append( name )

            else:
                post = ' ... OK'
            reg.print_reg( name, pre=' [' + str(count) + '] ', post=post )

elif wpe_reg:
    twatted = reg.get_all() 

elif del_reg:
    twatted = [ args[0] ] 

if len(twatted) == 0:
    print "No systems to unregister"
    sys.exit(0)

count = 0
print "Unregistering " + str( len(twatted) ) + " systems:"
for twat in twatted:
    count += 1
    print ' [' + str( count ) + '] ' + twat
    reg.unregister( twat )

# record registration changes
reg.dump_to_file()
