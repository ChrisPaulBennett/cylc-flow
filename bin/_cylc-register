#!/bin/bash

set -e  # ABORT on error

function print_usage() 
{
	echo "usage:"
    echo "  cylc register [-f] [-p PATH] NAME"
    echo "  cylc register [-d] NAME"
    echo "  cylc register [-c] [-r]"
    echo ""
    echo "Register a configured cylc system for use under a given name,"
    echo "or review, check, or unregister currently registered systems." 
    echo ""
    echo "Registration associates a name with a system definition directory."
    echo "Other cylc commands then target systems via their registered name."
    echo ""
    echo "Registered names are also used along with your username to construct"
    echo "a unique Pyro nameserver 'group name' for any system that you run."
    echo "This allows multiple systems, from multiple users, to run at once"
    echo "without interfering with each other (i.e. external tasks will not"
    echo "be able to send messages to the wrong scheduler instance)."
    echo ""
    echo "You can register the same system under multiple names. This makes"
    echo "it is possible, in principle, to run multiple instances of the"
    echo "same system at once. Be aware, however, that the external system"
    echo "must also be capable of doing this (perhaps by incorporating the"
    echo "cylc system name into its input and output directory paths and"
    echo "so on - it is safer and easier to run multiple *copies* of a"
    echo "system, each with different configuration and/or task definition"
    echo "settings so that the external systems are in effect separate)."
    echo ""
    echo "Registration information is stored under \$HOME/.cylc/registered."
    echo ""
    echo "arguments:"
    echo "   NAME        Name under which to register a configured system."
    echo ""
    echo "options:"
    echo "  -h, --help   Print this usage message and exit"
    echo "  -p PATH      Location of the configured system to be registered."        
    echo "  -c           Check all currently registered systems, print"
    echo "               their names and locations, and unregister any"
    echo "               that no longer point to a configured system."
    echo "  -f           Force: overwrite an existing registration."
    echo "  -d           Delete (unregister) the supplied system name."
    echo "  -r           Reset: delete (unregister) ALL your registered"
    echo "               system names."
}

function check_configured()
{
    SYS_DIR=$1

    # is this a cylc system definition directory?
    if [[ ! -d $SYS_DIR/taskdef/ || \
        ! -d $SYS_DIR/scripts ]]; then
        echo "ERROR: $SYS_DIR"
        echo "is not a cylc system definition directory: it does"
        echo "not contain taskdef and/or scripts sub-directories."
        return 1
    fi

    # has this cylc system definition directory been configured yet?
    if [[ ! -f $SYS_DIR/config_defaults.py || \
        ! -f $SYS_DIR/system_tasks.py ]]; then
        echo "ERROR: $SYS_DIR"
        echo "has not been configured yet: it does not contain config"
        echo "and/or task class modules. Use 'cylc configure' first."
        return 1
    fi

    # all good
    return 0
}

# cheap hack to get '--help', which isn't allowed by getopts
if [[ $1 == '--help' ]]; then
    print_usage
    exit 0
fi

CHECK=false
FORCE=false
RESET=false
DELETE=false
REGISTER=false
while getopts "rdfchp:" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        p)
        REGISTER=true
        SYS_DIR=$OPTARG
        ;;
        d)
        DELETE=true
        ;;
        c)
        CHECK=true
        ;;
        f)
        FORCE=true
        ;;
        r)
        RESET=true
        ;;
    esac
done

shift $(( OPTIND -1 ))

if $REGISTER || $DELETE; then
    if [[ $# == 1 ]]; then
        NAME=$1
    else
        echo "You have supplied a system path, but no name"
        usage
        exit 1
    fi
else
    if [[ $# != 0 ]]; then
        echo "Too many arguments for your chosen options"
        usage
        exit 1
    fi
fi

if ! $REGISTER && ! $DELETE && ! $CHECK && ! $RESET; then
    print_usage
    exit 1
fi

# make the registration directory if necessary
REG_DIR=$HOME/.cylc/registered
[[ ! -d $REG_DIR ]] && mkdir -p $REG_DIR

if $RESET; then
    echo "WARNING: DELETING ALL CURRENT SYSTEM REGISTRATIONS"
    COUNT=0
    cd $REG_DIR
    for REG in *; do
        COUNT=$((COUNT+1))
        echo "[$COUNT] $REG: $(cat $REG)"
        rm $REG
    done
    exit 0
fi

if $DELETE; then
    REG=$REG_DIR/$NAME
    if [[ -f $REG ]]; then
        echo "DELETING: $NAME -> $(cat $REG)"
        rm $REG
        exit 0
    else
        echo "ERROR: $NAME is not registered."
        exit 1
    fi
fi

if $REGISTER; then
    if [[ $SYS_DIR != /* ]]; then
        # make absolute path
        SYS_DIR=$PWD/$SYS_DIR
        # remove trailing '/'
        SYS_DIR=${SYS_DIR%/}
    fi

    # check the new system has been configured
    ! check_configured $SYS_DIR && exit 1

    # is the system already registered?
    if [[ -f $REG_DIR/$NAME ]]; then
        TO=$( cat $REG_DIR/$NAME )
        if [[ $TO = $SYS_DIR ]]; then
            # already registered as requested
            echo "ALREADY REGISTERED: $NAME -> $SYS_DIR"
            exit 0
        else
            # already registered for access to another system
            if ! $FORCE; then
                echo "ALREADY REGISTERED: $NAME -> $TO"
                echo "Use the '-f' option to re-register"
                exit 1
            fi # else continue on to the reg code below
        fi
    fi
    
    # register the system
    echo $SYS_DIR > $REG_DIR/$NAME
    echo "NEW: $NAME -> $SYS_DIR"

    exit 0
fi

if $CHECK; then
    # go to user registration directory
    cd $REG_DIR
    # how many systems registered?
    N_REG=$( ls -1 | wc -l )
    echo "You have $N_REG systems registered"
    [[ $N_REG = 0 ]] && exit 0

    # check and print each registered system
    COUNT=0
    for NAME in *; do 
        COUNT=$((COUNT + 1 ))
        SYS_DIR=$( cat $NAME )
        if check_configured $SYS_DIR; then
            echo "[${COUNT}] ${NAME}: $SYS_DIR"
        else
            echo " UNREGISTERING $NAME"
            rm -f $NAME
        fi
    done
    exit 0
fi
