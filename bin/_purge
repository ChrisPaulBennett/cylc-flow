#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


import os, sys
import cycle_time
import cylc_pyro_client
import Pyro.errors
from CylcOptionParsers import PromptOptionParser

parser = PromptOptionParser( """cylc purge [options] SUITE TASK_ID STOP

Remove an entire tree of dependent tasks, rooted on a given task, from a
running suite. The root task will be forced to spawn and die, and then
force every task that depends on it, and then every task that depends on
them, and so on until the given stop cycle time.

WARNING: THIS COMMAND IS DANGEROUS, but you can use an instant practice
mode clone (see 'cylc restart --help') to test your planned intervention,
or in case of disaster simply restart the suite from the automatic
pre-purge state dump (the filename will be logged by cylc before
actioning the purge.)""",
["TASK_ID              Task at which to start the purge (NAME%YYYYMMDDHH).",
 "STOP                 Cycle (inclusive!) at which to stop (YYYYMMDDHH)"] )

(options, args) = parser.parse_args()

if len( args ) != 3:
    parser.error( "suite name, task ID, and stop cycle required." )

target = args[1]
stop = args[2]

# check inputs
try:
    ( name, start ) = target.split('%')
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH")
 
for cycle in [ start, stop ]:
    if not cycle_time.is_valid( cycle ):
        parser.error( "invalid cycle time: " + cycle )

if not parser.prompt( 'Purge from ' + target + ' to ' + stop + ' in'):
    sys.exit(0)
    
suite = parser.get_suite_name()
owner = os.environ['USER']
host = options.host
port = options.port

try:
    proxy = cylc_pyro_client.client( suite, owner, host, port ).get_proxy( 'remote' )
    actioned, explanation = proxy.purge( target, stop, owner )
    print explanation
except Pyro.errors.NamingError, x:
    if options.debug:
        raise
    else:
        print x
        sys.exit(1)

if not actioned:
    sys.exit(1)
