#!/usr/bin/env python


import os, sys
import cycle_time
import cylc_pyro_client
from CylcOptionParsers import PromptOptionParser
from port_scan import SuiteIdentificationError

parser = PromptOptionParser( """cylc control purge [options] SUITE TASK_ID STOP

Remove an entire tree of dependent tasks from a running suite. The root
task will be forced to spawn and die, then so will every task that
depends on it, then every task that depends on those, and so on until
the specified stop cycle time.

WARNING: THIS COMMAND IS DANGEROUS, but in case of disaster you can
simply restart the suite from the automatic pre-purge state dump (the
filename will be logged by cylc before the purge is actioned.)

Note that the immediate downstream dependents of the root task will only
be detected if they exist at the time the purge is done. If you purge
before all such tasks have been spawned by their upstream predecessors,
those tasks will have to be cleaned up later with \lstinline=cylc
remove""",
["TASK_ID              Task at which to start the purge (NAME%YYYYMMDDHH).",
 "STOP                 Cycle (inclusive!) at which to stop (YYYYMMDDHH)"] )

(options, args) = parser.parse_args()

if len( args ) != 3:
    parser.error( "suite name, task ID, and stop cycle required." )

target = args[1]
stop = args[2]

try:
    ( name, start ) = target.split('%')
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH")
 
for cycle in [ start, stop ]:
    if not cycle_time.is_valid( cycle ):
        parser.error( "invalid cycle time: " + cycle )

suite = parser.get_suite_name()
owner = os.environ['USER']
host = options.host
port = options.port

try:
    proxy = cylc_pyro_client.client( suite, owner, host, port ).get_proxy( 'remote' )
except SuiteIdentificationError, x:
    raise SystemExit(x)

if not parser.prompt( 'Purge from ' + target + ' to ' + stop + ' in'):
    sys.exit(0)

actioned, explanation = proxy.purge( target, stop, owner )

print explanation
if not actioned:
    sys.exit(1)
