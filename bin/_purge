#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, sys
import cycle_time
import cylc_pyro_client
from CylcOptionParsers import PromptOptionParser
from port_scan import SuiteIdentificationError

parser = PromptOptionParser( """cylc [control] purge [options] SUITE TASK_ID STOP

Remove an entire tree of dependent tasks from a running suite. The root
task will be forced to spawn and die, then so will every task that
depends on it, then every task that depends on those, and so on until
the specified stop cycle time.

WARNING: THIS COMMAND IS DANGEROUS, but in case of disaster you can
simply restart the suite from the automatic pre-purge state dump (the
filename will be logged by cylc before the purge is actioned.)

Note that downstream tasks dependent on the root task will only be
detected as such if they exist at the time the purge is done. In other
words, if you want purge task P(T), and X(T) depends on P(T), but P is 
still running T-6, or whatever, and has not spawned a successor at T, 
then X will not affected by the purge. To avoid this, wait until all
tasks that depend on P have caught up to P(T) before purging.
[development note: post cylc-3.0 we could easily determine, via the
suite dependency graph, that X(T) needs to be included in the purge even
if it has not appeared in the suite yet.]

remove""",
["TASK_ID              Task at which to start the purge (NAME%YYYYMMDDHH).",
 "STOP                 Cycle (inclusive!) at which to stop (YYYYMMDDHH)"] )

(options, args) = parser.parse_args()

if len( args ) != 3:
    parser.error( "suite name, task ID, and stop cycle required." )

target = args[1]
stop = args[2]

try:
    ( name, start ) = target.split('%')
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH")
 
for cycle in [ start, stop ]:
    if not cycle_time.is_valid( cycle ):
        parser.error( "invalid cycle time: " + cycle )

suite = parser.get_suite_name()

try:
    proxy = cylc_pyro_client.client( suite ).get_proxy( 'remote' )
except SuiteIdentificationError, x:
    raise SystemExit(x)

if not parser.prompt( 'Purge from ' + target + ' to ' + stop + ' in'):
    sys.exit(0)

result = proxy.purge( target, stop )

if result.success:
    print result.reason
else:
    print 'ERROR:', result.reason
    sys.exit(1)
