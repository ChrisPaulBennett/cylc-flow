#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# standard Python modules
import os, sys
#import profile
import socket
from optparse import OptionParser
from time import sleep

# cylc source modules
import pyrex

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError
from Pyro.ext.daemonizer import Daemonizer
from lockserver import lockserver

class ServerDaemon( Daemonizer ):
    def __init__( self, pidfile, pns_host ):
        self.pns_host = pns_host
        Daemonizer.__init__(self, pidfile)

    def main_loop( self ):
        foo = open( "/home/oliverh/cylc/foo.txt", "a" )
        server = None
        try:
            server = LockServer(self.pns_host)
        except Exception, x:
            foo.write( str(x) + "\n" )
        else:
            pass

        bar = open( "/home/oliverh/cylc/bar.txt", "a" )
        try:
            server.start()
        except Exception, x:
            bar.write( str(x) + "\n" )
        else:
            pass



class LockServer:

    def __init__( self, pns_host ):
        # LOCATE THE PYRO NAMESERVER-------------------------------------------
        #self.nameserver = pyrex.discover( pns_host )
        try:
            self.nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
        except NamingError:
            raise SystemExit("Failed to find a Pyro nameserver on " + hostname )

        # CREATE A UNIQUE NAMESERVER GROUPNAME FOR THE LOCK SERVER ------------
        self.groupname = 'cylc'
        #self.nameserver.create_groupname( self.groupname )
        try:
            self.nameserver.createGroup( self.groupname )
        except:
            self.nameserver.deleteGroup( self.groupname )
            self.nameserver.createGroup( self.groupname )

        Pyro.config.PYRO_MULTITHREADED = 0
        # USE DNS NAMES INSTEAD OF FIXED IP ADDRESSES FROM /etc/hosts
        # (see the Userguide "Networking Issues" section).
        Pyro.config.PYRO_DNS_URI = True
        Pyro.config.PYRO_STDLOGGING = True
        Pyro.config.PYRO_TRACELEVEL = 3
        Pyro.core.initServer()


    def start( self ):
        # CREATE A PYRO pyro_daemon FOR THIS SYSTEM
        # (single threaded prob not necessary for lockserver
        # but it doesn't matter as few connections needed)
        self.pyro_daemon = Pyro.core.Daemon()
        #pyro_daemon.useNameServer(self.nameserver.get_ns())
        self.pyro_daemon.useNameServer(self.nameserver)

        self.locker = lockserver()
        #pyro_daemon.connect( self.locker, self.nameserver.obj_name( 'lockserver', self.groupname ))
        self.pyro_daemon.connect( self.locker, 'cylc.lockserver' )

        while True:
            self.pyro_daemon.handleRequests()


if __name__ == "__main__":

    usage = """1/ cylc lock-server --start|debug [options]
Usage: 2/ cylc lock-server --restart|stop|status" 

    Start, stop, restart, or check the status of, the cylc lock server.
    The lock server prevents accidental invocation of multiple instances
    of the same task at the same cycle time. It works similarly to a
    traditional "lock file", but works even for tasks that start and
    finish running on different hosts. It also prevents multiple copies
    of a system being run at once under different names, unless the
    system definition indicates the system is capable of doing that. 
    """

    parser = OptionParser( usage )

    #parser.set_defaults( pns_host= socket.getfqdn(), start=False,
    #        restart=False, stop=False, status=False )

    parser.set_defaults( pns_host= socket.getfqdn() )

    parser.add_option( "--host",
            help="(--(re)start only) Pyro nameserver host, defaults to the local hostname. Use "
            "if not auto-detected (which depends on network config).", 
            metavar="HOSTNAME", action="store", dest="pns_host" )

    #    parser.add_option( "--start", help="start the cylc lock server",
    #        action="store_true", dest="start" )

    #parser.add_option( "--stop", help="stop the cylc lock server",
    #        action="store_true", dest="stop" )

    #parser.add_option( "--restart", help="restart the cylc lock server",
    #        action="store_true", dest="restart" )

    #parser.add_option( "--status", help="check if the cylc lock server is running",
    #        action="store_true", dest="status" )

    ( options, args ) = parser.parse_args()

    #count = 0
    #for opt in [ options.start, options.restart, options.stop, options.status ]:
    #    if opt:
    #        count += 1

    #if count != 1:
    #    parser.error( "choose one option only!" )
    
    # get Pyro nameserver hostname-----------------------------------------
    if not options.pns_host:
        # (this won't happen; defaults to local hostname)
        parser.error( "Required: Pyro nameserver hostname" )
    else:
        pns_host = options.pns_host

    #server = None
    #try:
    #    if sys.argv[1] in ( 'start', 'debug' ):
    #        server = LockServer( pns_host )
    #except IndexError:
    #    pass

    #server_daemon = ServerDaemon( '/home/oliverh/cylc/ls.pid', server ) 
    server_daemon = ServerDaemon( '/home/oliverh/cylc/ls.pid', pns_host ) 
    server_daemon.process_command_line(sys.argv)

    #argv = None
    #if options.start:
    #    argv = 'start'
    #elif options.stop:
    #    argv = 'stop'
    #elif options.restart:
    #    argv = 'restart'
    #elif options.status:
    #    argv = 'status'

    #foo = LockServer( "/home/oliverh/cylc/lockserver.pid", pyro_daemon )
    #foo.process_command_line( [ "foo", argv ] )
    
