#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# standard Python modules
import os, sys
import cylcrc
import socket
from optparse import OptionParser
from time import sleep

# cylc source modules
import pyrex

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError
from Pyro.ext.daemonizer import Daemonizer
from lockserver import lockserver

class ServerDaemon( Daemonizer ):
    def __init__( self, pidfile, pns_host, logfile ):
        self.pns_host = pns_host
        self.logfile = logfile
        Daemonizer.__init__(self, pidfile)

    def main_loop( self ):
        # NOTE THE PYRO SERVER BEING DAEMONIZED MUST BE STARTED HERE
        # OTHERWISE ITS SOCKET FILE DESCRIPTORS WILL BE CLOSED DOWN IN
        # DAEMONIZER.__init__().

        # for debugging in daemon mode, uncomment the following so that
        # exceptions will be written to log files.

        #foo = open( "/home/oliverh/cylc/foo.txt", "a" )
        #server = None
        #try:
        server = LockServer(self.pns_host, self.logfile)
        #except Exception, x:
        #    foo.write( str(x) + "\n" )
        #else:
        #    pass

        #bar = open( "/home/oliverh/cylc/bar.txt", "a" )
        #try:
        server.start()
        #except Exception, x:
        #    bar.write( str(x) + "\n" )
        #else:
        #    pass


class LockServer:
    def __init__( self, pns_host, logfile ):
        # LOCATE THE PYRO NAMESERVER-------------------------------------------
        #self.nameserver = pyrex.discover( pns_host )
        try:
            self.nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
        except NamingError:
            raise SystemExit("Failed to find a Pyro nameserver on " + hostname )

        self.logfile = logfile

        # CREATE A UNIQUE NAMESERVER GROUPNAME FOR THE LOCK SERVER ------------
        self.groupname = 'cylc'
        #self.nameserver.create_groupname( self.groupname )
        try:
            self.nameserver.createGroup( self.groupname )
        except:
            self.nameserver.deleteGroup( self.groupname )
            self.nameserver.createGroup( self.groupname )

        Pyro.config.PYRO_MULTITHREADED = 0
        # USE DNS NAMES INSTEAD OF FIXED IP ADDRESSES FROM /etc/hosts
        # (see the Userguide "Networking Issues" section).
        Pyro.config.PYRO_DNS_URI = True
        Pyro.config.PYRO_STDLOGGING = True
        Pyro.config.PYRO_TRACELEVEL = 3
        Pyro.core.initServer()

    def start( self ):
        # CREATE A PYRO pyro_daemon FOR THIS SYSTEM
        # (single threaded prob not necessary for lockserver
        # but it doesn't matter as few connections needed)
        self.pyro_daemon = Pyro.core.Daemon()
        #pyro_daemon.useNameServer(self.nameserver.get_ns())
        self.pyro_daemon.useNameServer(self.nameserver)

        locker = lockserver( logfile )
        #pyro_daemon.connect( locker, self.nameserver.obj_name( 'lockserver', self.groupname ))
        self.pyro_daemon.connect( locker, 'cylc.lockserver' )

        while True:
            self.pyro_daemon.handleRequests()


if __name__ == "__main__":

    usage = """1/ cylc lock-server --start|restart|debug [options]
Usage: 2/ cylc lock-server --status|stop" 

Control the cylc lock server daemon. The lock server prevents multiple
instances of a system from running simultaneously (even under different
names) unless the system config file indicates this is permissible, and
it prevents multiple instances of the same task (at the same cycle time)
from running simultaneously. Unlike a traditional "lock file" the lock
server works for tasks that start and finish executing on different hosts.

The lockserver pid (process ID) file and log file can be specified under
the '[lockserver]' section of your .cylcrc file.""" 

    parser = OptionParser( usage )

    parser.set_defaults( pns_host= socket.getfqdn(), rcfile=None,
            start=False, debug=False, restart=False, status=False,
            stop=False )

    parser.add_option( "--host",
            help="(for --start|restart|debug). Pyro nameserver host, "
            "defaults to the local hostname. Use if not auto-detected "
            "(which depends on network config).", 
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "--start", help="Start up the server.",
            action="store_true", dest="start" )

    parser.add_option( "--debug", help="Do not daemonize the server, "
           "i.e. do not detach from the parent environment.",
            action="store_true", dest="debug" )

    parser.add_option( "--restart", help="Restart a running server.",
            action="store_true", dest="restart" )

    parser.add_option( "--status", help="Check that the server is running.",
            action="store_true", dest="status" )

    parser.add_option( "--stop", help="Shut down the server.",
            action="store_true", dest="stop" )

    parser.add_option( "--rcfile", help="Use an alternative cylc rc file "
            "(default $HOME/.cylcrc).", metavar="PATH", action="store",
            dest="rcfile" )

    ( options, args ) = parser.parse_args()

    count = 0
    for opt in [ options.start, options.restart, options.stop, options.status, options.debug ]:
        if opt:
            count += 1

    if count != 1:
        parser.error( "choose one option only!" )
    
    pns_host = options.pns_host
    config = cylcrc.rc( options.rcfile )
    logfile = config.get( 'lockserver', 'log file' )
    pidfile = config.get( 'lockserver', 'pid file' )

    server_daemon = ServerDaemon( pidfile, pns_host, logfile ) 

    argv = None
    if options.start:
        argv = 'start'
    elif options.stop:
        argv = 'stop'
    elif options.restart:
        argv = 'restart'
    elif options.status:
        argv = 'status'

    server_daemon.process_command_line([ sys.argv[0], argv ])
