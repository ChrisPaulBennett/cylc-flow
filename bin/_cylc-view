#!/usr/bin/env python

# example basictreeview.py

import threading
import gobject
import pygtk
pygtk.require('2.0')
import gtk
import time
from CylcOptionParsers import NoPromptOptionParser_u
from connector import connector
import pyrex
from cycle_time import _rt_to_dt, is_valid
import os, re, sys
import tail

# TO DO:
# 1/ see http://eccentric.cx/misc/pygtk/pygtkfaq.html#13.4
#    How do I get changes in my TreeModel to show up in my TreeView?

def get_col( state ):
    if state == 'waiting':
        return '#38a'
    elif state == 'submitted':
        return '#f83'
    elif state == 'running':
        return '#0a0'
    elif state == 'failed':
        return '#f00'
    else:
        return '#000'

def markup( col, string ):
    return '<span foreground="' + col + '">' + string + '</span>'

def compare_dict_of_dict( one, two ):
    for key in one:
        if key not in two:
            return False
        for subkey in one[ key ]:
            if subkey not in two[ key ]:
                return False
            if one[key][subkey] != two[key][subkey]:
                return False

    for key in two:
        if key not in one:
            return False
        for subkey in two[ key ]:
            if subkey not in one[ key ]:
                return False
            if two[key][subkey] != one[key][subkey]:
                return False

    return True

class LogThread(threading.Thread):
    def __init__( self, logview, log ):
        super( LogThread, self).__init__()
        self.logview = logview
        self.logbuffer = logview.get_buffer()
        self.logfile = log
        self.quit = False
        self.freeze = False

    def run( self ):
        #for line in tail.tail( open( self.logfile )):
        gen = tail.tail( open( self.logfile ))
        while not self.quit:
            if not self.freeze:
                line = gen.next()
                if line: 
                    gobject.idle_add( self.update_gui, line )
        #print "Disconnecting from log viewer thread"
 
    def update_gui( self, line ):
        self.logbuffer.insert( self.logbuffer.get_end_iter(), line )
        self.logview.scroll_to_iter( self.logbuffer.get_end_iter(), 0 )
        return False

class MyThread(threading.Thread):
    def __init__(self, led_liststore, fl_liststore, ttreestore,
            task_list, label_mode, label_status, label_time ):

        super(MyThread, self).__init__()

        self.state_summary = {}

        self.fl_liststore = fl_liststore
        self.ttreestore = ttreestore
        self.led_liststore = led_liststore
        self.task_list = task_list
        self.label_mode = label_mode
        self.label_status = label_status
        self.label_time = label_time

        try:
            self.god = connector( pns_host, groupname, 'state_summary' ).get()
        except Exception, x:
            print x
            raise

        self.quit = False

        self.waiting_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-waiting-glow.xpm" )
        self.submitted_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-submitted-glow.xpm" )
        self.running_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-running-glow.xpm" )
        self.failed_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-failed-glow.xpm" )
        self.finished_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-finished.xpm" )

        self.empty_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-empty.xpm" )

        self.led_digits_one = []
        self.led_digits_two = []
        for i in range(10):
            self.led_digits_one.append( gtk.gdk.pixbuf_new_from_file( imagedir + "/digits/one/digit-" + str(i) + ".xpm" ))
            self.led_digits_two.append( gtk.gdk.pixbuf_new_from_file( imagedir + "/digits/two/digit-" + str(i) + ".xpm" ))

        #self.cc = color_chooser()

    def connection_lost( self ):
        self.label_status.set_markup( "<b>CONNECTION LOST</b>" )
        self.label_status.get_parent().modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff0' ))
        # GTK IDLE FUNCTIONS MUST RETURN FALSE OR WILL BE CALLED 
        # MULTIPLE TIMES???????????????///
        return False


 
    def update_summary(self):
        #print "Updating Summary"
        try:
            [glbl, states] = self.god.get_state_summary()
        except Exception,x:
            self.led_liststore.clear()
            self.ttreestore.clear()
            self.fl_liststore.clear()
            gobject.idle_add( self.connection_lost )
 
            return False

        if compare_dict_of_dict( states, self.state_summary ):
            #print "STATE UNCHANGED"
            return False

        self.state_summary = states

        if glbl['stopping']:
            self.status = 'STOPPING'

        elif glbl['paused']:
            self.status = 'PAUSED'
       
        elif glbl['will_pause_at']:
            self.status = 'PAUSE ' + glbl[ 'will_pause_at' ]

        elif glbl['will_stop_at']:
            self.status = 'STOP ' + glbl[ 'will_stop_at' ]

        else:
            self.status = 'running'

        if glbl[ 'dummy_mode' ]:
            #rate = glbl[ 'dummy_clock_rate' ]
            #self.mode = 'DUMMY (' + str( rate ) + 's/hr)'
            self.mode = 'DUMMY'
        else:
            self.mode = 'REAL'

        dt = glbl[ 'last_updated' ]
        self.dt = dt.strftime( " %Y/%m/%d %H:%M:%S" ) 
        
        return True

    def search_level( self, model, iter, func, data ):
        while iter:
            if func( model, iter, data):
                return iter
            iter = model.iter_next(iter)
        return None

    def search_treemodel( self, model, iter, func, data ):
        while iter:
            if func( model, iter, data):
                return iter
            result = self.search_treemodel( model, model.iter_children(iter), func, data)
            if result:
                return result
            iter = model.iter_next(iter)
        return None

    def match_func( self, model, iter, data ):
        column, key = data
        value = model.get_value( iter, column )
        return value == key

    def digitize( self, ct ):
        led_ctime = []
        for i in range( 10 ):
            digit = int( ct[i:i+1] )
            if i in [0,1,2,3,6,7]:
                led_ctime.append( self.led_digits_one[ digit ] )  
            else:
                led_ctime.append( self.led_digits_two[ digit ] )  

        return led_ctime

    def update_gui( self ):
        #print "Updating GUI"

        new_data = {}
        for id in self.state_summary:
            state = self.state_summary[ id ][ 'state' ]
            message = self.state_summary[ id ][ 'latest_message' ]
            message = markup( get_col(state), message )
            state = markup( get_col(state), state )
            new_data[id] = [ state, message ]

        list_data = {}
        iter = self.fl_liststore.get_iter_first()
        while iter:
            row = []
            for col in range( self.fl_liststore.get_n_columns() ):
                row.append( self.fl_liststore.get_value( iter, col) )

            [ctime, name, state, message] = row
            id = name + '%' + ctime 
            list_data[ id ] = [ state, message ]

            if id not in new_data:
                # id no longer in system, remove from view
                #print "REMOVING", id
                result = self.fl_liststore.remove( iter )
                if not result:
                    iter = None

            elif new_data[ id ] != list_data[ id ]:
                #print "CHANGING", id
                # id still in system but data changed, so replace it
                self.fl_liststore.append( [ ctime, name ] + new_data[ id ] )
                result = self.fl_liststore.remove( iter )
                if not result:
                    iter = None

            else:
                # id still exists and data has not changed
                #print "UNCHANGED", id
                iter = self.fl_liststore.iter_next( iter )
            
        # add any new data    
        for id in new_data:
            name, ctime = id.split( '%' )
            if id not in list_data:
                #print "ADDING", id
                self.fl_liststore.append( [ ctime, name ] + new_data[ id ] )

        # EXPANDING TREE VIEW

        new_data = {}
        for id in self.state_summary:
            name, ctime = id.split( '%' )
            if ctime not in new_data:
                new_data[ ctime ] = {}
            state = self.state_summary[ id ][ 'state' ]
            message = self.state_summary[ id ][ 'latest_message' ]
            message = markup( get_col( state ), message )
            state = markup( get_col(state), state )
            new_data[ ctime ][ name ] = [ state, message ]

        # print existing tree:
        #print
        #iter = self.ttreestore.get_iter_first()
        #while iter:
        #    row = []
        #    for col in range( self.ttreestore.get_n_columns() ):
        #        row.append( self.ttreestore.get_value( iter, col ))
        #    print "==================", row
        #    iterch = self.ttreestore.iter_children( iter )
        #    while iterch:
        #        ch_row = []
        #        for col in range( self.ttreestore.get_n_columns() ):
        #            ch_row.append( self.ttreestore.get_value( iterch, col ))
        #        print "  ===========", ch_row
        #        iterch = self.ttreestore.iter_next( iterch )
        #    iter = self.ttreestore.iter_next( iter )
        #print

        tree_data = {}
        iter = self.ttreestore.get_iter_first()
        while iter:
            # get parent ctime 
            row = []
            for col in range( self.ttreestore.get_n_columns() ):
                row.append( self.ttreestore.get_value( iter, col) )
            [ ctime, state, message ] = row
            # state is empty string for parent row

            tree_data[ ctime ] = {}

            if ctime not in new_data:
                # parent ctime not in new data; remove it
                #print "REMOVING", ctime
                self.ttreestore.remove( iter )

            else:
                # parent ctime IS in new data; check children
                iterch = self.ttreestore.iter_children( iter )
                while iterch:
                    ch_row = []
                    for col in range( self.ttreestore.get_n_columns() ):
                        ch_row.append( self.ttreestore.get_value( iterch, col) )
                    [ name, state, message ] = ch_row
                    tree_data[ ctime ][name] = [ state, message ]

                    if name not in new_data[ ctime ]:
                        #print "  removing", name, "from", ctime
                        result = self.ttreestore.remove( iterch )
                        if not result:
                            # This indicates we removed the last 
                            # child, i.e. there is no next iterch.
                            # Remove leaves iterch at the old value,
                            # which has just become invalid.
                            iterch = None
                    elif tree_data[ctime][name] != new_data[ ctime ][name]:
                        #print "   changing", name, "at", ctime
                        self.ttreestore.append( iter, [ name ] + new_data[ctime][name] )
                        result = self.ttreestore.remove( iterch )
                        if not result:
                            # see above
                            iterch = None
                    else:
                        iterch = self.ttreestore.iter_next( iterch )

                # then increment parent ctime
                iter = self.ttreestore.iter_next( iter )

        for ctime in new_data:
            if ctime not in tree_data:
                # add new ctime tree
                #print "ADDING", ctime
                piter = self.ttreestore.append(None, [ctime, None, None ])
                for name in new_data[ ctime ]:
                    #print "  adding", name, "to", ctime
                    self.ttreestore.append( piter, [ name ] + new_data[ctime][name] )
                continue

            # this ctime tree is already in model
            p_iter = self.search_level( self.ttreestore, 
                    self.ttreestore.get_iter_first(),
                    self.match_func, (0, ctime ))

            for name in new_data[ ctime ]:
                # look for a matching row in the model
                ch_iter = self.search_treemodel( self.ttreestore, 
                        self.ttreestore.iter_children( p_iter ),
                        self.match_func, (0, name ))
                if not ch_iter:
                    #print "  adding", name, "to", ctime
                    self.ttreestore.append( p_iter, [ name ] + new_data[ctime][name] )
                    

        # LED VIEW
        self.led_liststore.clear()

        tasks = {}
        for id in self.state_summary:
            name, ctime = id.split( '%' )
            if ctime not in tasks:
                tasks[ ctime ] = [ name ]
            else:
                tasks[ ctime ].append( name )
 
        # flat (a liststore would do)
        ctimes = tasks.keys()
        ctimes.sort()

        for ctime in ctimes:
            tasks_at_ctime = tasks[ ctime ]
            state_list = [ ]

            for name in self.task_list:
                if name in tasks_at_ctime:
                    state = self.state_summary[ name + '%' + ctime ][ 'state' ] 
                    if state == 'waiting':
                        state_list.append( self.waiting_led )
                    elif state == 'submitted':
                        state_list.append( self.submitted_led )
                    elif state == 'running':
                        state_list.append( self.running_led )
                    elif state == 'finished':
                        state_list.append( self.finished_led )
                    elif state == 'failed':
                        state_list.append( self.failed_led )
                else:
                    state_list.append( self.empty_led )

            self.led_liststore.append( self.digitize( ctime ) + state_list )
            

        return False

    def run(self):
        glbl = None
        states = {}
        while not self.quit:
            if self.update_summary():
                gobject.idle_add( self.update_gui )
                gobject.idle_add( self.label_mode.set_text, self.mode )
                gobject.idle_add( self.label_status.set_text, self.status )
                gobject.idle_add( self.label_time.set_text, self.dt )
            time.sleep(1)
        else:
            pass
            #print "Disconnecting task state info thread"

class CylcView:

    # visibility determined by state matching active toggle buttons
    def visible_cb(self, model, iter, col ):
        # set visible if model value NOT in filter_states
        # TO DO: WHY IS STATE SOMETIMES NONE?
        state = model.get_value(iter, col) 
        #print '-->', model.get_value( iter, 0 ), model.get_value( iter, 1 ), state, model.get_value( iter, 3 )
        if state:
            p = re.compile( r'<.*?>')
            state = re.sub( r'<.*?>', '', state )

        return state not in self.filter_states

    def check_filter_buttons(self, tb):
        del self.filter_states[:]
        for b in self.filter_buttonbox.get_children():
            if not b.get_active():
                self.filter_states.append(b.get_label())

        self.modelfilter.refilter()
        return

    # close the window and quit
    def delete_event(self, widget, event, data=None):
        gtk.main_quit()
        self.lt.quit = True
        self.t.quit = True
        #print "BYE from main thread"
        return False

    def reset_logbuffer( self ):
        # clear log buffer iters and tags
        logbuffer = self.logview.get_buffer()
        s,e = logbuffer.get_bounds()
        logbuffer.remove_all_tags( s,e )
        self.find_current_iter = None
        self.find_current = None
 
    def replace_log( self, logfile ):
        self.logfile = logfile
        self.lt.quit = True
        logpath = self.logdir + '/' + self.logfile 
        logbuffer = self.logview.get_buffer()
        s,e = logbuffer.get_bounds()
        self.reset_logbuffer()
        logbuffer.delete( s, e )
        self.log_label.set_text( logpath ) 
        self.lt = LogThread( self.logview, logpath )
        #print "Starting log viewer thread"
        self.lt.start()

    def switch_log( self, cb ):
        model = cb.get_model()
        index = cb.get_active()
        if index == 0:
            return False

        task = model[index][0]
        self.replace_log( task )

        return False

    def rotate_log( self, bt, go_older ):
        cur_log = self.logfile
        m = re.match( '(.*)\.(\d)$', cur_log ) 
        if m:
            level = int( m.groups()[1] )
            log_base = m.groups()[0]
        else:
            level = 0
            log_base = cur_log

        warn = False

        if go_older:
            level += 1
        else:
            level -= 1

        if level < 0:
            self.warning_dialog( "The newest (active) log is already displayed" )
            return

        if level == 0:
            new_log = log_base
        else:
            new_log = log_base + '.' + str( level )

        if new_log not in os.listdir( self.logdir ):
            self.warning_dialog( "No older log available" )
            return

        self.replace_log( new_log )

    def warning_dialog( self, msg ):
        dialog = gtk.MessageDialog( None,
                gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_WARNING,
                gtk.BUTTONS_CLOSE, msg )
        dialog.run()
        dialog.destroy()

    def freeze_log( self, b ):
        # TO DO: HANDLE MORE STUFF IN THREADS LIKE THIS, RATHER THAN
        # PASSING IN ARGUMENTS?
        if b.get_active():
            self.lt.freeze = True
            b.set_label( 'UnFreeze' )
            self.reset_logbuffer()
        else:
            self.lt.freeze = False
            b.set_label( 'Freeze' )

        return False

    def about( self, bt ):
        about = gtk.AboutDialog()
        if gtk.gtk_version[1] >= 12:
            # set_program_name() was added in PyGTK 2.12
            about.set_program_name( "cylc" )
        about.set_version( cylc_version )
        about.set_copyright( "(c) Hilary Oliver, NIWA" )
        about.set_comments( 
"""
Cylc View is a real time system monitor for Cylc.
""" )
        about.set_website( "http://www.niwa.co.nz" )
        about.set_logo( gtk.gdk.pixbuf_new_from_file( imagedir + "/dew.jpg" ))
        about.run()
        about.destroy()

    def click_exit( self, foo ):
        gtk.main_quit()
        self.lt.quit = True
        self.t.quit = True
        #print "BYE from main thread"
        return False

    def expand_all( self, widget, view ):
        view.expand_all()
 
    def collapse_all( self, widget, view ):
        view.collapse_all()

    def led_heading_toggle( self, b ):
        if self.led_heading_type == 2:
            self.led_heading_type = 0
            # no headings
            headings = ['Cycle Time' ] + ['-'] * len( self.task_list )

        elif self.led_heading_type == 0:
            # short name headings
            self.led_heading_type = 1
            headings = ['Cycle Time' ] + self.task_list_shortnames

        elif self.led_heading_type == 1:
            # long name headings
            self.led_heading_type = 2
            headings = ['Cycle Time' ] + self.task_list

        tvcs = self.led_treeview.get_columns()
        for n in range( 1,1+len( self.task_list) ):
            heading = headings[n]
            # underscores treated as underlines markup?
            #heading = re.sub( '_', ' ', heading )
            tvcs[n].set_title( headings[n] )

    def on_find_clicked( self, tv, e ):
        needle = e.get_text ()
        if not needle:
            return

        self.lt.freeze = True
        self.freeze_button.set_active(True)
        self.freeze_button.set_label('UnFreeze')
        if not self.search_warning_done:
            self.warning_dialog( "Find Next detaches the live log feed; click UnFreeze when you're done" ) 
            self.search_warning_done = True

        tb = tv.get_buffer ()

        if needle == self.find_current:
            s = self.find_current_iter
        else:
            s,e = tb.get_bounds()
            tb.remove_all_tags( s,e )
            s = tb.get_end_iter ()
            tv.scroll_to_iter( s, 0 )
        try:
            f, l = s.backward_search (needle, gtk.TEXT_SEARCH_TEXT_ONLY) 
        except:
            self.warning_dialog( '"' + needle + '"' + " not found" )
        else:
            tag = tb.create_tag( None, background="#70FFA9" )
            tb.apply_tag( tag, f, l )
            self.find_current_iter = f
            self.find_current = needle
            tv.scroll_to_iter( f, 0 )

    def __init__(self):
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_title("cylc view <" + groupname + ">" )
        window.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( "#ddd" ))
        window.set_size_request(600, 500)
        window.connect("delete_event", self.delete_event)

        self.find_current = None
        self.find_current_iter = None
        self.search_warning_done = False

        # Get list of tasks in the system
        try:
            ss = connector( pns_host, groupname, 'state_summary' ).get()
        except Exception, x:
            print x
            raise

        self.task_list = ss.get_config( 'task_list' )
        shortnames = ss.get_config( 'task_list_shortnames' )

        temp = {}
        for t in range( len( self.task_list )):
            temp[ self.task_list[ t ] ] = shortnames[ t ]

        self.task_list.sort()
        self.task_list_shortnames = []
        for task in self.task_list:
            self.task_list_shortnames.append( temp[ task ] )
 
        # construct the LED display

        foo = tuple( [gtk.gdk.Pixbuf]* (10 + len( self.task_list)))
        led_liststore = gtk.ListStore( *foo )
        self.led_treeview = gtk.TreeView( led_liststore )
        ts = self.led_treeview.get_selection()
        ts.set_mode( gtk.SELECTION_NONE )

        tvc = gtk.TreeViewColumn( 'Cycle Time' )
        for i in range(10):
            cellpb = gtk.CellRendererPixbuf()
            cellpb.set_property( 'cell-background', 'black' )
            tvc.pack_start( cellpb, False )
            tvc.set_attributes( cellpb, pixbuf=i )

        self.led_treeview.append_column( tvc )

        # this doesn't show (brief flash of yellow at startup)
        # led_treeview.modify_base( gtk.STATE_NORMAL, gtk.gdk.color_parse( "yellow" ) )

        for n in range( 10, 10+len( self.task_list )):
            cell = gtk.CellRendererPixbuf()
            cell.set_property( 'cell_background', 'black' )
            cell.set_property( 'xalign', 0 )
            # replace heading underscores with spaces (they display as underline!)
            tvc = gtk.TreeViewColumn( "-"  )
            tvc.set_min_width( 20 )  # WIDTH OF LED PIXBUFS
            tvc.pack_end( cell, True )
            tvc.set_attributes( cell, pixbuf=n )
            self.led_treeview.append_column( tvc )

        # allow filtering out of 'finished' and 'waiting'
        all_states = [ 'waiting', 'submitted', 'running', 'finished', 'failed' ]
        # initially filter out only 'finished' tasks
        self.filter_states = [ 'finished' ]

        # LOWER DISPLAY

        # TAB ONE: Filtered List
        fl_liststore = gtk.ListStore(str, str, str, str)
        self.modelfilter = fl_liststore.filter_new()
        self.modelfilter.set_visible_func(self.visible_cb, 2)
        modelsort = gtk.TreeModelSort( self.modelfilter )
        modelsort.set_sort_column_id(0, gtk.SORT_ASCENDING)
        treeview = gtk.TreeView()
        treeview.set_model(modelsort)
        ts = treeview.get_selection()
        ts.set_mode( gtk.SELECTION_NONE )



        headings = ['cycle', 'name', 'state', 'latest message' ]
        bkgcols = ['#def', '#fff', '#fff', '#fff' ]

        # create the TreeViewColumn to display the data
        for n in range(len(headings)):
            # add columns to treeview
            cell = gtk.CellRendererText()
            cell.set_property( 'cell-background', bkgcols[ n] )
            tvc = gtk.TreeViewColumn( headings[n], cell, markup=n )
            #tvc = gtk.TreeViewColumn( headings[n], cell, text=n )
            treeview.append_column(tvc)
            tvc.set_sort_column_id(n)
            # add the cells to the columns
            #tvc.pack_start(cell, True)

            # set the cell attributes to the appropriate liststore column
            #treeview.columns[n].set_attributes( cell, text=n)

        # make it searchable
        treeview.set_search_column(1)

        user, name = groupname.split('^')

        label_status = gtk.Label( "status..." )
        label_mode = gtk.Label( "mode..." )
        label_time = gtk.Label( "time..." )
        label_sysname = gtk.Label( name )

        topbuttonbox = gtk.HButtonBox()
        quit_button = gtk.Button( "Quit" )
        quit_button.connect("clicked", self.click_exit )
        #tooltips = gtk.Tooltips()
        #tooltips.set_tip( quit_button, "Exit cylc view" )
        topbuttonbox.set_layout( gtk.BUTTONBOX_END )
        about_button = gtk.Button( "About" )
        about_button.connect("clicked", self.about )
        led_heading_button = gtk.Button( "Toggle Task Name Headings" )
        led_heading_button.connect("clicked", self.led_heading_toggle )
        self.led_heading_type = 0

        topbuttonbox.add( about_button )
        topbuttonbox.add( quit_button )
        hbox1 = gtk.HBox()
        hbox1.pack_start( led_heading_button, False )
        hbox1.pack_end( topbuttonbox, False )

        top_hbox = gtk.HBox()
        sysname_eb = gtk.EventBox()
        sysname_eb.add( label_sysname )
        sysname_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#d91212' ) ) 
        top_hbox.pack_start( sysname_eb, True )

        mode_eb = gtk.EventBox()
        mode_eb.add( label_mode )
        #label_mode.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#f00' ))  
        #mode_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#aaa' ) )
        mode_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff7800' ) )
        top_hbox.pack_start( mode_eb, True )

        status_eb = gtk.EventBox()
        status_eb.add( label_status )
        #elf.label_status.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff0' ))  
        #status_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#bbb' ) )
        status_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#dbd40a' ) )
        top_hbox.pack_start( status_eb, True )

        time_eb = gtk.EventBox()
        time_eb.add( label_time )
        #label_time.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#f0f' ))  
        #time_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ccc' ) )
        time_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#a7c339' ) )
        top_hbox.pack_start( time_eb, True )


        vpaned = gtk.VPaned()
        vpaned.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#d91212' ) )
  
        led_scrolledwindow = gtk.ScrolledWindow()
        led_scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        led_scrolledwindow.add( self.led_treeview )

        vpaned.add1( led_scrolledwindow )

        scrolledwindow = gtk.ScrolledWindow()
        scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

        self.filter_buttonbox = gtk.HButtonBox()

        vbox = gtk.VBox()
        vbox.pack_start( scrolledwindow, True )
        vbox.pack_start( self.filter_buttonbox, False )

        notebook = gtk.Notebook()
        notebook.set_tab_pos(gtk.POS_TOP)
 
        label = gtk.Label("Filtered List")
        notebook.append_page( vbox, label )

        # For reasons unknown, filter before sorting screws up the 
        # treeview display here, but the other way around works.
        ttreestore = gtk.TreeStore(str, str, str )
        tmodelsort = gtk.TreeModelSort( ttreestore )
        tmodelsort.set_sort_column_id(0, gtk.SORT_ASCENDING)
        ttreeview = gtk.TreeView()
        ttreeview.set_model(tmodelsort)
        ts = ttreeview.get_selection()
        ts.set_mode( gtk.SELECTION_NONE )

        headings = ['task', 'state', 'latest message' ]

        for n in range(len(headings)):
            cell = gtk.CellRendererText()
            tvc = gtk.TreeViewColumn( headings[n], cell, markup=n )
            #tvc = gtk.TreeViewColumn( headings[n], cell, text=n )
            ttreeview.append_column(tvc)
            tvc.set_sort_column_id(n)
 
        label = gtk.Label("Expanding Tree")

        cycle_tree_scrolledwindow = gtk.ScrolledWindow()
        cycle_tree_scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        cycle_tree_scrolledwindow.add( ttreeview )

        vbox = gtk.VBox()
        bbox = gtk.HButtonBox()
        expand_button = gtk.Button( "Expand" )
        expand_button.connect( 'clicked', self.expand_all, ttreeview )
    
        collapse_button = gtk.Button( "Collapse" )
        collapse_button.connect( 'clicked', self.collapse_all, ttreeview )

        bbox.add( expand_button )
        bbox.add( collapse_button )
        bbox.set_layout( gtk.BUTTONBOX_END )

        vbox.pack_start( cycle_tree_scrolledwindow )
        vbox.pack_start( bbox, False )

        notebook.append_page( vbox, label )

        for st in all_states:
            b = gtk.ToggleButton( st )
            self.filter_buttonbox.pack_start(b)
            if st in self.filter_states:
                b.set_active(False)
            else:
                b.set_active(True)
            b.connect('toggled', self.check_filter_buttons)

        self.filter_buttonbox.set_layout( gtk.BUTTONBOX_END )

        scrolledwindow.add( treeview )

        vpaned.add2( notebook )

        logscroll = gtk.ScrolledWindow()
        logscroll.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        self.logview = gtk.TextView()
        self.logview.modify_base( gtk.STATE_NORMAL, gtk.gdk.color_parse( "#fffaeb" ) )
        logscroll.add( self.logview )
        self.logview.set_editable( False )
        self.logdir = ss.get_config( 'logging_dir' ) 
        self.logfile = 'main'
        vbox = gtk.VBox()

        search_hbox = gtk.HBox()
        e = gtk.Entry ()
        search_hbox.pack_start (e, True)
        e.show () 
        b = gtk.Button ("Find Next")
        b.connect_object ('clicked', self.on_find_clicked, self.logview, e)
        search_hbox.pack_start (b, False)

        hbox = gtk.HBox()
        self.log_label = gtk.Label( self.logdir + '/' + self.logfile )
        self.log_label.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( "#f00" ))
        hbox.pack_start( self.log_label, True )

        self.freeze_button = gtk.ToggleButton( "Freeze" )
        self.freeze_button.set_active(False)
        self.freeze_button.connect("toggled", self.freeze_log )
        hbox.pack_end( self.freeze_button, False )

        combobox = gtk.combo_box_new_text()
        combobox.append_text( 'Select Log' ) 
        combobox.append_text( 'main' ) 
        for task in self.task_list:
            combobox.append_text( task )

        combobox.connect("changed", self.switch_log )
        combobox.set_active(0)

        previous = gtk.Button( "newer rotation" )
        previous.connect("clicked", self.rotate_log, False )
        hbox.pack_end( previous, False )

        previous = gtk.Button( "older rotation" )
        previous.connect("clicked", self.rotate_log, True )
        hbox.pack_end( previous, False )

        hbox.pack_end( combobox, False )
 
        vbox.pack_start( logscroll, True )
        vbox.pack_start( search_hbox, False )
        vbox.pack_start( hbox, False )

        notebook.append_page( vbox, gtk.Label("Log Viewer") )

        bigbox = gtk.VBox()
        bigbox.pack_start( hbox1, False )
        bigbox.pack_start( top_hbox, False )
        bigbox.pack_start( vpaned, True )
        #bigbox.pack_end( hbox, False )
        window.add( bigbox )

        window.show_all()

        self.t = MyThread( led_liststore, fl_liststore,
                ttreestore, self.task_list, label_mode, label_status, label_time )

        self.lt = LogThread( self.logview, self.logdir + '/' + self.logfile )
        #print "Starting task state info thread"
        self.t.start()
        #print "Starting log viewer thread"
        self.lt.start()

if __name__ == "__main__":
    parser = NoPromptOptionParser_u( """cylc view [options] SYSTEM 

A monitor that displays the state of all tasks in a running system. 

THIS PROGRAM MONITORS TASK PROXY OBJECTS INSIDE THE SCHEDULER, NOT
EXTERNAL SYSTEM TASKS (how to do that obviously depends on the job
submission method used by each task).""")

    ( options, args ) = parser.parse_args()

    system_name = parser.get_system_name()
    pns_host = parser.get_pns_host()
    groupname = parser.get_groupname()

    # get systems currently registered in the Pyro nameserver
    #ns_groups = pyrex.discover( pns_host )

    if not pyrex.discover(pns_host).registered( groupname ):
        print "No " + groupname + " group registered with Pyro yet, waiting ..." 
        while True:
            time.sleep(1)
            if pyrex.discover( pns_host ).registered( groupname ):
                break

    imagedir = os.environ[ 'CYLC_DIR' ] + '/images'
    cylc_version = "X.Y.Z"

    gobject.threads_init()
    tvexample = CylcView()
    gtk.main()

