#!/usr/bin/env python

# example basictreeview.py

import threading
import gobject
import pygtk
pygtk.require('2.0')
import gtk
import time
from CylcOptionParsers import NoPromptOptionParser_u
from connector import connector
import pyrex
from cycle_time import _rt_to_dt, is_valid
import os, re, sys

# TO DO:
# 1/ see http://eccentric.cx/misc/pygtk/pygtkfaq.html#13.4
#    How do I get changes in my TreeModel to show up in my TreeView?


class color_chooser:
    cols = [ '#f38', '#2a3', '#83f' ]
    def __init__( self ):
        self.index = 0

    def get_color( self ):
        if self.index >= len( color_chooser.cols ):
            self.index = 0

        res = color_chooser.cols[ self.index ]
        self.index += 1
        return res

def compare_dict_of_dict( one, two ):
    for key in one:
        if key not in two:
            return False
        for subkey in one[ key ]:
            if subkey not in two[ key ]:
                return False
            if one[key][subkey] != two[key][subkey]:
                return False

    for key in two:
        if key not in one:
            return False
        for subkey in two[ key ]:
            if subkey not in one[ key ]:
                return False
            if two[key][subkey] != one[key][subkey]:
                return False

    return True

class MyThread(threading.Thread):
    def __init__(self, ctime_liststore, led_liststore, fl_liststore, ttreestore,
            task_list, label_mode, label_status, label_time ):

        super(MyThread, self).__init__()

        self.state_summary = {}

        self.fl_liststore = fl_liststore
        self.ttreestore = ttreestore
        self.led_liststore = led_liststore
        self.ctime_liststore = ctime_liststore
        self.task_list = task_list
        self.label_mode = label_mode
        self.label_status = label_status
        self.label_time = label_time

        try:
            self.god = connector( pns_host, groupname, 'state_summary' ).get()
        except Exception, x:
            print x
            raise

        self.quit = False

        self.waiting_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-waiting-glow.xpm" )
        self.submitted_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-submitted-glow.xpm" )
        self.running_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-running-glow.xpm" )
        self.failed_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-failed-glow.xpm" )
        self.finished_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-finished.xpm" )
        self.empty_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-empty.xpm" )

        self.cc = color_chooser()

    def update_summary(self):
        #print "Updating Summary"
        try:
            [glbl, states] = self.god.get_state_summary()
        except Exception,x:
            print x
            return False

        if compare_dict_of_dict( states, self.state_summary ):
            #print "STATE UNCHANGED"
            return False

        self.state_summary = states

        if glbl['stopping']:
            self.status = 'STOPPING'

        elif glbl['paused']:
            self.status = 'PAUSED'
       
        elif glbl['will_pause_at']:
            self.status = 'PAUSE ' + glbl[ 'will_pause_at' ]

        elif glbl['will_stop_at']:
            self.status = 'STOP ' + glbl[ 'will_stop_at' ]

        else:
            self.status = 'running'

        if glbl[ 'dummy_mode' ]:
            #rate = glbl[ 'dummy_clock_rate' ]
            #self.mode = 'DUMMY (' + str( rate ) + 's/hr)'
            self.mode = 'DUMMY'
        else:
            self.mode = 'REAL'

        dt = glbl[ 'last_updated' ]
        self.dt = dt.strftime( " %Y/%m/%d %H:%M:%S" ) 
        
        return True

    def search_level( self, model, iter, func, data ):
        while iter:
            if func( model, iter, data):
                return iter
            iter = model.iter_next(iter)
        return None

    def search_treemodel( self, model, iter, func, data ):
        while iter:
            if func( model, iter, data):
                return iter
            result = self.search_treemodel( model, model.iter_children(iter), func, data)
            if result:
                return result
            iter = model.iter_next(iter)
        return None

    def match_func( self, model, iter, data ):
        column, key = data
        value = model.get_value( iter, column )
        return value == key

    def update_gui( self ):
        #print "Updating GUI"

        new_data = {}
        for id in self.state_summary:
            state = self.state_summary[ id ][ 'state' ]
            #if state == 'running':
            #    state = '<span foreground="#0a0"><b>running</b></span>'
            #elif state == 'waiting':
            #    state = '<span foreground="#38a">waiting</span>'
            #elif state == 'submitted':
            #    state = '<span foreground="#000"><b>submitted</b></span>'
            #elif state == 'failed':
            #    state = '<span foreground="#f00"><b>failed</b></span>'
            message = self.state_summary[ id ][ 'latest_message' ]
            #message = '<span foreground="' + self.cc.get_color() + '">' + message + '</span>'
            #message = '<span foreground="#000">' + message + '</span>'

            new_data[id] = [ state, message ]

        list_data = {}
        iter = self.fl_liststore.get_iter_first()
        while iter:
            row = []
            for col in range( self.fl_liststore.get_n_columns() ):
                row.append( self.fl_liststore.get_value( iter, col) )

            [ctime, name, state, message] = row
            id = name + '%' + ctime 
            list_data[ id ] = [ state, message ]

            if id not in new_data:
                # id no longer in system, remove from view
                #print "REMOVING", id
                self.fl_liststore.remove( iter )

            elif new_data[ id ] != list_data[ id ]:
                #print "CHANGING", id
                # id still in system but data changed, so replace it
                self.fl_liststore.append( [ ctime, name ] + new_data[ id ] )
                self.fl_liststore.remove( iter )

            else:
                # id still exists and data has not changed
                #print "UNCHANGED", id
                iter = self.fl_liststore.iter_next( iter )
            
        # add any new data    
        for id in new_data:
            name, ctime = id.split( '%' )
            if id not in list_data:
                #print "ADDING", id
                self.fl_liststore.append( [ ctime, name ] + new_data[ id ] )

        # EXPANDING TREE VIEW

        new_data = {}
        for id in self.state_summary:
            name, ctime = id.split( '%' )
            if ctime not in new_data:
                new_data[ ctime ] = {}
            state = self.state_summary[ id ][ 'state' ]
            message = self.state_summary[ id ][ 'latest_message' ]
            new_data[ ctime ][ name ] = [ state, message ]

        # print existing tree:
        #print
        #iter = self.ttreestore.get_iter_first()
        #while iter:
        #    row = []
        #    for col in range( self.ttreestore.get_n_columns() ):
        #        row.append( self.ttreestore.get_value( iter, col ))
        #    print "==================", row
        #    iterch = self.ttreestore.iter_children( iter )
        #    while iterch:
        #        ch_row = []
        #        for col in range( self.ttreestore.get_n_columns() ):
        #            ch_row.append( self.ttreestore.get_value( iterch, col ))
        #        print "  ===========", ch_row
        #        iterch = self.ttreestore.iter_next( iterch )
        #    iter = self.ttreestore.iter_next( iter )
        #print

        tree_data = {}
        iter = self.ttreestore.get_iter_first()
        while iter:
            # get parent ctime 
            row = []
            for col in range( self.ttreestore.get_n_columns() ):
                row.append( self.ttreestore.get_value( iter, col) )
            [ ctime, state, message ] = row
            # state is empty string for parent row

            tree_data[ ctime ] = {}

            if ctime not in new_data:
                # parent ctime not in new data; remove it
                #print "REMOVING", ctime
                self.ttreestore.remove( iter )

            else:
                # parent ctime IS in new data; check children
                iterch = self.ttreestore.iter_children( iter )
                while iterch:
                    ch_row = []
                    for col in range( self.ttreestore.get_n_columns() ):
                        ch_row.append( self.ttreestore.get_value( iterch, col) )
                    [ name, state, message ] = ch_row
                    tree_data[ ctime ][name] = [ state, message ]

                    if name not in new_data[ ctime ]:
                        #print "  removing", name, "from", ctime
                        result = self.ttreestore.remove( iterch )
                        if not result:
                            # This indicates we removed the last 
                            # child, i.e. there is no next iterch.
                            # Remove leaves iterch at the old value,
                            # which has just become invalid.
                            iterch = None
                    elif tree_data[ctime][name] != new_data[ ctime ][name]:
                        #print "   changing", name, "at", ctime
                        self.ttreestore.append( iter, [ name ] + new_data[ctime][name] )
                        result = self.ttreestore.remove( iterch )
                        if not result:
                            # see above
                            iterch = None
                    else:
                        iterch = self.ttreestore.iter_next( iterch )

                # then increment parent ctime
                iter = self.ttreestore.iter_next( iter )

        for ctime in new_data:
            if ctime not in tree_data:
                # add new ctime tree
                #print "ADDING", ctime
                piter = self.ttreestore.append(None, [ctime, None, None ])
                for name in new_data[ ctime ]:
                    #print "  adding", name, "to", ctime
                    self.ttreestore.append( piter, [ name ] + new_data[ctime][name] )
                continue

            # this ctime tree is already in model
            p_iter = self.search_level( self.ttreestore, 
                    self.ttreestore.get_iter_first(),
                    self.match_func, (0, ctime ))

            for name in new_data[ ctime ]:
                # look for a matching row in the model
                ch_iter = self.search_treemodel( self.ttreestore, 
                        self.ttreestore.iter_children( p_iter ),
                        self.match_func, (0, name ))
                if not ch_iter:
                    #print "  adding", name, "to", ctime
                    self.ttreestore.append( p_iter, [ name ] + new_data[ctime][name] )
                    

        # LED VIEW
        self.led_liststore.clear()
        self.ctime_liststore.clear()

        tasks = {}
        for id in self.state_summary:
            name, ctime = id.split( '%' )
            if ctime not in tasks:
                tasks[ ctime ] = [ name ]
            else:
                tasks[ ctime ].append( name )
 
        # flat (a liststore would do)
        ctimes = tasks.keys()
        ctimes.sort()

        for ctime in ctimes:
            tasks_at_ctime = tasks[ ctime ]
            state_list = [ ]

            for name in self.task_list:
                if name in tasks_at_ctime:
                    state = self.state_summary[ name + '%' + ctime ][ 'state' ] 
                    if state == 'waiting':
                        state_list.append( self.waiting_led )
                    elif state == 'submitted':
                        state_list.append( self.submitted_led )
                    elif state == 'running':
                        state_list.append( self.running_led )
                    elif state == 'finished':
                        state_list.append( self.finished_led )
                    elif state == 'failed':
                        state_list.append( self.failed_led )
                else:
                    state_list.append( self.empty_led )

            self.led_liststore.append( state_list )
            self.ctime_liststore.append( [ self.empty_led, 
                '<span color="#5af"><b>' + ctime + '</b></span>'] )

        return False

    def run(self):
        glbl = None
        states = {}
        while not self.quit:
            if self.update_summary():
                gobject.idle_add( self.update_gui )
                gobject.idle_add( self.label_mode.set_text, self.mode )
                gobject.idle_add( self.label_status.set_text, self.status )
                gobject.idle_add( self.label_time.set_text, self.dt )
            time.sleep(1)
        else:
            print "BYE"

class CylcView:

    # visibility determined by state matching active toggle buttons
    def visible_cb(self, model, iter, col ):

        # set visible if model value NOT in filter_states
        # TO DO: WHY IS STATE SOMETIMES NONE?
        state = model.get_value(iter, col) 

        #if state:
        #    p = re.compile( r'<.*?>')
        #    state = re.sub( r'<.*?>', '', state )

        return state not in self.filter_states

    def check_filter_buttons(self, tb):
        del self.filter_states[:]
        for b in self.filter_buttonbox.get_children():
            if not b.get_active():
                self.filter_states.append(b.get_label())

        self.modelfilter.refilter()
        self.tfilter.refilter()
        return

    # close the window and quit
    def delete_event(self, widget, event, data=None):
        gtk.main_quit()
        self.t.quit = True
        return False

    def click_exit( self, foo ):
        gtk.main_quit()
        self.t.quit = True
        return False

    def expand_all( self, widget, view ):
        view.expand_all()
 
    def collapse_all( self, widget, view ):
        view.collapse_all()

    def __init__(self):
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_title("cylc view <" + groupname + ">" )
        window.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( "#ddd" ))
        window.set_size_request(500, 400)
        window.connect("delete_event", self.delete_event)

        # Get list of tasks in the system
        try:
            ss = connector( pns_host, groupname, 'state_summary' ).get()
        except Exception, x:
            print x
            raise

        task_name_heading = {}
        task_list = ss.get_config( 'task_list' )
        if not longnames:
            task_list_shortnames = ss.get_config( 'task_list_shortnames' )

        for t in range( len( task_list )):
            if not longnames:
                task_name_heading[ task_list[ t ] ] = task_list_shortnames[ t ]
            else:
                task_name_heading[ task_list[ t ] ] = task_list[ t ]
        
        task_list.sort()

        # construct the LED display

        ctime_liststore = gtk.ListStore( gtk.gdk.Pixbuf, str )
        ctime_treeview = gtk.TreeView( ctime_liststore )
        tvc = gtk.TreeViewColumn( 'cycle' )
        
        cellpb = gtk.CellRendererPixbuf()
        cellpb.set_property( 'cell-background', 'black' )
        tvc.pack_start( cellpb, False )
        tvc.set_attributes( cellpb, pixbuf=0  )

        cell = gtk.CellRendererText()
        cell.set_property( 'cell-background', 'black' )
        tvc.pack_start( cell, True )
        tvc.set_attributes( cell, markup=1 )
        #tvc.set_attributes( cell, text=1 )

        ctime_treeview.append_column( tvc )

        foo = tuple( [gtk.gdk.Pixbuf]*len( task_list ) )
        led_liststore = gtk.ListStore( *foo )
        led_treeview = gtk.TreeView( led_liststore )

        # this doesn't show (brief flash of yellow at startup)
        #led_treeview.modify_base( gtk.STATE_NORMAL, gtk.gdk.color_parse( "yellow" ) )

        for n in range( len( task_list )):
            cell = gtk.CellRendererPixbuf()
            cell.set_property( 'cell_background', 'black' )
            cell.set_property( 'xalign', 0 )
	    # replace heading underscores with spaces (they display as underline!)
	    heading = task_name_heading[ task_list[n]]
	    heading = re.sub( '_', ' ', heading )
            tvc = gtk.TreeViewColumn( heading  )
            tvc.set_min_width( 30 )  # WIDTH OF LED PIXBUFS
            tvc.pack_end( cell, True )
            tvc.set_attributes( cell, pixbuf=n )
            led_treeview.append_column( tvc )

        # allow filtering out of 'finished' and 'waiting'
        all_states = [ 'waiting', 'submitted', 'running', 'finished', 'failed' ]
        # initially filter out 'waiting' and 'finished' tasks
        self.filter_states = [ 'waiting', 'finished' ]


        # LOWER DISPLAY

        # TAB ONE: Filtered List
        fl_liststore = gtk.ListStore(str, str, str, str)
        self.modelfilter = fl_liststore.filter_new()
        treeview = gtk.TreeView()
        self.modelfilter.set_visible_func(self.visible_cb, 2)
        modelsort = gtk.TreeModelSort( self.modelfilter )
        modelsort.set_sort_column_id(0, gtk.SORT_ASCENDING)
        treeview.set_model(modelsort)

        headings = ['cycle', 'name', 'state', 'latest message' ]
        bkgcols = ['#def', '#fff', '#fff', '#fff' ]

        # create the TreeViewColumn to display the data
        for n in range(len(headings)):
            # add columns to treeview
            cell = gtk.CellRendererText()
            cell.set_property( 'cell-background', bkgcols[ n] )
            #tvc = gtk.TreeViewColumn( headings[n], cell, markup=n )
            tvc = gtk.TreeViewColumn( headings[n], cell, text=n )
            treeview.append_column(tvc)
            tvc.set_sort_column_id(n)
            # add the cells to the columns
            #tvc.pack_start(cell, True)

            # set the cell attributes to the appropriate liststore column
            #treeview.columns[n].set_attributes( cell, text=n)

        # make it searchable
        treeview.set_search_column(1)

        user, name = groupname.split('^')

        label_status = gtk.Label( "status..." )
        label_mode = gtk.Label( "mode..." )
        label_time = gtk.Label( "time..." )
        label_sysname = gtk.Label( name )

        quit_button = gtk.Button( "Quit" )
        quit_button.connect("clicked", self.click_exit )
        tooltips = gtk.Tooltips()
        tooltips.set_tip( quit_button, "Exit cylc view" )

        top_hbox = gtk.HBox()
        sysname_eb = gtk.EventBox()
        sysname_eb.add( label_sysname )
        sysname_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#d91212' ) ) 
        top_hbox.pack_start( sysname_eb, True )

        mode_eb = gtk.EventBox()
        mode_eb.add( label_mode )
        #label_mode.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#f00' ))  
        #mode_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#aaa' ) )
        mode_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff7800' ) )
        top_hbox.pack_start( mode_eb, True )

        status_eb = gtk.EventBox()
        status_eb.add( label_status )
        #elf.label_status.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff0' ))  
        #status_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#bbb' ) )
        status_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#dbd40a' ) )
        top_hbox.pack_start( status_eb, True )

        time_eb = gtk.EventBox()
        time_eb.add( label_time )
        #label_time.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#f0f' ))  
        #time_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ccc' ) )
        time_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#a7c339' ) )
        top_hbox.pack_start( time_eb, True )


        vpaned = gtk.VPaned()

        led_hbox = gtk.HBox()

        led_hbox.pack_start( ctime_treeview, False )
        led_hbox.pack_start( led_treeview, True )

        led_scrolledwindow = gtk.ScrolledWindow()
        led_scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        led_scrolledwindow.add_with_viewport( led_hbox )

        vpaned.add1( led_scrolledwindow )

        scrolledwindow = gtk.ScrolledWindow()
        scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

        self.filter_buttonbox = gtk.HButtonBox()

        notebook = gtk.Notebook()
        notebook.set_tab_pos(gtk.POS_TOP)
 
        label = gtk.Label("Sortable List")
        notebook.append_page( scrolledwindow, label )

        # For reasons unknown, filter before sorting screws up the 
        # treeview display here, but the other way around works.
        ttreestore = gtk.TreeStore(str, str, str )
        ttreeview = gtk.TreeView()
        tmodelsort = gtk.TreeModelSort( ttreestore )
        tmodelsort.set_sort_column_id(0, gtk.SORT_ASCENDING)
        self.tfilter = tmodelsort.filter_new()
        self.tfilter.set_visible_func(self.visible_cb, 1 )
        ttreeview.set_model(self.tfilter)

        headings = ['task', 'state', 'latest message' ]

        for n in range(len(headings)):
            cell = gtk.CellRendererText()
            #tvc = gtk.TreeViewColumn( headings[n], cell, markup=n )
            tvc = gtk.TreeViewColumn( headings[n], cell, text=n )
            ttreeview.append_column(tvc)
            tvc.set_sort_column_id(n)
 
        label = gtk.Label("Expandable Tree")

        cycle_tree_scrolledwindow = gtk.ScrolledWindow()
        cycle_tree_scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        cycle_tree_scrolledwindow.add( ttreeview )

        vbox = gtk.VBox()
        bbox = gtk.HButtonBox()
        expand_button = gtk.Button( "Expand" )
        expand_button.connect( 'clicked', self.expand_all, ttreeview )
    
        collapse_button = gtk.Button( "Collapse" )
        collapse_button.connect( 'clicked', self.collapse_all, ttreeview )

        bbox.add( expand_button )
        bbox.add( collapse_button )
        bbox.set_layout( gtk.BUTTONBOX_END )

        vbox.pack_start( cycle_tree_scrolledwindow )
        vbox.pack_start( bbox, False )

        notebook.append_page( vbox, label )

        for st in all_states:
            b = gtk.ToggleButton( st )
            self.filter_buttonbox.pack_start(b)
            if st in self.filter_states:
                b.set_active(False)
            else:
                b.set_active(True)
            b.connect('toggled', self.check_filter_buttons)

        hbox = gtk.HBox()
        hbox.pack_start( quit_button, False )

        hbox.pack_start( self.filter_buttonbox, True )

        self.filter_buttonbox.set_layout( gtk.BUTTONBOX_END )

        scrolledwindow.add( treeview )

        vpaned.add2( notebook )

        bigbox = gtk.VBox()
        bigbox.pack_start( top_hbox, False )
        bigbox.pack_start( vpaned, True )
        bigbox.pack_end( hbox, False )
        window.add( bigbox )

        window.show_all()

        self.t = MyThread( ctime_liststore, led_liststore, fl_liststore,
                ttreestore, task_list, label_mode, label_status, label_time )

        self.t.start()

if __name__ == "__main__":
    parser = NoPromptOptionParser_u( """cylc view [options] SYSTEM 

A monitor that displays the state of all tasks in a running system. 

THIS PROGRAM MONITORS TASK PROXY OBJECTS INSIDE THE SCHEDULER, NOT
EXTERNAL SYSTEM TASKS (how to do that obviously depends on the job
submission method used by each task).""")

    parser.add_option( "--longnames", help="Display full task names. The default "
        "is to display short tasknames, if defined, to save screen space.",
        action="store_true", default=False, dest="longnames" )

    ( options, args ) = parser.parse_args()

    system_name = parser.get_system_name()
    pns_host = parser.get_pns_host()
    groupname = parser.get_groupname()
    longnames = options.longnames

    # get systems currently registered in the Pyro nameserver
    #ns_groups = pyrex.discover( pns_host )

    if not pyrex.discover(pns_host).registered( groupname ):
        print "No " + groupname + " group registered with Pyro yet, waiting ..." 
        while True:
            time.sleep(1)
            if pyrex.discover( pns_host ).registered( groupname ):
                break

    imagedir = os.environ[ 'CYLC_DIR' ] + '/images'

    gobject.threads_init()
    tvexample = CylcView()
    gtk.main()

