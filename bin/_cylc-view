#!/usr/bin/env python

# example basictreeview.py

from stateview import updater
from logviewer import logviewer
from cylc_logviewer import cylc_logviewer


import gobject
import gtk
import pygtk
pygtk.require('2.0')
import time, os, re, sys
from CylcOptionParsers import NoPromptOptionParser_u
from connector import connector
import pyrex
from cycle_time import _rt_to_dt, is_valid


class CylcView:

    # visibility determined by state matching active toggle buttons
    def visible_cb(self, model, iter, col ):
        # set visible if model value NOT in filter_states
        # TO DO: WHY IS STATE SOMETIMES NONE?
        state = model.get_value(iter, col) 
        #print '-->', model.get_value( iter, 0 ), model.get_value( iter, 1 ), state, model.get_value( iter, 3 )
        if state:
            p = re.compile( r'<.*?>')
            state = re.sub( r'<.*?>', '', state )

        return state not in self.filter_states

    def check_filter_buttons(self, tb):
        del self.filter_states[:]
        for b in self.filter_buttonbox.get_children():
            if not b.get_active():
                self.filter_states.append(b.get_label())

        self.modelfilter.refilter()
        return

    # close the window and quit
    def delete_event(self, widget, event, data=None):
        gtk.main_quit()
        self.lvp.quit()
        self.t.quit = True
        #print "BYE from main thread"
        return False

    def warning_dialog( self, msg ):
        dialog = gtk.MessageDialog( None,
                gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_WARNING,
                gtk.BUTTONS_CLOSE, msg )
        dialog.run()
        dialog.destroy()

    def about( self, bt ):
        about = gtk.AboutDialog()
        if gtk.gtk_version[1] >= 12:
            # set_program_name() was added in PyGTK 2.12
            about.set_program_name( "cylc" )
        about.set_version( cylc_version )
        about.set_copyright( "(c) Hilary Oliver, NIWA" )
        about.set_comments( 
"""
Cylc View is a real time system monitor for Cylc.
""" )
        about.set_website( "http://www.niwa.co.nz" )
        about.set_logo( gtk.gdk.pixbuf_new_from_file( imagedir + "/dew.jpg" ))
        about.run()
        about.destroy()

    def click_exit( self, foo ):
        gtk.main_quit()
        #self.lt.quit = True
        self.lvp.quit()
        self.t.quit = True
        #print "BYE from main thread"
        return False

    def expand_all( self, widget, view ):
        view.expand_all()
 
    def collapse_all( self, widget, view ):
        view.collapse_all()

    def led_heading_toggle( self, b ):
        if self.led_heading_type == 2:
            self.led_heading_type = 0
            # no headings
            headings = ['Cycle Time' ] + ['-'] * len( self.task_list )

        elif self.led_heading_type == 0:
            # short name headings
            self.led_heading_type = 1
            headings = ['Cycle Time' ] + self.task_list_shortnames

        elif self.led_heading_type == 1:
            # long name headings
            self.led_heading_type = 2
            headings = ['Cycle Time' ] + self.task_list

        tvcs = self.led_treeview.get_columns()
        for n in range( 1,1+len( self.task_list) ):
            heading = headings[n]
            # underscores treated as underlines markup?
            #heading = re.sub( '_', ' ', heading )
            tvcs[n].set_title( headings[n] )

    def create_led_panel( self ):
        types = tuple( [gtk.gdk.Pixbuf]* (10 + len( self.task_list)))
        liststore = gtk.ListStore( *types )
        treeview = gtk.TreeView( liststore )
        treeview.get_selection().set_mode( gtk.SELECTION_NONE )

        tvc = gtk.TreeViewColumn( 'Cycle Time' )
        for i in range(10):
            cr = gtk.CellRendererPixbuf()
            cr.set_property( 'cell-background', 'black' )
            tvc.pack_start( cr, False )
            tvc.set_attributes( cr, pixbuf=i )
        treeview.append_column( tvc )

        for n in range( 10, 10+len( self.task_list )):
            cr = gtk.CellRendererPixbuf()
            cr.set_property( 'cell_background', 'black' )
            cr.set_property( 'xalign', 0 )
            tvc = gtk.TreeViewColumn( "-"  )
            tvc.set_min_width( 20 )  # WIDTH OF LED PIXBUFS
            tvc.pack_end( cr, True )
            tvc.set_attributes( cr, pixbuf=n )
            treeview.append_column( tvc )

        sw = gtk.ScrolledWindow()
        sw.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

        self.led_treeview = treeview
        sw.add( treeview )

        return sw

    def create_tree_panel( self ):
        self.ttreestore = gtk.TreeStore(str, str, str )
        tms = gtk.TreeModelSort( self.ttreestore )
        tms.set_sort_column_id(0, gtk.SORT_ASCENDING)
        treeview = gtk.TreeView()
        treeview.set_model(tms)
        treeview.get_selection().set_mode( gtk.SELECTION_NONE )

        headings = ['task', 'state', 'latest message' ]
        for n in range(len(headings)):
            cr = gtk.CellRendererText()
            tvc = gtk.TreeViewColumn( headings[n], cr, markup=n )
            #tvc = gtk.TreeViewColumn( headings[n], cr, text=n )
            treeview.append_column(tvc)
            tvc.set_sort_column_id(n)
 
        sw = gtk.ScrolledWindow()
        sw.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        sw.add( treeview )

        vbox = gtk.VBox()
        bbox = gtk.HButtonBox()
        expand_button = gtk.Button( "Expand" )
        expand_button.connect( 'clicked', self.expand_all, treeview )
    
        collapse_button = gtk.Button( "Collapse" )
        collapse_button.connect( 'clicked', self.collapse_all, treeview )

        bbox.add( expand_button )
        bbox.add( collapse_button )
        bbox.set_layout( gtk.BUTTONBOX_END )

        vbox.pack_start( sw )
        vbox.pack_start( bbox, False )

        return vbox

    def create_flatlist_panel( self ):
        self.fl_liststore = gtk.ListStore(str, str, str, str)
        self.modelfilter = self.fl_liststore.filter_new()
        self.modelfilter.set_visible_func(self.visible_cb, 2)
        tms = gtk.TreeModelSort( self.modelfilter )
        tms.set_sort_column_id(0, gtk.SORT_ASCENDING)
        treeview = gtk.TreeView()
        treeview.set_model(tms)
        treeview.get_selection().set_mode( gtk.SELECTION_NONE )

        headings = ['cycle', 'name', 'state', 'latest message' ]
        bkgcols = ['#def', '#fff', '#fff', '#fff' ]

        # create the TreeViewColumn to display the data
        for n in range(len(headings)):
            # add columns to treeview
            cr = gtk.CellRendererText()
            cr.set_property( 'cell-background', bkgcols[ n] )
            tvc = gtk.TreeViewColumn( headings[n], cr, markup=n )
            #tvc = gtk.TreeViewColumn( headings[n], cr, text=n )
            tvc.set_sort_column_id(n)
            treeview.append_column(tvc)

        treeview.set_search_column(1)

        sw = gtk.ScrolledWindow()
        sw.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        sw.add( treeview )

        self.filter_buttonbox = gtk.HButtonBox()

        # allow filtering out of 'finished' and 'waiting'
        all_states = [ 'waiting', 'submitted', 'running', 'finished', 'failed' ]
        # initially filter out only 'finished' tasks
        self.filter_states = [ 'finished' ]

        for st in all_states:
            b = gtk.ToggleButton( st )
            self.filter_buttonbox.pack_start(b)
            if st in self.filter_states:
                b.set_active(False)
            else:
                b.set_active(True)
            b.connect('toggled', self.check_filter_buttons)

        self.filter_buttonbox.set_layout( gtk.BUTTONBOX_END )

        vbox = gtk.VBox()
        vbox.pack_start( sw, True )
        vbox.pack_start( self.filter_buttonbox, False )

        return vbox

    def logview_destroy( self, w, e, jt ):
        jt.quit = True
        
    def test_logview( self, b ):
        a_logfile = '/home/oliverh/cylc/A-munge.log'
        window = gtk.Window()
        window.set_title("log view" )
        window.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( "#ddd" ))
        window.set_size_request(600, 300)
        window.add( self.create_task_logview() )
        jt = tailer( gobject, self.jlogview, a_logfile )
        jt.quit = False
        window.connect("delete_event", self.logview_destroy, jt )
        window.show_all()
        #print "Starting job log viewer thread"
        jt.start()

    def create_top_buttonbox( self ):
        bb = gtk.HButtonBox()
        bb.set_layout( gtk.BUTTONBOX_END )

        quit_button = gtk.Button( "Quit" )
        quit_button.connect("clicked", self.click_exit )
        #tooltips = gtk.Tooltips()
        #tooltips.set_tip( quit_button, "Exit cylc view" )

        about_button = gtk.Button( "About" )
        about_button.connect("clicked", self.about )

        heading_button = gtk.Button( "Toggle Task Name Headings" )
        heading_button.connect("clicked", self.led_heading_toggle )
        self.led_heading_type = 0

        test_button = gtk.Button( "Test" )
        test_button.connect("clicked", self.test_logview )
        bb.add( test_button )

        bb.add( about_button )
        bb.add( quit_button )

        hb = gtk.HBox()
        hb.pack_start( heading_button, False )
        hb.pack_end( bb, False )
        return hb


    def create_info_bar( self ):
        user, name = groupname.split('^')

        self.label_status = gtk.Label( "status..." )
        self.label_mode = gtk.Label( "mode..." )
        self.label_time = gtk.Label( "time..." )
        self.label_sysname = gtk.Label( name )

        hbox = gtk.HBox()

        eb = gtk.EventBox()
        eb.add( self.label_sysname )
        eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#d91212' ) ) 
        hbox.pack_start( eb, True )

        eb = gtk.EventBox()
        eb.add( self.label_mode )
        eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff7800' ) )
        hbox.pack_start( eb, True )

        eb = gtk.EventBox()
        eb.add( self.label_status )
        eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#dbd40a' ) )
        hbox.pack_start( eb, True )

        eb = gtk.EventBox()
        eb.add( self.label_time )
        eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#a7c339' ) )
        hbox.pack_start( eb, True )

        return hbox


    def translate_task_names( self, shortnames ):
        temp = {}
        for t in range( len( self.task_list )):
            temp[ self.task_list[ t ] ] = shortnames[ t ]

        self.task_list.sort()
        self.task_list_shortnames = []
        for task in self.task_list:
            self.task_list_shortnames.append( temp[ task ] )
 

    def __init__(self):
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_title("cylc view <" + groupname + ">" )
        window.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( "#ddd" ))
        window.set_size_request(600, 500)
        window.connect("delete_event", self.delete_event)

        # Get list of tasks in the system
        try:
            ss = connector( pns_host, groupname, 'state_summary' ).get()
        except Exception, x:
            print x
            raise

        self.logdir = ss.get_config( 'logging_dir' ) 
        self.logfile = 'main'

        self.task_list = ss.get_config( 'task_list' )
        shortnames = ss.get_config( 'task_list_shortnames' )

        self.translate_task_names( shortnames )

        notebook = gtk.Notebook()
        notebook.set_tab_pos(gtk.POS_TOP)
        notebook.append_page( self.create_flatlist_panel(), gtk.Label("List") )
        notebook.append_page( self.create_tree_panel(), gtk.Label("Tree") )

        main_panes = gtk.VPaned()
        main_panes.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#d91212' ))
        main_panes.add1( self.create_led_panel())
        main_panes.add2( notebook )

        cylc_log = self.logdir + '/' + self.logfile 
        self.lvp = cylc_logviewer( 'main', self.logdir, self.logfile, self.task_list )
        notebook.append_page( self.lvp.get_widget(), gtk.Label("Cylc Logs"))

        bigbox = gtk.VBox()
        bigbox.pack_start( self.create_top_buttonbox(), False )
        bigbox.pack_start( self.create_info_bar(), False )
        bigbox.pack_start( main_panes, True )
        window.add( bigbox )

        window.show_all()

        self.t = updater( gobject, ss, imagedir, 
                self.led_treeview.get_model(), 
                self.fl_liststore,
                self.ttreestore, 
                self.task_list, 
                self.label_mode, self.label_status, self.label_time )

        #print "Starting task state info thread"
        self.t.start()

if __name__ == "__main__":
    parser = NoPromptOptionParser_u( """cylc view [options] SYSTEM 

A monitor that displays the state of all tasks in a running system. 

THIS PROGRAM MONITORS TASK PROXY OBJECTS INSIDE THE SCHEDULER, NOT
EXTERNAL SYSTEM TASKS (how to do that obviously depends on the job
submission method used by each task).""")

    ( options, args ) = parser.parse_args()

    system_name = parser.get_system_name()
    pns_host = parser.get_pns_host()
    groupname = parser.get_groupname()

    # get systems currently registered in the Pyro nameserver
    #ns_groups = pyrex.discover( pns_host )

    if not pyrex.discover(pns_host).registered( groupname ):
        print "No " + groupname + " group registered with Pyro yet, waiting ..." 
        while True:
            time.sleep(1)
            if pyrex.discover( pns_host ).registered( groupname ):
                break

    imagedir = os.environ[ 'CYLC_DIR' ] + '/images'
    cylc_version = "X.Y.Z"

    gobject.threads_init()
    tvexample = CylcView()
    gtk.main()

