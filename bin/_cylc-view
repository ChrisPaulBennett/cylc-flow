#!/usr/bin/env python

# example basictreeview.py

import threading
import gobject
import pygtk
pygtk.require('2.0')
import gtk
import time
from CylcOptionParsers import NoPromptOptionParser_u
from connector import connector
import pyrex
from cycle_time import _rt_to_dt, is_valid
import os, re, sys

# TO DO:
# 1/ see http://eccentric.cx/misc/pygtk/pygtkfaq.html#13.4
#    How do I get changes in my TreeModel to show up in my TreeView?


class color_chooser:
    cols = [ '#f38', '#2a3', '#83f' ]
    def __init__( self ):
        self.index = 0

    def get_color( self ):
        if self.index >= len( color_chooser.cols ):
            self.index = 0

        res = color_chooser.cols[ self.index ]
        self.index += 1
        return res

def compare_dicts( one, two ):
    for key,value in two.iteritems():
        try:
            if one[ key ] == value:
                return True
            else:
                return False
        except KeyError:
            return False

class MyThread(threading.Thread):
    def __init__(self, ctime_liststore, led_liststore, treestore, task_list, 
            label_mode, label_status, label_time ):

        super(MyThread, self).__init__()

        self.state_summary = {}

        self.treestore = treestore
        self.led_liststore = led_liststore
        self.ctime_liststore = ctime_liststore
        self.task_list = task_list
        self.label_mode = label_mode
        self.label_status = label_status
        self.label_time = label_time


        try:
            self.god = connector( pns_host, groupname, 'state_summary' ).get()
        except Exception, x:
            print x
            raise

        self.quit = False

        self.waiting_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-waiting-glow.xpm" )
        self.submitted_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-submitted-glow.xpm" )
        self.running_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-running-glow.xpm" )
        self.failed_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-failed-glow.xpm" )
        self.finished_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-finished.xpm" )
        self.empty_led = gtk.gdk.pixbuf_new_from_file( imagedir + "/led-empty.xpm" )

        self.cc = color_chooser()

    def update_summary(self):
        #print "Updating Summary"
        try:
            [glbl, states] = self.god.get_state_summary()
        except Exception,x:
            print x
            return False

        # TO DO: FOR NOW UPDATE GUI EVERY TIME

        #if not compare_dicts( states, self.state_summary ):

        self.state_summary = states

        if glbl['stopping']:
            self.status = 'STOPPING'

        elif glbl['paused']:
            self.status = 'PAUSED'
       
        elif glbl['will_pause_at']:
            self.status = 'PAUSE ' + glbl[ 'will_pause_at' ]

        elif glbl['will_stop_at']:
            self.status = 'STOP ' + glbl[ 'will_stop_at' ]

        else:
            self.status = 'running'


        if glbl[ 'dummy_mode' ]:
            #rate = glbl[ 'dummy_clock_rate' ]
            #self.mode = 'DUMMY (' + str( rate ) + 's/hr)'
            self.mode = 'DUMMY'
        else:
            self.mode = 'REAL'

        dt = glbl[ 'last_updated' ]
        self.dt = dt.strftime( " %Y/%m/%d %H:%M:%S" ) 
        
        return True

    def update_gui( self ):
        #print "Updating View"
        self.treestore.clear()

        # flat (a liststore would do)
        for id in self.state_summary:
            name, ctime = id.split( '%' )
            name = '<b>' + name + '</b>'
            state = self.state_summary[ id ][ 'state' ]
            if state == 'running':
                state = '<span foreground="#0a0"><b>running</b></span>'
            elif state == 'waiting':
                state = '<span foreground="#38a">waiting</span>'
            elif state == 'submitted':
                state = '<span foreground="#000"><b>submitted</b></span>'
            elif state == 'failed':
                state = '<span foreground="#f00"><b>failed</b></span>'

            message = self.state_summary[ id ][ 'latest_message' ]
            #message = '<span foreground="' + self.cc.get_color() + '">' + message + '</span>'
            message = '<span foreground="#000">' + message + '</span>'
            self.treestore.append( None, [ ctime, name, state, message ])
        
        self.led_liststore.clear()
        self.ctime_liststore.clear()

        tasks = {}
        for id in self.state_summary:
            name, ctime = id.split( '%' )
            if ctime not in tasks:
                tasks[ ctime ] = [ name ]
            else:
                tasks[ ctime ].append( name )
 
        # flat (a liststore would do)
        ctimes = tasks.keys()
        ctimes.sort()

        for ctime in ctimes:
            tasks_at_ctime = tasks[ ctime ]
            state_list = [ ]

            for name in self.task_list:
                if name in tasks_at_ctime:
                    state = self.state_summary[ name + '%' + ctime ][ 'state' ] 
                    if state == 'waiting':
                        state_list.append( self.waiting_led )
                    elif state == 'submitted':
                        state_list.append( self.submitted_led )
                    elif state == 'running':
                        state_list.append( self.running_led )
                    elif state == 'finished':
                        state_list.append( self.finished_led )
                    elif state == 'failed':
                        state_list.append( self.failed_led )
                else:
                    state_list.append( self.empty_led )

            self.led_liststore.append( state_list )
            self.ctime_liststore.append( [ self.empty_led, 
                '<span color="#5af"><b>' + ctime + '</b></span>'] )

        return False

        # expanding treeview
        #members = {}
        #for id in self.state_summary:
        #   name, ctime = id.split( '%' )
        #   if ctime not in members:
        #       members[ ctime ] = [ id ]
        #   else:
        #        members[ ctime ].append( id )
        #
        #for ctime in members:
        #    piter = self.treestore.append(None, [ctime, 'foo','running','bar'])
        #    for id in members[ ctime ]:
        #        name, junk = id.split( '%' )
        #        state = self.state_summary[ id ][ 'state' ]
        #        message = self.state_summary[ id ][ 'latest_message' ]
        #        self.treestore.append( piter, [ ctime, name, state, message ])
        #
        #return False

    def run(self):
        glbl = None
        states = {}
        while not self.quit:
            if self.update_summary():
                gobject.idle_add( self.update_gui )
                gobject.idle_add( self.label_mode.set_text, self.mode )
                gobject.idle_add( self.label_status.set_text, self.status )
                gobject.idle_add( self.label_time.set_text, self.dt )
            time.sleep(1)
        else:
            print "BYE"

class CylcView:

    # visibility determined by state matching active toggle buttons
    def visible_cb(self, model, iter, data):
        # set visible if model value NOT in filter_states

        # TO DO: WHY IS STATE SOMETIMES NONE?
        state = model.get_value(iter, 2) 
        if state:
            p = re.compile( r'<.*?>')
            state = re.sub( r'<.*?>', '', state )

        return state not in data

    def check_buttons(self, tb):
        del self.filter_states[:]
        for b in self.bbox.get_children():
            if not b.get_active():
                self.filter_states.append(b.get_label())
        self.modelfilter.refilter()
        return

    # close the window and quit
    def delete_event(self, widget, event, data=None):
        gtk.main_quit()
        self.t.quit = True
        return False

    def click_exit( self, foo ):
        gtk.main_quit()
        self.t.quit = True
        return False


    def __init__(self):
        # Create a new window
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( "#ddd" ))

        self.window.set_title("cylc view <" + groupname + ">" )

        self.window.set_size_request(500, 400)

        self.window.connect("delete_event", self.delete_event)

        # LED MONITOR
        try:
            ss = connector( pns_host, groupname, 'state_summary' ).get()
        except Exception, x:
            print x

        self.task_list = ss.get_config( 'task_list' )
        self.task_list.sort()

        self.ctime_liststore = gtk.ListStore( gtk.gdk.Pixbuf, str )
        self.ctime_treeview = gtk.TreeView( self.ctime_liststore )
        tvc = gtk.TreeViewColumn( 'cycle' )
        
        cellpb = gtk.CellRendererPixbuf()
        cellpb.set_property( 'cell-background', 'black' )
        tvc.pack_start( cellpb, False )
        tvc.set_attributes( cellpb, pixbuf=0  )

        cell = gtk.CellRendererText()
        cell.set_property( 'cell-background', 'black' )
        tvc.pack_start( cell, True )
        tvc.set_attributes( cell, markup=1 )

        self.ctime_treeview.append_column( tvc )

        foo = tuple( [gtk.gdk.Pixbuf]*len( self.task_list ) )
        self.led_liststore = gtk.ListStore( *foo )
        self.led_treeview = gtk.TreeView( self.led_liststore )

        # this doesn't show (brief flash of yellow at startup)
        #self.led_treeview.modify_base( gtk.STATE_NORMAL, gtk.gdk.color_parse( "yellow" ) )

        for n in range( len( self.task_list )):
            cell = gtk.CellRendererPixbuf()
            cell.set_property( 'cell_background', 'black' )
            cell.set_property( 'xalign', 0 )
            tvc = gtk.TreeViewColumn( self.task_list[n] )
            tvc.set_min_width( 30 )  # WIDTH OF LED PIXBUFS
            tvc.pack_end( cell, True )
            #tvc.pack_end( cell, False )
            tvc.set_attributes( cell, pixbuf=n )
            self.led_treeview.append_column( tvc )
       

        # allow filtering out of 'finished' and 'waiting'
        self.all_states = [ 'waiting', 'submitted', 'running', 'finished', 'failed' ]
        # initially filter out only 'finished' tasks
        self.filter_states = [ 'finished' ]


        # create a liststore with one string column to use as the model
        self.treestore = gtk.TreeStore(str, str, str, str)
        self.modelfilter = self.treestore.filter_new()

        self.treeview = gtk.TreeView()

        self.modelfilter.set_visible_func(self.visible_cb, self.filter_states)

        self.modelsort = gtk.TreeModelSort( self.modelfilter )
        self.modelsort.set_sort_column_id(0, gtk.SORT_ASCENDING)
        self.treeview.set_model(self.modelsort)

        headings = ['cycle', 'name', 'state', 'latest message' ]
        bkgcols = ['#def', '#fff', '#fff', '#fff' ]

        # create the TreeViewColumn to display the data
        for n in range(4):
            # add columns to treeview
            cell = gtk.CellRendererText()
            cell.set_property( 'cell-background', bkgcols[ n] )
            tvc = gtk.TreeViewColumn( headings[n], cell, markup=n )
            self.treeview.append_column(tvc)
            tvc.set_sort_column_id(n)
            # add the cells to the columns
            #tvc.pack_start(cell, True)

            # set the cell attributes to the appropriate liststore column
            #self.treeview.columns[n].set_attributes( cell, text=n)

        # make it searchable
        self.treeview.set_search_column(1)

        # Allow sorting on the column
        # Allow drag and drop reordering of rows
        #self.treeview.expand_all()

        user, name = groupname.split('^')

        self.top_hbox = gtk.HBox()
        self.label_sysname = gtk.Label( name )
        self.label_status = gtk.Label( "status..." )
        self.label_mode = gtk.Label( "mode..." )
        self.label_time = gtk.Label( "time..." )
        self.quit_button = gtk.Button( "Quit" )
        self.quit_button.connect("clicked", self.click_exit )

        self.tooltips = gtk.Tooltips()
        self.tooltips.set_tip( self.quit_button, "Exit cylc view" )

        self.sysname_eb = gtk.EventBox()
        self.sysname_eb.add( self.label_sysname )
        self.sysname_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff0' ) ) # f41 orange
        self.top_hbox.pack_start( self.sysname_eb, True )

        self.mode_eb = gtk.EventBox()
        self.mode_eb.add( self.label_mode )
        #self.label_mode.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#f00' ))  
        self.mode_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#aaa' ) )
        self.top_hbox.pack_start( self.mode_eb, True )

        self.status_eb = gtk.EventBox()
        self.status_eb.add( self.label_status )
        #elf.label_status.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ff0' ))  
        self.status_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#bbb' ) )
        self.top_hbox.pack_start( self.status_eb, True )

        self.time_eb = gtk.EventBox()
        self.time_eb.add( self.label_time )
        #self.label_time.modify_fg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#f0f' ))  
        self.time_eb.modify_bg( gtk.STATE_NORMAL, gtk.gdk.color_parse( '#ccc' ) )
        self.top_hbox.pack_start( self.time_eb, True )

        self.top_hbox.pack_start( self.quit_button, True )
 
        self.vpaned = gtk.VPaned()

        self.led_hbox = gtk.HBox()

        self.led_hbox.pack_start( self.ctime_treeview, False )
        self.led_hbox.pack_start( self.led_treeview, True )

        self.led_scrolledwindow = gtk.ScrolledWindow()
        self.led_scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )
        self.led_scrolledwindow.add_with_viewport( self.led_hbox )

        self.vpaned.add1( self.led_scrolledwindow )

        self.hbox = gtk.HBox()

        self.scrolledwindow = gtk.ScrolledWindow()
        self.scrolledwindow.set_policy( gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC )

        self.vbox = gtk.VBox()

        self.bbox = gtk.HButtonBox()

        self.label = gtk.Label('Task Filters:')

        self.hbox.pack_start( self.label, True )
        self.hbox.pack_start( self.bbox, False )

        self.vbox.pack_start(self.scrolledwindow)
        self.vbox.pack_start(self.hbox, False)
        # create toggle buttons to select filtering based on
        # bug state and set buttons active

        for st in self.all_states:
            b = gtk.ToggleButton( st )
            self.bbox.pack_start(b)
            if st == 'finished':
                b.set_active(False)
            else:
                b.set_active(True)
            b.connect('toggled', self.check_buttons)

        self.scrolledwindow.add( self.treeview )

        self.vpaned.add2( self.vbox )

        self.bigbox = gtk.VBox()
        self.bigbox.pack_start( self.top_hbox, False )
        self.bigbox.pack_end( self.vpaned, True )
        self.window.add( self.bigbox )

        #self.window.pack_start( self.top_hbox, False )
        #self.window.add( self.vpaned, True )


        #self.window.add(self.vbox)

        self.window.show_all()

        self.t = MyThread( self.ctime_liststore, 
                self.led_liststore, self.treestore, 
                self.task_list, self.label_mode, 
                self.label_status, self.label_time )
        self.t.start()

if __name__ == "__main__":
    parser = NoPromptOptionParser_u( """cylc view [options] SYSTEM 

A monitor that displays the state of all tasks in a running system. 

THIS PROGRAM MONITORS TASK PROXY OBJECTS INSIDE THE SCHEDULER, NOT
EXTERNAL SYSTEM TASKS (how to do that obviously depends on the job
submission method used by each task).""")

#parser.add_option( "--shortnames", help="Display short task names, if defined.",
#        action="store_true", default=False, dest="shortnames" )

    ( options, args ) = parser.parse_args()

    system_name = parser.get_system_name()
    pns_host = parser.get_pns_host()
    groupname = parser.get_groupname()

    # get systems currently registered in the Pyro nameserver
    #ns_groups = pyrex.discover( pns_host )

    if not pyrex.discover(pns_host).registered( groupname ):
        print "No " + groupname + " group registered with Pyro yet, waiting ..." 
        while True:
            time.sleep(1)
            if pyrex.discover( pns_host ).registered( groupname ):
                break

    imagedir = os.environ[ 'CYLC_DIR' ] + '/images'

    gobject.threads_init()
    tvexample = CylcView()
    gtk.main()

