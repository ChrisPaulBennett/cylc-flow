#!/usr/bin/env python

import re, os, sys, socket, logging
from time import sleep
from optparse import OptionParser
from OrderedDict import OrderedDict
from config import config
from mkdir_p import mkdir_p
from registration import getdb, regsplit, RegistrationError
from execute import execute
from job_submit import job_submit
import cycle_time, pimp_my_logger
from suite_lock import suite_lock
from lockserver import lockserver
import task, clocktriggered
import accelerated_clock 

usage = """cylc [task] submit|single [options] SUITE TASK_ID

Submit a single task to run exactly as it would be run from within its 
parent suite. This can be used as an easy way to run single tasks
for any reason, but it is particularly useful during suite development.

If the parent suite is running at the same time and it has acquired an
exclusive suite lock (which means you cannot running multiple instances
of the suite at once under different registrations) then the lockserver
will let you 'submit' a task from the suite only under the same
registration, and only if the exact same task (NAME%CYCLE_TIME) is not
running at the same time in the suite. 

arguments:
   SUITE           Registered name of the target suite.
   TASK_ID         Identity of the task to run (NAME%YYYYMMDDHH).""" 


def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( sched=False, dry_run=False )

    parser.add_option( "-d", "--dry-run",
            help="Generate the cylc task execution file for the "
            "task and report how it would be submitted to run.",
            action="store_true", dest="dry_run" )

    parser.add_option( "--scheduler",
            help="(EXPERIMENTAL) tell the task to run as a scheduler task, "
            "i.e. to attempt to communicate with a task proxy in a running "
            "cylc suite (you probably do not want to do this).",
            action="store_true", dest="sched" )

    return parser

# parse commandline options and arguments-----------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) != 2:
    parser.error( "suite name and task ID required." )

# get input args------------------------------------------------------
suite = args[0]
task_id = args[1]

host = socket.getfqdn()

# find location of the suite definition directory --------------------
reg = getdb(suite)
reg.load_from_file()
try:
    suite_dir,descr = reg.get( suite )
except RegistrationError,x:
    raise SystemExit(x)

# provide access to the suite bin directory
os.environ[ 'PATH' ] += ':' + suite_dir + '/bin'

# check task ---------------------------------------------------------
try:
    ( task_name, ctime ) = task_id.split( '%' )
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH" )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

owner = os.environ['USER']

# load suite config item --------------------------------------------
config = config( suite )
config.create_directories()
# modify logging dir for single task submit so as not to alter suite logs
logging_dir = os.path.join( config['top level logging directory'], suite + '-submit' ) 
mkdir_p( logging_dir )

use_lockserver = False
if config[ 'use lockserver' ]:
    use_lockserver = True
    lockserver_port = lockserver( host ).ping()

    # Request suite access from the lock server. If the task's parent
    # suite has an exclusive lock, we can use submit only via the
    # same suite registration. submit does not need to call
    # release_suite_access()
    if not suite_lock( suite, suite_dir, host, lockserver_port, 'submit' ).request_suite_access():
        raise SystemExit( 'ERROR: failed to acquire a suite lock' )

# CYLC EXECUTION ENVIRONMENT
cylcenv = OrderedDict()
if options.sched:
    cylcenv[ 'CYLC_MODE' ] = 'scheduler'
else:
    cylcenv[ 'CYLC_MODE' ] = 'submit'
cylcenv[ 'CYLC_SUITE_HOST' ] = host
cylcenv[ 'CYLC_SUITE_PORT' ] = 'NONE'
cylcenv[ 'CYLC_DIR' ] = os.environ[ 'CYLC_DIR' ]
cylcenv[ 'CYLC_SUITE_DIR' ] = suite_dir
cylcenv[ 'CYLC_SUITE' ] = suite
suite_owner, suite_group, suite_name = regsplit( suite ).get()
cylcenv[ 'CYLC_SUITE_GROUP' ] = suite_group
cylcenv[ 'CYLC_SUITE_NAME' ] = suite_name
cylcenv[ 'CYLC_SUITE_OWNER' ] = owner
cylcenv[ 'CYLC_USE_LOCKSERVER' ] = str( use_lockserver )

dclock = accelerated_clock.clock( None, None, False ) 
# nasty kludge to give the dummy mode clock to task classes:
task.task.clock = dclock
clocktriggered.clocktriggered.clock = dclock

# USER DEFINED GLOBAL ENVIRONMENT
globalenv = OrderedDict()
for var in config['environment']:
    globalenv[ var ] = config['environment'][var]

# create the log
log = logging.getLogger()
pimp_my_logger.pimp_it( log, logging_dir, \
        config['roll scheduler log at startup'], \
        logging.INFO, False, None, True )

job_submit.cylc_env = cylcenv
job_submit.global_env = globalenv
job_submit.shell = config['job submission shell'] 
job_submit.joblog_dir = config['job submission log directory']

# intantiate the task--------------------------------------------------
try:
    task_proxy = config.get_task_proxy( task_name, ctime, 'waiting', startup=True )
except KeyError, x:
    raise SystemExit( 'task not found: ' + task_name )

#print '\nPREREQUISITES:\n'
#for item in task_proxy.prerequisites.dump():
#    print item
#print '\nOUTPUTS:\n'
#for item in task_proxy.outputs.dump():
#    print item

# SUBMIT THE TASK TO RUN-----------------------------------------------
if options.dry_run:
    print "DRY RUN: create task execution script, show how it would be submitted."
else:
    print "Logging directory: " + logging_dir
    print
task_proxy.run_external_task( dry_run=options.dry_run )
print
