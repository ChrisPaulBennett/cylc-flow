#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


import re, os, sys, datetime, socket, logging
from time import sleep
from optparse import OptionParser
from OrderedDict import OrderedDict
from config import config

from registration import registrations
from execute import execute
from job_submit import job_submit
import cycle_time, pimp_my_logger
from cylcrc import preferences
from suite_lock import suite_lock
from lockserver import lockserver

usage = """cylc submit [options] SUITE TASK_ID

Submit a single task to run just as the scheduler would submit it. This
can be used as an easy way to invoke single tasks for any reason, but it
is particularly useful during suite development.

arguments:
   SUITE           Registered name of the target suite.
   TASK_ID         Identity of the task to run (NAME%YYYYMMDDHH).""" 


def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( sched=False, dry_run=False )

    parser.add_option( "-d", "--dry-run",
            help="Generate the cylc task execution file for the "
            "task and report how it would be submitted to run.",
            action="store_true", dest="dry_run" )

    parser.add_option( "--scheduler",
            help="(EXPERIMENTAL) tell the task to run as a scheduler task, "
            "i.e. to attempt to communicate with a task proxy in a running "
            "cylc suite (you probably do not want to do this).",
            action="store_true", dest="sched" )

    return parser

# parse commandline options and arguments-----------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) != 2:
    parser.error( "suite name and task ID required." )

# get input args------------------------------------------------------
name = args[0]
task_id = args[1]

host = socket.getfqdn()

# find location of the suite-specific modules------------------------
reg = registrations()
if reg.is_registered( name ):
    suite_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "suite " + name + " is not registered!" )

# provide access to the suite bin directory
os.environ[ 'PATH' ] += ':' + suite_dir + '/bin'

# check task ----------------------------------------------------------
try:
    ( task_name, ctime ) = task_id.split( '%' )
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH" )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

owner = os.environ['USER']

# load cylcrc file----------------------------------------------------
prefs = preferences()
logging_dir = os.path.join( prefs['logging directory'], name + '-submit' ) 

use_lockserver = False
if prefs[ 'use lockserver' ]:
    use_lockserver = True
    lockserver_port = lockserver( owner, host ).ping()

    # request suite access from the lock server
    # submit does not need to call release_suite_access()
    if not suite_lock( name, suite_dir, owner, host, lockserver_port, 'submit' ).request_suite_access():
        raise SystemExit( 'ERROR: failed to acquire a suite lock' )

# initial global environment ----------------------------------------
globalenv = OrderedDict()
if options.sched:
    globalenv[ 'CYLC_MODE' ] = 'scheduler'
else:
    globalenv[ 'CYLC_MODE' ] = 'submit'
globalenv[ 'CYLC_SUITE_HOST' ] = host
globalenv[ 'CYLC_SUITE_PORT' ] = 'NONE'
globalenv[ 'CYLC_DIR' ] = os.environ[ 'CYLC_DIR' ]
globalenv[ 'CYLC_SUITE_DIR' ] = suite_dir
globalenv[ 'CYLC_SUITE_NAME' ] = name
globalenv[ 'CYLC_SUITE_OWNER' ] = owner
globalenv[ 'CYLC_USE_LOCKSERVER' ] = str( use_lockserver )

# load suite configuration--------------------------------------------
config = config( os.path.join( suite_dir, 'suite.rc' ))
logging_lvl = config['logging level']

for var in config['environment']:
    globalenv[ var ] = config['environment'][var]

# create the log
log = logging.getLogger()
pimp_my_logger.pimp_it( log, logging_dir, logging_lvl, False, None, True )

job_submit.global_env = globalenv
job_submit.joblog_dir = config['job submission log directory']

# intantiate the task--------------------------------------------------
task_proxy = config.get_task_proxy( task_name, ctime, 'waiting', startup=True )

print '\nPREREQUISITES:\n'
for item in task_proxy.prerequisites.dump():
    print item
print '\nOUTPUTS:\n'
for item in task_proxy.outputs.dump():
    print item


# SUBMIT THE TASK TO RUN-----------------------------------------------
print
if not options.dry_run:
    print "Logging directory: " + logging_dir
    print
task_proxy.run_external_task( options.dry_run )
print
