#!/usr/bin/env python

import re, os, sys, socket, logging
from time import sleep
from optparse import OptionParser
from OrderedDict import OrderedDict
from config import config
from mkdir_p import mkdir_p
from registration import registrations
from execute import execute
from job_submit import job_submit
import cycle_time, pimp_my_logger
from suite_lock import suite_lock
from lockserver import lockserver

usage = """cylc submit [options] SUITE TASK_ID

Submit a single task to run just as the scheduler would submit it. This
can be used as an easy way to invoke single tasks for any reason, but it
is particularly useful during suite development.

arguments:
   SUITE           Registered name of the target suite.
   TASK_ID         Identity of the task to run (NAME%YYYYMMDDHH).""" 


def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( sched=False, dry_run=False )

    parser.add_option( "-d", "--dry-run",
            help="Generate the cylc task execution file for the "
            "task and report how it would be submitted to run.",
            action="store_true", dest="dry_run" )

    parser.add_option( "--scheduler",
            help="(EXPERIMENTAL) tell the task to run as a scheduler task, "
            "i.e. to attempt to communicate with a task proxy in a running "
            "cylc suite (you probably do not want to do this).",
            action="store_true", dest="sched" )

    return parser

# parse commandline options and arguments-----------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) != 2:
    parser.error( "suite name and task ID required." )

# get input args------------------------------------------------------
name = args[0]
task_id = args[1]

host = socket.getfqdn()

# find location of the suite-specific modules------------------------
reg = registrations()
if reg.is_registered( name ):
    suite_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "suite " + name + " is not registered!" )

# provide access to the suite bin directory
os.environ[ 'PATH' ] += ':' + suite_dir + '/bin'

# check task ---------------------------------------------------------
try:
    ( task_name, ctime ) = task_id.split( '%' )
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH" )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

owner = os.environ['USER']

# load suite config item --------------------------------------------
config = config( name )
config.create_directories()

logging_dir = os.path.join( config['top level logging directory'], name + '-submit' ) 
mkdir_p( logging_dir )

use_lockserver = False
if config[ 'use lockserver' ]:
    use_lockserver = True
    lockserver_port = lockserver( owner, host ).ping()

    # request suite access from the lock server
    # submit does not need to call release_suite_access()
    if not suite_lock( name, suite_dir, owner, host, lockserver_port, 'submit' ).request_suite_access():
        raise SystemExit( 'ERROR: failed to acquire a suite lock' )

# CYLC EXECUTION ENVIRONMENT
cylcenv = OrderedDict()
if options.sched:
    cylcenv[ 'CYLC_MODE' ] = 'scheduler'
else:
    cylcenv[ 'CYLC_MODE' ] = 'submit'
cylcenv[ 'CYLC_SUITE_HOST' ] = host
cylcenv[ 'CYLC_SUITE_PORT' ] = 'NONE'
cylcenv[ 'CYLC_DIR' ] = os.environ[ 'CYLC_DIR' ]
cylcenv[ 'CYLC_SUITE_DIR' ] = suite_dir
cylcenv[ 'CYLC_SUITE_NAME' ] = name
cylcenv[ 'CYLC_SUITE_OWNER' ] = owner
cylcenv[ 'CYLC_USE_LOCKSERVER' ] = str( use_lockserver )

# USER DEFINED GLOBAL ENVIRONMENT
globalenv = OrderedDict()
for var in config['environment']:
    globalenv[ var ] = config['environment'][var]

# create the log
log = logging.getLogger()
pimp_my_logger.pimp_it( log, logging_dir, logging.INFO, False, None, True )

job_submit.cylc_env = cylcenv
job_submit.global_env = globalenv
 
job_submit.joblog_dir = config['job submission log directory']

# intantiate the task--------------------------------------------------
task_proxy = config.get_task_proxy( task_name, ctime, 'waiting', startup=True )

#print '\nPREREQUISITES:\n'
#for item in task_proxy.prerequisites.dump():
#    print item
#print '\nOUTPUTS:\n'
#for item in task_proxy.outputs.dump():
#    print item

# SUBMIT THE TASK TO RUN-----------------------------------------------
if options.dry_run:
    print "DRY RUN: create task execution script, show how it would be submitted."
else:
    print "Logging directory: " + logging_dir
    print
task_proxy.run_external_task( dry_run=options.dry_run )
print
