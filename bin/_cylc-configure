#!/bin/bash

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# Generate task class and config module for a particular cylc suite

# TO DO: rewrite this in Python to allow long options '--help' etc., for
# consistency with other cylc commands.

set -e  # ABORT on error

function print_usage() 
{
	echo "Usage: cylc configure [options] PATH"
    echo ""
    echo "Create a ready-to-schedule suite from parsed task definition files."
    echo "A suite should be reconfigured if its taskdef files have changed."
    echo ""
    echo "Configuration generates suite-specific Python modules in the"
    echo "'configured' sub-directory of the suite definition directory."
    echo "A customizable suite.config file is also generated the first time"
    echo "a suite is configured, after which it will not be overwritten."
    echo ""
    echo "Arguments:"
    echo "  PATH         Location of a cylc suite definition directory."
    echo ""
    echo "Options:"
    echo "  -h, --help   Print this usage message and exit."
    echo "  -c           Clean: remove all autogenerated files and backups from"
    echo "               the specified cylc suite definition directory (but NOT"
    echo "               the customizable files)."
}

# long options '--foo=bar' aren't supported by bash getopts
# but we need '--help' option to comply with 'cylc help'.
for OPT in $@; do
    if [[ $OPT == '--help' ]]; then
        print_usage
        exit 0
    fi
done

CLEAN=false

#while getopts "hf" opt; do
while getopts "hc" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        c)
        CLEAN=true
        ;;
        *)
        exit 1
        ;;
    esac
done

shift $(( OPTIND -1 ))

if [[ $# == 1 ]]; then 
    # all args supplied
    SUITE_DIR=$1
else
    echo "WRONG NUMBER OF ARGS"
    print_usage
	exit 1
fi

if [[ ! -d $SUITE_DIR ]]; then
    echo "Directory not found: $SUITE_DIR"
    exit 1
fi

if [[ $SUITE_DIR != /* ]]; then
    # make path absolute 
    SUITE_DIR=$PWD/$SUITE_DIR
    # remove trailing '/'
    SUITE_DIR=${SUITE_DIR%/}
fi

TASKDEF=$SUITE_DIR/taskdef
CONFIGURED=$SUITE_DIR/configured

# is this a cylc suite definition directory?
if [[ ! -d $TASKDEF ]]; then
    echo "ERROR: $TASKDEF not found"
    exit 1
fi

if $CLEAN; then
    echo
    echo "CLEANING CYLC SUITE $SUITE_DIR"
    # remove all auto-generated files
    rm -rf $CONFIGURED
    # and backups
    rm -rf ${CONFIGURED}.[0-9]*
    echo "Done"
    exit 0
fi

# check that the cylc bin directory is accessible
CYLC=$(which cylc)
CYLC_DIR=${CYLC%/bin/cylc}

echo
echo "CONFIGURING CYLC SUITE $SUITE_DIR"

# back up or create configured output sub-dir
if [[ -d $CONFIGURED ]]; then
    BKP=${CONFIGURED}.$$
    echo "Backing up existing configured dir to $BKP"
    cp -r $CONFIGURED $BKP
    rm -rf $CONFIGURED
fi
mkdir -p $CONFIGURED

echo
echo "Processing task definition files"

# if the command line gets too big we'll have to use xargs:
#    find taskdef -name '*.def' -o -name '*.py' | xargs _cylc-taskdef
# and modify _cylc-taskdef so that it appends output to
# task_classes.py file rather than overwriting.

cd $CONFIGURED
TASKDEFS=$( find $TASKDEF -name '*.def' -o -name '*.py' ) 
_cylc-taskdef $CONFIGURED $TASKDEFS
cd $SUITE_DIR

# generate task list module
echo
echo "Generating the task list module"

cat > $CONFIGURED/task_list.py <<eof
#/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# LIST OF TASK NAMES (order irrelevant)
task_list = \\
    [
eof
OIFS=$IFS
IFS=$'\n'
for MOD in $CONFIGURED/class_*.py; do
    echo -n "  $MOD"
    NAME=$( egrep '^ *name = ' $MOD )
    NAME=${NAME# *= }
    echo " ... $NAME"
    echo "       ${NAME}," >> $CONFIGURED/task_list.py
done
IFS=$OIFS
cat >> $CONFIGURED/task_list.py <<eof
    ]

task_list_shortnames = \\
    [
eof
OIFS=$IFS
IFS=$'\n'
for MOD in $CONFIGURED/class_*.py; do
    SHORTNAME=$( egrep '^ *short_name = ' $MOD )
    SHORTNAME=${SHORTNAME# *= }
    echo "       ${SHORTNAME}," >> $CONFIGURED/task_list.py
done
IFS=$OIFS
cat >> $CONFIGURED/task_list.py <<eof
    ]
# END OF FILE
eof

echo "task_list.py"

echo

# suite config file
export CYLC_SUITE_DIR=$SUITE_DIR
python -c 'from suiterc import suiterc; rc=suiterc()'

cat >> suite.config.README <<eof
_________________________________
*** CYLC SUITE CONFIG FILE FORMAT

A default is generated the first time a new system is configured.

Uses standard config file format:

[Section]
item = value

- Full line or trailing comments: '#'.
- No multiline values allowed.
- List values may be comma and/or space separated.
- '%' in values must be doubled up: MY_TASK_ID = foo%%2010010106

_________________________________
*** ANNOTATED CONFIGURABLE ITEMS:

[general] #----------------------

# title string describing suite
title = USERGUIDE EXAMPLE SUITE

# can multiple instances of this suite run at once under different names?
allow simultaneous instances = False

[task insertion groups] #-------

# you can insert multiple tasks at once with 'cylc insert'
coldstart = modelX, modelY, cold_postp

[job submission] #--------------

# the 'default' method for the entire system ...
default = background

# ... except for tasks singled out for different methods:
at_now = task1, task3, task5
ll_raw = task6

[global environment] #--------- 

# Environment variables accessible to all suite tasks.
# Not evaluated until task execution time.
# Order of definition is preserved:
ONE = one
TWO = $ONE

# You can use shell expansion expressions and so on:
SUFFIX = ${HOME##*_}
eof

touch $CONFIGURED/FILES.AUTOGENERATED.BY.CYLC

# DONE
