#!/bin/bash

# Generate task class and config module for a particular cylc system

# TO DO: rewrite this in Python to allow long options '--help' etc., for
# consistency with other cylc commands.

set -e  # ABORT on error

function print_usage() 
{
	echo "usage: cylc configure [options] -s SYSTEM-NAME SYSTEM-PATH"
    echo ""
    echo "Configure a cylc system defined under SYSTEM-PATH for scheduling."
    echo "Subsequently you can refer to a configured system by its name." 
    echo "This needs to be done once, initially, and thereafter only if"
    echo "the system's task definition files have changed." 
    echo ""
    echo "Several files are generated in the system definition directory (so"
    echo "you need write permissions there; copy the directory if necessary):" 
    echo " * A Python task class module based on the task definition files."
    echo " * A Python default config module, which you can customize."
    echo "Finally, the configured system will be registered by name under"
    echo "your .cylc directory,  \$HOME/.cylc/configured, for future use."
    echo ""
    echo "arguments:"
    echo "  SYSTEM-PATH     Path to the system to be configured (with"
    echo "                  taskdef and scripts sub-dirs, etc.)." 
    echo ""
    echo "options:"
    echo "  -h, --help      Print this usage message and exit"
    echo "  -s NAME, --system=NAME"
    echo "                  Name to use in registering the configured system."
    echo "  -q QUEUE        Submit jobs to QUEUE using qsub, instead of using"
    echo "                  direct execution in the background." 
    echo "  -f              Force overwrite an existing system config file,"
    echo "                  after making a backup of the old config file."
    echo "                  By default we do not do this after reconfiguring"
    echo "                  because the config file may have been customized."
}

# cheap hack to get '--help', which isn't allowed by getopts
if [[ $1 == '--help' ]]; then
    print_usage
    exit 0
fi

FORCE=false
QSUB=false
NAMED=false
while getopts "hfq:s:" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        f)
        FORCE=true
        ;;
        q)
        QSUB=true
        QUEUE=$OPTARG
        ;;
        s)
        NAMED=true
        SYS_NAME=$OPTARG
        ;;
    esac
done

shift $(( OPTIND -1 ))

# check compulsory options
if ! $NAMED; then
    echo "ERROR: '-s NAME' is required"
    print_usage
    exit 1
fi

if [[ $# == 1 ]]; then 
    # all args supplied
    SYS_DIR=$1
    if [[ $SYS_DIR != /* ]]; then
        # make absolute path
        SYS_DIR=$PWD/$SYS_DIR
        # remove trailing '/'
        SYS_DIR=${SYS_DIR%/}
    fi

else
    echo "WRONG NUMBER OF ARGS"
    print_usage
	exit 1
fi

# bin/cylc checks that the cylc bin directory is accessible
CYLC=$(which cylc)
CYLC_DIR=${CYLC%/bin/cylc}

cd $SYS_DIR

echo
echo "CONFIGURING CYLC SYSTEM $SYS_NAME"

echo
echo "Processing task definition files"

# if the command line gets too big we'll have to use xargs:
#    find taskdef -name '*.def' -o -name '*.py' | xargs _cylc-task-generator
# and modify task-generator.py so that it appends to the output
# task_classes.py file rather than overwriting it each time.

TASKDEFS=$( find taskdef -name '*.def' -o -name '*.py' ) 

# generate task class code
_cylc-task-generator $TASKDEFS
echo "=> $SYS_DIR/task_classes.py"

echo
WRITE_CONFIG=true
if [[ -f system_config.py ]]; then
    echo "System config file already exists, "
    if ! $FORCE; then
        echo "NOT OVERWRITING in case of customization"
        WRITE_CONFIG=false
    else
        BACKUP=system_config.py.OLD.$$
        echo "OVERWRITING (backup: $BACKUP)"
        cp system_config.py $BACKUP
    fi
else
    echo "Writing the system config file"
fi

if $WRITE_CONFIG; then
    cat > system_config.py <<eof
#!/usr/bin/python

# THIS CYLC SYSTEM CONFIG MODULE WAS GENERATED BY 'cylc configure' FOR:
# $PWD

# Configured items are held in a single dict: config[ 'item' ] = value.
# REFER TO THE CYLC USER GUIDE FOR DOCUMENTATION OF CONFIGURABLE ITEMS. 
# Reconfiguring the system will not overwrite this unless you force it.

import logging  # for logging level
import os       # os.environ['HOME']

config = {}

# SYSTEM NAME
config['system_name'] = '$SYS_NAME'

# TASK NAMES
config['task_list'] = \\
    [
eof

    for FILE in $TASKDEFS; do
        TASKNAME=$( _cylc-taskname < $FILE )
        echo "       '${TASKNAME}'," >> system_config.py
    done

    cat >> system_config.py <<eof
    ]

# TASK GROUPS
config['task_groups'] = {}

# LOGGING DIRECTORY
config['logging_dir'] = 'CYLC-LOGS'

# STATE DUMP DIRECTORY
config['state_dump_dir'] = 'CYLC-STATE'

# ENVIRONMENT VARIABLES THAT MAY BE USED BY TASKS IN THIS SYSTEM
sys_name = config[ 'system_name' ]
user_name = os.environ['USER'] 
config['environment'] = {'TMPDIR':'/tmp/' + user_name + '/' + sys_name }

# MAXIMUM INTERVAL (IN CYCLE TIME) BETWEEN FASTEST AND SLOWEST TASKS
config['max_runahead_hours'] = 24

# JOB LAUNCH METHOD (currently qsub or direct background execution).
eof
    if $QSUB; then
        echo "config['use_qsub'] = True" >> system_config.py
        echo "config['job_queue'] = '$QUEUE'" >> system_config.py
    else
        echo "config['use_qsub'] = False" >> system_config.py
        echo "config['job_queue'] = None" >> system_config.py
    fi

    cat >> system_config.py <<eof

# LOG VERBOSITY
config['logging_level'] = logging.INFO
#config['logging_level'] = logging.DEBUG

# END-OF-FILE
eof
fi
echo "=> $SYS_DIR/system_config.py"

#echo
#echo "Installing the cylc task-wrapper script"
#mkdir -p scripts
#cp $CYLC_DIR/bin/_cylc-task-wrapper scripts/cylc-task-wrapper
#echo "=> $SYS_DIR/scripts/cylc-task-wrapper"

echo
echo "Updating your cylc global config"
CONF_DIR=$HOME/.cylc/configured
[[ ! -d $CONF_DIR ]] && mkdir -p $CONF_DIR

echo $SYS_DIR > $CONF_DIR/$SYS_NAME
echo "=> $CONF_DIR/$SYS_NAME"

echo
