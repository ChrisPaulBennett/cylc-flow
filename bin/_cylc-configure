#!/bin/bash

# Generate task class and config module for a particular cylc system

# TO DO: rewrite this in Python to allow long options '--help' etc., for
# consistency with other cylc commands.

set -e  # ABORT on error

function print_usage() 
{
	echo "usage: cylc configure [options] PATH"
    echo ""
    echo "Generate the system-specific Python source modules required by cylc."
    echo "This only needs to be done after changing the task definition files." 
    echo ""
    echo "YOU MUST HAVE WRITE PERMISSION IN THE SYSTEM DEFINITION DIRECTORY"
    echo "because the configure process writes some Python modules into it:"
    echo " * task_classes.py: task classes based on task definition files"
    echo " * task_list.py: list of task names to run"
    echo " * system_config.py: system configuration settings"
    echo " * job_submit.py: TO DO - EXPLAIN"
    echo ""
    echo "If you reconfigure the system, the config module will not be "
    echo "overwritten in case it has been customized, but the task list"
    echo "will be overwritten."
    echo ""
    echo "arguments:"
    echo "  PATH            Location of a cylc system definition directory."
    echo ""
    echo "options:"
    echo "  -h, --help      Print this usage message and exit."
    echo "  -f, --force     Overwrite existing config and job submit modules."
}

# cheap hack to get '--help', which isn't allowed by getopts
if [[ $1 == '--help' ]]; then
    print_usage
    exit 0
fi

FORCE=false
while getopts "hf" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        f)
        FORCE=true
        ;;
        *)
        echo "ERROR, unknown option $opt"
        exit 1
        ;;
    esac
done

shift $(( OPTIND -1 ))

if [[ $# == 1 ]]; then 
    # all args supplied
    SYS_DIR=$1
    if [[ $SYS_DIR != /* ]]; then
        # make absolute path
        SYS_DIR=$PWD/$SYS_DIR
        # remove trailing '/'
        SYS_DIR=${SYS_DIR%/}
    fi

else
    echo "WRONG NUMBER OF ARGS"
    print_usage
	exit 1
fi

# bin/cylc checks that the cylc bin directory is accessible
CYLC=$(which cylc)
CYLC_DIR=${CYLC%/bin/cylc}

cd $SYS_DIR

echo
echo "CONFIGURING CYLC SYSTEM $SYS_DIR"

echo
echo "Processing task definition files"

# if the command line gets too big we'll have to use xargs:
#    find taskdef -name '*.def' -o -name '*.py' | xargs _cylc-task-generator
# and modify task-generator.py so that it appends to the output
# task_classes.py file rather than overwriting it each time.

TASKDEFS=$( find taskdef -name '*.def' -o -name '*.py' ) 

# generate task class code
_cylc-task-generator $TASKDEFS
echo "$SYS_DIR/task_classes.py"

echo
WRITE_CONFIG=true
if [[ -f system_config.py ]]; then
    echo "system config module already exists, "
    if ! $FORCE; then
        echo "NOT OVERWRITING in case of customization"
        WRITE_CONFIG=false
    else
        BACKUP=system_config.py.OLD.$$
        echo "OVERWRITING (backup: $BACKUP)"
        cp system_config.py $BACKUP
    fi
else
    echo "Generating the system config module"
fi

if $WRITE_CONFIG; then
cat > system_config.py <<eof
#!/usr/bin/python

# o SYSTEM CONFIG MODULE FOR THE CYLC SYSTEM DEFINITION DIRECTORY:
#  $PWD
# o REFER TO THE CYLC USER GUIDE FOR DOCUMENTATION OF CONFIG ITEMS. 
# o THIS FILE WAS AUTOGENERATED BY 'cylc configure' BUT WILL NOT
# BE OVERWRITTEN ON RECONFIGURATION UNLESS YOU FORCE IT. 

# Configured items are held in a dict (Python associative array): 
#   items[ 'item' ] = value.
# Note that some "values" are themselves lists or dicts.

from config import config
from task_list import task_list
from system_info import info
import logging  # for logging level
import os       # os.environ['HOME']

class system_config( config ):

    def __init__( self, sysname ):
        config.__init__( self, sysname )

        # system title
        # self.items[ 'system_title' ] = 'DEFAULT TITLE'

        # system info: add descriptive information as you like, e.g.:
        # self.items[ 'system_info' ]['foo'] = 'foo bar baz'

        # system task list
        self.items['task_list'] = task_list

        # system info
        self.items['system_info']['info'] = info

        # task insertion groups, e.g:
        # self.items['task_groups']['foo'] = ['bar', 'baz']

        # default job submit method, e.g.:
        # self.items['job_submit_method'] = 'background2'

        # environment variables available to all tasks, can include
        # the registered system name, e.g.:
        # user = os.environ['USER'] 
        # self.items['environment']['TMPDIR'] = '/tmp/' + user + '/' + sysname

# END OF FILE
eof
fi
echo "system_config.py"

echo
echo "Generating the task list module"

cat > task_list.py <<eof
# LIST OF TASK NAMES (order irrelevant)
task_list = \\
    [
eof

for FILE in $TASKDEFS; do
    TASKNAME=$( _cylc-taskname < $FILE )
    echo "       '${TASKNAME}'," >> task_list.py
done

cat >> task_list.py <<eof
    ]
# END OF FILE
eof

echo "task_list.py"

# TASK GROUPS
# Use to insert multiple tasks at once, via 'cylc control', into the
# running system. One use for this item is to group together all tasks
# needed to cold start the system's driving models after a failure that
# prevents continued warm cycling. E.g.:
#config['task_groups']['coldstart'] = [ 'task1', 'task2', 'task3' ]

# ENVIRONMENT VARIABLES FOR USE BY ALL TASKS IN THIS SYSTEM, e.g.:
#user_name = os.environ['USER'] 
#config['environment']['TMPDIR'] = '/tmp/' + user_name

# OVERRIDE THE DEFAULT JOB SUBMIT METHOD FOR SPECIFIC TASKS, e.g.:
# method names are strings that are the name of a class imported into
# the job_submit_methods module in the system definition directory,
# e.g.:
#config['job_submit_overrides']['background2'] = [ 'task1', 'task2' ]

# END OF FILE 

echo
WRITE_JOBSUB=true
if [[ -f job_submit_methods.py ]]; then
    echo "job_submit_methods module already exists, "
    if ! $FORCE; then
        echo "NOT OVERWRITING in case of customization"
        WRITE_JOBSUB=false
    else
        BACKUP=job_submit_methods.py.OLD.$$
        echo "OVERWRITING (backup: $BACKUP)"
        cp job_submit_methods.py $BACKUP
    fi
else
    echo "Writing the job submit methods module"
fi

if $WRITE_JOBSUB; then
cat > job_submit_methods.py <<eof
#!/usr/bin/python

from background import background
from background2 import background2
from background_remote import background_remote
eof
fi
echo "$SYS_DIR/job_submit_methods.py"
echo

echo
WRITE_INFO=true
if [[ -f system_info.py ]]; then
    echo "system_info module already exists, "
    if ! $FORCE; then
        echo "NOT OVERWRITING in case of customization"
        WRITE_INFO=false
    else
        BACKUP=system_info.py.OLD.$$
        echo "OVERWRITING (backup: $BACKUP)"
        cp system_info.py $BACKUP
    fi
else
    echo "Writing the system info module"
fi

if $WRITE_INFO; then
cat > system_info.py <<eof
#!/usr/bin/python

info="""
REPLACE THIS WITH A DESCRIPTION OF YOUR SYSTEM, AND ANY ASPECTS OF IT
THAT ARE CONFIGURABLE VIA CYLC.
"""
eof
fi
echo "$SYS_DIR/system_info.py"
echo
