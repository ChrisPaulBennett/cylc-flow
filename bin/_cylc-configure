#!/bin/bash

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# Generate task class and config module for a particular cylc suite

# TO DO: rewrite this in Python to allow long options '--help' etc., for
# consistency with other cylc commands.

set -e  # ABORT on error

function print_usage() 
{
	echo "Usage: cylc configure [options] PATH"
    echo
    echo "Create a ready-to-schedule suite by parsing task definition files."
    echo "By default only taskdef files that have changed are reprocessed."
    echo 
    echo "MANUAL USE OF THIS COMMAND IS RARELY REQUIRED ANYMORE: cylc auto"
    echo "(re)configures any taskdef files that have changed. Occasional"
    echo "use of the '-c' (clean up) option is still recommended."
    echo
    echo "This generates suite-specific Python modules in the 'configured'"
    echo "sub-directory of the suite definition directory. A customizable"
    echo "suite config file is also generated on the first configuration."
    echo
    echo "Arguments:"
    echo "  PATH         Location of a cylc suite definition directory."
    echo
    echo "Options:"
    echo "  -h, --help   Print this usage message and exit."
    echo "  -c           Clean up (remove) all autogenerated backups."
    echo "  -f           Force processinf of all suite taskdef files."
}

# long options '--foo=bar' aren't supported by bash getopts
# but we need '--help' option to comply with 'cylc help'.
for OPT in $@; do
    if [[ $OPT == '--help' ]]; then
        print_usage
        exit 0
    fi
done

CLEAN=false
FORCE=false

while getopts "hcf" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        c)
        CLEAN=true
        ;;
        f)
        FORCE=true
        ;;
        *)
        exit 1
        ;;
    esac
done

shift $(( OPTIND -1 ))

if [[ $# == 1 ]]; then 
    # all args supplied
    SUITE_DIR=$1
else
    echo "ERROR: wrong number of arguments"
    print_usage
	exit 1
fi

if [[ ! -d $SUITE_DIR ]]; then
    echo "Directory not found: $SUITE_DIR"
    exit 1
fi

if [[ $SUITE_DIR != /* ]]; then
    # make path absolute 
    SUITE_DIR=$PWD/$SUITE_DIR
    # remove trailing '/'
    SUITE_DIR=${SUITE_DIR%/}
fi

TASKDEF=$SUITE_DIR/taskdef
CONFIGURED=$SUITE_DIR/configured

# is this a cylc suite definition directory?
if [[ ! -d $TASKDEF ]]; then
    echo "ERROR: $TASKDEF not found"
    exit 1
fi

if $CLEAN; then
    echo "Removing autogenerated suite file backups"
    #rm -rf $CONFIGURED
    rm -rf ${CONFIGURED}.[0-9]*
    exit 0
fi

# check that the cylc bin directory is accessible
CYLC=$(which cylc)
CYLC_DIR=${CYLC%/bin/cylc}

# if the command line gets too big we'll have to use xargs:
#    find taskdef -name '*.def' -o -name '*.py' | xargs _cylc-taskgen
# and modify _cylc-taskgen so that it appends output to
# task_classes.py file rather than overwriting.

TASKDEFS=""
ALL_TASKDEFS=$( find $TASKDEF -name '*.def' -o -name '*.py' ) 

if $FORCE; then
    ZIPPO=false
    TASKDEFS=$ALL_TASKDEFS
else
    ZIPPO=true
    for DEF in $ALL_TASKDEFS; do
        FNAME=$( basename $DEF )
        CLS="$CONFIGURED/class_${FNAME%.def}.py"
        if [[ ! -f $CLS ]] || [[ $DEF -nt $CLS ]]; then
            ZIPPO=false
            TASKDEFS="$TASKDEFS $DEF"
        fi
    done
fi

if $ZIPPO; then
    echo "This suite is configured."
    exit 0
fi

if [[ -d $CONFIGURED ]]; then
    # back up the configured dir
    BKP=${CONFIGURED}.$$
    echo "Suite configuration backup: $BKP"
    cp -r $CONFIGURED $BKP
else
    mkdir -p $CONFIGURED
fi

echo "Parsing task definition files:"
_cylc-taskgen $CONFIGURED $TASKDEFS

echo "Generating configured/task_classes.py"

cat > $CONFIGURED/task_classes.py <<eof
#/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

eof

for FILE in $CONFIGURED/class_*.py; do
    FNAME=$( basename $FILE )
    MODNAME=${FNAME%.py}
    CLSLINE=$( egrep '^class ' $FILE )
    # e.g. 'class foo(free):'
    CLS=$( echo $CLSLINE | sed -e 's/class //' )
    CLSNAME=$( echo $CLS | sed -e 's/(.*$//' )
    echo "from $MODNAME import $CLSNAME" >> $CONFIGURED/task_classes.py
done

echo "Generating configured/task_list.py"

cat > $CONFIGURED/task_list.py <<eof
#/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# LIST OF TASK NAMES (order irrelevant)
task_list = \\
    [
eof
OIFS=$IFS
IFS=$'\n'
for MOD in $CONFIGURED/class_*.py; do
    #echo -n "  $MOD"
    NAME=$( egrep '^ *name = ' $MOD )
    NAME=${NAME# *= }
    #echo " ... $NAME"
    echo "       ${NAME}," >> $CONFIGURED/task_list.py
done
IFS=$OIFS
cat >> $CONFIGURED/task_list.py <<eof
    ]

task_list_shortnames = \\
    [
eof
OIFS=$IFS
IFS=$'\n'
for MOD in $CONFIGURED/class_*.py; do
    SHORTNAME=$( egrep '^ *short_name = ' $MOD )
    SHORTNAME=${SHORTNAME# *= }
    echo "       ${SHORTNAME}," >> $CONFIGURED/task_list.py
done
IFS=$OIFS
cat >> $CONFIGURED/task_list.py <<eof
    ]
# END OF FILE
eof

# suite config file
export CYLC_SUITE_DIR=$SUITE_DIR
python -c 'from suiterc import suiterc; rc=suiterc()'

cat > $SUITE_DIR/suite.config.README <<eof
___________________________
*** CYLC SUITE CONFIG FILES

These conform to the standard Python ConfigParser module specs: 
http://docs.python.org/library/configparser.html.

A default config file is generated on first use of a suite.

; comment
[Section]
item = value ; comment

- COMMENTS start with ';' ('#' is allowed only for full line comments).
- Multiline values are not permitted.
- The '%' character must be doubled up: 
     MY_TASK_ID = foo%%2010010106 becomes MY_TASK_ID=foo%2010010106
- List values may be comma and/or space separated (cylc-specific).

_________________________________________
*** CYLC CONFIGURATION SECTIONS AND ITEMS

[general] ;----------------------

; title string describing suite
title = USERGUIDE EXAMPLE SUITE

; can multiple instances of this suite run at once under different names?
allow simultaneous instances = False

[task insertion groups] ;-------

; you can insert multiple tasks at once with 'cylc insert'
coldstart = modelX, modelY, cold_postp

[job submission] ;--------------

; the 'default' method for the entire system ...
default = background

; ... except for tasks singled out for different methods:
at_now = task1, task3, task5
ll_raw = task6

[global environment] ;--------- 

; Environment variables accessible to all suite tasks.
; Not evaluated until task execution time.
; Order of definition is preserved:
ONE = one
TWO = \$ONE

; You can use shell expansion expressions and so on:
FOO = \${HOME##*_}
; But note that '%' characters must be doubled up:
BAR = \${HOME%%%%_*}  ; becomes \${HOME%%_*}
eof

touch $CONFIGURED/FILES.AUTOGENERATED.BY.CYLC
# DONE
