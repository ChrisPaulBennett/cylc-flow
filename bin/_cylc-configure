#!/bin/bash

# Generate task class code, config module, and environment file for a
# particular cylc system, and copy the task-wrapper from cylc/bin to the
# system scripts directory.

# TO DO: rewrite this in Python to allow long options '--help' etc., for
# consistency with other cylc commands.

set -e  # ABORT on error

function print_usage() 
{
	echo "Usage: cylc configure [options] [CYLC_TOP] [SYS_NAME] SYS_PATH"
    echo ""
    echo "Configure a system for scheduling with cylc (or reconfigure"
    echo "an existing system after changing its task definition files)."
    echo ""
    echo "Arguments:"
    echo "  CYLC_TOP  ... top level of your cylc installation"
    echo "  SYS_NAME  ... name of the system"
    echo "  SYS_PATH  ... top level system defintion directory"
    echo ""
    echo "Options:"
    echo "  -h         ... print this message and exit"
    echo "  -f         ... force overwrite the system config file"
    echo "  -q QUEUE   ... configure cylc to launch jobs with qsub"
    echo ""
    echo "CYLC_TOP can be omitted if you cd into the cylc top level."
    echo "If SYS_NAME is omitted the last directory of SYS_DIR will"
    echo "be registered as the system name."
    echo ""
    echo "This command generates:"
    echo " * A Python task class module for the system task definitions."
    echo " * A default Python config module for the system."
    echo " * A environment script that gives cylc access to the system."
    echo "and registers the system in \$HOME/.cylc/configured-systems."
}

FORCE=false
QSUB=false
while getopts "hfq:" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        f)
        FORCE=true
        ;;
        q)
        QSUB=true
        QUEUE=$OPTARG
        ;;
    esac
done

shift $(( OPTIND -1 ))

if [[ $# == 3 ]]; then 
    # all args supplied
    SYS_NAME=$1
    CYLC_TOP_DIR=$2
    CYLC_SYS_DIR=$3

elif [[ $# == 2 ]]; then
    CYLC_SYS_DIR=$2
    # first arg must be either CYLC_TOP_DIR or SYS_NAME
    if [[ -d $1/taskdef ]]; then
        # first arg is the system dir
        CYLC_TOP_DIR=$1
        # system name is implied
        SYS_NAME=$( basename $CYLC_SYS_DIR )
    else
        # first arg is system name
        SYS_NAME=$1
        # cylc top dir is implied
        CYLC_TOP_DIR=$PWD
    fi

elif [[ $# == 1 ]]; then 
    # only system path supplied
    CYLC_SYS_DIR=$1
    # others implied
    SYS_NAME=$( basename $CYLC_SYS_DIR )
    CYLC_TOP_DIR=$PWD

else
    echo "WRONG NUMBER OF ARGS"
    print_usage
	exit 1
fi

CYLC=$CYLC_TOP_DIR/bin/cylc 
if [[ ! -f $CYLC ]]; then
	echo "ERROR: $CYLC not found!"
    print_usage
	exit 1
fi

ENV_SCRIPT='cylc-env.sh'

TOPDIR=$CYLC_TOP_DIR
SYSDIR=$CYLC_SYS_DIR

# remove any trailing '/'
SYSDIR=${SYSDIR%/}
TOPDIR=$PWD

# access to cylc utilities and sub-commands for this script
PATH=$PWD/bin:$PATH

cd $SYSDIR

echo
echo "CONFIGURING CYLC SYSTEM $SYS_NAME"

echo
echo "Processing task definition files"

# if the command line gets too big we'll have to use xargs:
#    find taskdef -name '*.def' -o -name '*.py' | xargs _cylc-task-generator
# and modify task-generator.py so that it appends to the output
# task_classes.py file rather than overwriting it each time.

TASKDEFS=$( find taskdef -name '*.def' -o -name '*.py' ) 

_cylc-task-generator $TASKDEFS
echo "=> $SYSDIR/task_classes.py"

echo
WRITE_CONFIG=true
if [[ -f user_config.py ]]; then
    echo -n "System config file exists"
    if ! $FORCE; then
        echo "(use '-f' to revert to defaults)"
        WRITE_CONFIG=false
    else
        echo "('-f': reverting to defaults)"
    fi
fi

if $WRITE_CONFIG; then
    cat > user_config.py <<eof
#!/usr/bin/python

# THIS IS A CYLC CONFIGURATION FILE FOR THE SYSTEM 
# $PWD
# IT WAS INITIALLY GENERATED BY 'cylc configure'.
# RECONFIGURING WILL NOT OVERWRITE UNLESS FORCED,
# because you may want to change default settings.

import logging  # for logging level
import os       # os.environ['HOME']

# config[ 'item_name' ] = item_value
config = {}

# SYSTEM NAME (also used as Pyro nameserver group)
config['system_name'] = '$SYS_NAME'

# LIST OF TASK NAMES
config['task_list'] = \\
    [
eof
    for FILE in $TASKDEFS; do
        TASKNAME=$( _cylc-taskname < $FILE )
        echo "       '${TASKNAME}'," >> user_config.py
    done

    cat >> user_config.py <<eof
    ]

# TASK GROUPS
config['task_groups'] = {}

# LOGGING DIRECTORY (default: in cwd)
config['logging_dir'] = 'CYLC-LOGS'

# STATE DUMP FILE (default: in cwd)
config['state_dump_dir'] = 'CYLC-STATE'
config['state_dump_file'] = 'state'

# ENVIRONMENT VARIABLES TO SET FOR USE BY EXTERNAL TASKS
# { VAR1:VALUE1, VAR2:VALUE2, ...}
config['environment'] = {'TMPDIR':'/tmp/' + os.environ['USER'] + '/' + config[ 'system_name' ]}

# MAXIMUM TIME ANY TASK IS ALLOWED TO GET AHEAD OF THE SLOWEST
config['max_runahead_hours'] = 24

# DUMMY MODE
config['dummy_mode'] = False

# JOB LAUNCH METHOD (qsub or background)
eof
    if $QSUB; then
        echo "config['use_qsub'] = True" >> user_config.py
        echo "config['job_queue'] = '$QUEUE'" >> user_config.py
    else
        echo "config['use_qsub'] = False" >> user_config.py
        echo "config['job_queue'] = None" >> user_config.py
    fi

    cat >> user_config.py <<eof

 # LOG VERBOSITY
config['logging_level'] = logging.INFO
#config['logging_level'] = logging.DEBUG
eof
fi
echo "=> $SYSDIR/user_config.py"

echo
echo "Installing the cylc task-wrapper script"
mkdir -p $TOPDIR/$SYSDIR/scripts
cp $TOPDIR/bin/_cylc-task-wrapper $TOPDIR/$SYSDIR/scripts/cylc-task-wrapper
echo "=> $SYSDIR/scripts/cylc-task-wrapper"

echo
echo "Generating a cylc environment script"

cat > $ENV_SCRIPT <<EOF
#!/bin/bash

# AUTO-GENERATED BY 'cylc configure'

# Set PATH and PYTHONPATH for cylc to run this system:
# $TOPDIR/$SYSDIR

# clean existing cylc paths
      PATH=\$( $TOPDIR/bin/_cylc-clean-path \$PATH )
PYTHONPATH=\$( $TOPDIR/bin/_cylc-clean-path \$PYTHONPATH )

# not using \$HOME or relative path; may be sourced by other users
PATH=$TOPDIR/bin:$TOPDIR/$SYSDIR/scripts:\$PATH
PATH=\${PATH%:}  # in case variable was empty before
PYTHONPATH=$TOPDIR/src:$TOPDIR/src/task-classes:$TOPDIR/src/requisites:$TOPDIR/$SYSDIR:\$PYTHONPATH
PYTHONPATH=\${PYTHONPATH%:}  # in case was empty before
export PATH PYTHONPATH

# export my location as \$CYLC_ENV
export CYLC_ENV=$TOPDIR/$SYSDIR/$ENV_SCRIPT

# export cylc bin path for utility scripts
export CYLC_BIN=$TOPDIR/bin

echo "ENVIRONMENT CONFIGURED FOR CYLC SYSTEM $TOPDIR/$SYSDIR"
EOF
echo "=> $SYSDIR/$ENV_SCRIPT"

#echo
#echo "SOURCE THE $SYS_NAME ENVIRONMENT SCRIPT BEFORE RUNNING CYLC:"
#echo ". $TOPDIR/$SYSDIR/cylc-env.sh"
#echo

echo
echo "Updating your cylc global config"
CONF_DIR=$HOME/.cylc/configured-systems
[[ ! -d $CONF_DIR ]] && mkdir -p $CONF_DIR

echo $TOPDIR/$SYSDIR > $CONF_DIR/$SYS_NAME
echo "=> $CONF_DIR/$SYS_NAME"

echo
