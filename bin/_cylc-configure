#!/bin/bash

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# Generate task class and config module for a particular cylc suite

# TO DO: rewrite this in Python to allow long options '--help' etc., for
# consistency with other cylc commands.

set -e  # ABORT on error

function print_usage() 
{
	echo "Usage: cylc configure [options] PATH"
    echo
    echo "Create a ready-to-schedule suite by parsing task definition files."
    echo "By default only taskdef files that have changed are reprocessed."
    echo 
    echo "MANUAL USE OF THIS COMMAND IS RARELY REQUIRED ANYMORE: cylc auto"
    echo "(re)configures any taskdef files that have changed. Occasional"
    echo "use of the '-c' (clean up) option is still recommended."
    echo
    echo "This generates suite-specific Python modules in the 'configured'"
    echo "sub-directory of the suite definition directory. A customizable"
    echo "suite config file is also generated on the first configuration."
    echo
    echo "Arguments:"
    echo "  PATH         Location of a cylc suite definition directory."
    echo
    echo "Options:"
    echo "  -h, --help   Print this usage message and exit."
    echo "  -c           Clean up (remove) all autogenerated backups."
    echo "  -f           Force processinf of all suite taskdef files."
}

# long options '--foo=bar' aren't supported by bash getopts
# but we need '--help' option to comply with 'cylc help'.
for OPT in $@; do
    if [[ $OPT == '--help' ]]; then
        print_usage
        exit 0
    fi
done

CLEAN=false
FORCE=false

while getopts "hcf" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        c)
        CLEAN=true
        ;;
        f)
        FORCE=true
        ;;
        *)
        exit 1
        ;;
    esac
done

shift $(( OPTIND -1 ))

if [[ $# == 1 ]]; then 
    # all args supplied
    SUITE_DIR=$1
else
    echo "ERROR: wrong number of arguments"
    print_usage
	exit 1
fi

if [[ ! -d $SUITE_DIR ]]; then
    echo "Directory not found: $SUITE_DIR"
    exit 1
fi

if [[ $SUITE_DIR != /* ]]; then
    # make path absolute 
    SUITE_DIR=$PWD/$SUITE_DIR
    # remove trailing '/'
    SUITE_DIR=${SUITE_DIR%/}
fi

TASKDEF=$SUITE_DIR/taskdef
CONFIGURED=$SUITE_DIR/configured

# is this a cylc suite definition directory?
if [[ ! -d $TASKDEF ]]; then
    echo "ERROR: $TASKDEF not found"
    exit 1
fi

if $CLEAN; then
    echo "Removing autogenerated suite file backups"
    #rm -rf $CONFIGURED
    rm -rf ${CONFIGURED}.[0-9]*
    exit 0
fi

# check that the cylc bin directory is accessible
CYLC=$(which cylc)
CYLC_DIR=${CYLC%/bin/cylc}

# if the command line gets too big we'll have to use xargs:
#    find taskdef -name '*.def' -o -name '*.py' | xargs _cylc-taskgen
# and modify _cylc-taskgen so that it appends output to
# task_classes.py file rather than overwriting.

TASKDEFS=""
ALL_TASKDEFS=$( find $TASKDEF -name '*.def' -o -name '*.py' ) 

if $FORCE; then
    ZIPPO=false
    TASKDEFS=$ALL_TASKDEFS
else
    ZIPPO=true
    for DEF in $ALL_TASKDEFS; do
        CLSNAME=$( _cylc-get-taskname < $DEF )
        CLS=$CONFIGURED/__${CLSNAME}.py
        if [[ ! -f $CLS ]] || [[ $DEF -nt $CLS ]]; then
            ZIPPO=false
            TASKDEFS="$TASKDEFS $DEF"
        fi
    done
fi

if $ZIPPO; then
    echo "This suite is configured."
    exit 0
fi

if [[ -d $CONFIGURED ]]; then
    # back up the configured dir
    BKP=${CONFIGURED}.$$
    echo "Suite configuration backup: $BKP"
    cp -r $CONFIGURED $BKP
else
    mkdir -p $CONFIGURED
fi

echo "Parsing task definition files:"
_cylc-taskgen $CONFIGURED $TASKDEFS

echo "Generating configured/task_classes.py"

cat > $CONFIGURED/task_classes.py <<eof
#/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

eof

for FILE in $CONFIGURED/__*.py; do
    FNAME=$( basename $FILE )
    MODNAME=${FNAME%.py}
    CLSNAME=${MODNAME#__}
    echo "from $MODNAME import $CLSNAME" >> $CONFIGURED/task_classes.py
done

echo "Generating configured/task_list.py"

cat > $CONFIGURED/task_list.py <<eof
#/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# LIST OF TASK NAMES (order irrelevant)
task_list = \\
    [
eof
OIFS=$IFS
IFS=$'\n'
for MOD in $CONFIGURED/__*.py; do
    #echo -n "  $MOD"
    NAME=$( egrep '^ *name = ' $MOD )
    NAME=${NAME# *= }
    #echo " ... $NAME"
    echo "       ${NAME}," >> $CONFIGURED/task_list.py
done
IFS=$OIFS
cat >> $CONFIGURED/task_list.py <<eof
    ]

task_list_shortnames = \\
    [
eof
OIFS=$IFS
IFS=$'\n'
for MOD in $CONFIGURED/__*.py; do
    SHORTNAME=$( egrep '^ *short_name = ' $MOD )
    SHORTNAME=${SHORTNAME# *= }
    echo "       ${SHORTNAME}," >> $CONFIGURED/task_list.py
done
IFS=$OIFS
cat >> $CONFIGURED/task_list.py <<eof
    ]
# END OF FILE
eof

# generate default suite config file
export CYLC_SUITE_DIR=$SUITE_DIR
python -c 'from suiterc import suiterc; rc=suiterc()'

echo "Copying documents"

# copy suite config README file
mkdir -p $SUITE_DIR/doc
cp $CYLC_DIR/doc/suite.rc.README $SUITE_DIR/doc

# copy suite design document
cp $CYLC_DIR/doc/SuiteDesign.txt $SUITE_DIR/doc

touch $CONFIGURED/AUTOGENERATED.BY.CYLC
# DONE
