#!/bin/bash

# Generate task class code, config module, and environment file for a
# particular cylc system, and copy the task-wrapper from cylc/bin to the
# system scripts directory.

# TO DO: rewrite this in Python to allow long options '--help' etc., for
# consistency with other cylc commands.

set -e  # ABORT on error

function print_usage() 
{
    echo ""
	echo "Usage: cylc configure [options] CYLC-PATH SYSTEM-PATH"
    echo "          Configure a cylc system for scheduling"
    echo ""
    echo "This generates, in the system definition directory:"
    echo " * A Python task class module"
    echo " * A Python default config module, which you can customize"
    echo " * A environment script that provides access to the system"
    echo "And: registers the system under \$HOME/.cylc/configured."
    echo ""
    echo "Arguments:"
    echo "  CYLC-PATH   ... path to the cylc installation"
    echo "                  (with bin/ and src/ sub-dirs, etc.)"
    echo "  SYSTEM-PATH ... path to the system defintion directory"
    echo "                  (with taskdef/ and scripts/ sub-dirs, etc.)" 
    echo ""
    echo "Compulsory Options:"
    echo "  -n NAME     ... name of the system to configure"
    echo ""
    echo "Optional Options:"
    echo "  -h, --help  ... print this message and exit"
    echo "  -f          ... force overwrite an existing system config file"
    echo "                  (which may have been customized) with defaults"
    echo "  -q QUEUE    ... submit jobs to QUEUE using qsub (default"
    echo "                  is direct execution in background)". 
    echo ""
}

# cheap hack to get '--help', which isn't allowed by getopts
if [[ $1 == '--help' ]]; then
    print_usage
    exit 0
fi

FORCE=false
QSUB=false
NAMED=false
while getopts "hfq:n:" opt; do
    case $opt in
        h)
        print_usage
        exit 0
        ;;
        f)
        FORCE=true
        ;;
        q)
        QSUB=true
        QUEUE=$OPTARG
        ;;
        n)
        NAMED=true
        SYS_NAME=$OPTARG
        ;;
    esac
done

shift $(( OPTIND -1 ))

# check compulsory options
if ! $NAMED; then
    echo "ERROR: '-n NAME' is required"
    print_usage
    exit 1
fi

if [[ $# == 2 ]]; then 
    # all args supplied
    CYLC_TOP_DIR=$1
    CYLC_SYS_DIR=$2

else
    echo "WRONG NUMBER OF ARGS"
    print_usage
	exit 1
fi

CYLC=$CYLC_TOP_DIR/bin/cylc 
if [[ ! -f $CYLC ]]; then
	echo "ERROR: $CYLC not found!"
    print_usage
	exit 1
fi

ENV_SCRIPT='cylc-env.sh'

TOPDIR=$CYLC_TOP_DIR
SYSDIR=$CYLC_SYS_DIR

# remove any trailing '/'
SYSDIR=${SYSDIR%/}
TOPDIR=$PWD

# access to cylc utilities and sub-commands for this script
PATH=$PWD/bin:$PATH

cd $SYSDIR

echo
echo "CONFIGURING CYLC SYSTEM $SYS_NAME"

echo
echo "Processing task definition files"

# if the command line gets too big we'll have to use xargs:
#    find taskdef -name '*.def' -o -name '*.py' | xargs _cylc-task-generator
# and modify task-generator.py so that it appends to the output
# task_classes.py file rather than overwriting it each time.

TASKDEFS=$( find taskdef -name '*.def' -o -name '*.py' ) 

_cylc-task-generator $TASKDEFS
echo "=> $SYSDIR/task_classes.py"

echo
WRITE_CONFIG=true
if [[ -f user_config.py ]]; then
    echo "Config file already exists for $SYS_NAME"
    if ! $FORCE; then
        echo "I won't overwrite with default values in"
        echo "case of customization; use '-f' to force"
        WRITE_CONFIG=false
    else
        BACKUP=user_config.py.OLD.$$
        echo "Overwrite with default values requested"
        echo "Backing up old file to $BACKUP"
        cp user_config.py $BACKUP
    fi
fi

if $WRITE_CONFIG; then
    cat > user_config.py <<eof
#!/usr/bin/python

# FILE AUTO-GENERATED BY 'cylc configure' FOR THIS CYLC SYSTEM:
# $PWD

# YOU MAY CUSTOMIZE THIS FILE, i.e. CHANGE THE DEFAULT VALUES.
# 'cylc configure' will not overwrite this file on reconfiguring
# (after changing task definitions) unless you force it ('-f'). 

import logging  # for logging level
import os       # os.environ['HOME']

# CONFIG ITEMS ARE HELD IN A PYTHON DICT: config[ 'item' ] = value
config = {}

# SYSTEM NAME
# Used to refer to this system in cylc commands, and as a Pyro
# Nameserver Group in which to register task objects etc. 
config['system_name'] = '$SYS_NAME'

# LIST OF TASK NAMES
# You can turn off tasks by commenting them out in this list.
config['task_list'] = \\
    [
eof
    for FILE in $TASKDEFS; do
        TASKNAME=$( _cylc-taskname < $FILE )
        echo "       '${TASKNAME}'," >> user_config.py
    done

    cat >> user_config.py <<eof
    ]

# TASK GROUPS
# Task groups allow dynamic insertion of multiple related tasks at once
# by the group name, e.g. all the tasks needed to cold start some model:
# config['task_groups']['foo_coldstart'] = [ 'foo_cold', 'bar', 'baz' ]
config['task_groups'] = {}

# LOGGING DIRECTORY
# This can be relative to your running directory, or an absolute path.
config['logging_dir'] = 'CYLC-LOGS'

# STATE DUMP FILE
# This can be relative to your running directory, or an absolute path.
config['state_dump_dir'] = 'CYLC-STATE'
config['state_dump_file'] = 'state'

# ENVIRONMENT VARIABLES THAT MAY BE USED BY EXTERNAL TASKS
# config['environment'] = { VAR1:VALUE1, VAR2:VALUE2, ...}
config['environment'] = {'TMPDIR':'/tmp/' + os.environ['USER'] + '/' + config[ 'system_name' ]}

# MAXIMUM CYLCE TIME INTERVAL BETWEEN THE FASTEST AND SLOWEST TASKS
config['max_runahead_hours'] = 24

# JOB LAUNCH METHOD
# Currently: qsub as task owner, or direct background execution.
# To change job lauch method, see src/task_launcher.py.
eof
    if $QSUB; then
        echo "config['use_qsub'] = True" >> user_config.py
        echo "config['job_queue'] = '$QUEUE'" >> user_config.py
    else
        echo "config['use_qsub'] = False" >> user_config.py
        echo "config['job_queue'] = None" >> user_config.py
    fi

    cat >> user_config.py <<eof

# LOG VERBOSITY
# 'info' level logs messages relevant to task execution and scheduling.
# 'debug' level adds messages that trace the execution of cylc itself.
config['logging_level'] = logging.INFO
#config['logging_level'] = logging.DEBUG
eof
fi
echo "=> $SYSDIR/user_config.py"

echo
echo "Installing the cylc task-wrapper script"
mkdir -p $TOPDIR/$SYSDIR/scripts
cp $TOPDIR/bin/_cylc-task-wrapper $TOPDIR/$SYSDIR/scripts/cylc-task-wrapper
echo "=> $SYSDIR/scripts/cylc-task-wrapper"

echo
echo "Generating a cylc environment script"

cat > $ENV_SCRIPT <<EOF
#!/bin/bash

# AUTO-GENERATED BY 'cylc configure'

# Set PATH and PYTHONPATH for cylc to run this system:
# $TOPDIR/$SYSDIR

# clean existing cylc paths
      PATH=\$( $TOPDIR/bin/_cylc-clean-path \$PATH )
PYTHONPATH=\$( $TOPDIR/bin/_cylc-clean-path \$PYTHONPATH )

# not using \$HOME or relative path; may be sourced by other users
PATH=$TOPDIR/bin:$TOPDIR/$SYSDIR/scripts:\$PATH
PATH=\${PATH%:}  # in case variable was empty before
PYTHONPATH=$TOPDIR/src:$TOPDIR/src/task-classes:$TOPDIR/src/requisites:$TOPDIR/$SYSDIR:\$PYTHONPATH
PYTHONPATH=\${PYTHONPATH%:}  # in case was empty before
export PATH PYTHONPATH

# export my location as \$CYLC_ENV
export CYLC_ENV=$TOPDIR/$SYSDIR/$ENV_SCRIPT

# export cylc bin path for utility scripts
export CYLC_BIN=$TOPDIR/bin

echo "ENVIRONMENT CONFIGURED FOR $TOPDIR/$SYSDIR"
EOF
echo "=> $SYSDIR/$ENV_SCRIPT"

#echo
#echo "SOURCE THE $SYS_NAME ENVIRONMENT SCRIPT BEFORE RUNNING CYLC:"
#echo ". $TOPDIR/$SYSDIR/cylc-env.sh"
#echo

echo
echo "Updating your cylc global config"
CONF_DIR=$HOME/.cylc/configured
[[ ! -d $CONF_DIR ]] && mkdir -p $CONF_DIR

echo $TOPDIR/$SYSDIR > $CONF_DIR/$SYS_NAME
echo "=> $CONF_DIR/$SYS_NAME"

echo
