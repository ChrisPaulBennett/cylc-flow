#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# TO DO: THIS SCRIPT NEEDS TO BE CLEANED UP WITH MORE CODE REUSE

import string
import glob
import sys
import re

import os

def usage():
    print 'USAGE: ' + sys.argv[0] + ' <list of task definition files>'
    sys.exit(1)

def indent_more():
    global indent
    global indent_unit
    indent += indent_unit

def indent_less():
    global indent
    global indent_unit
    indent = re.sub( indent_unit, '', indent, 1 )
    
def print_parsed_info():

    global parsed_def

    for k in parsed_def:
        print
        print k + ':' 
        for val in parsed_def[ k ]:
            print ' - ' + val

def interpolate_cycle_times( strng ):
    # interpolate $(CYCLE_TIME [+/-N]) in a string
    # strng = 'a string'  (SINGLE QUOTES REQUIRED)

    # strip leading spaces
    strng = re.sub( "^'\s+", "'", strng )

    # replace "$(CYCLE_TIME)"
    strng = re.sub( "^'\$\(CYCLE_TIME\)'$",   "self.c_time",     strng ) # alone
    strng = re.sub( "^'\$\(CYCLE_TIME\)",     "self.c_time + '", strng ) # start line
    strng = re.sub( "\$\(CYCLE_TIME\)'$", "' + self.c_time"   ,  strng ) # end line
    strng = re.sub( "\$\(CYCLE_TIME\)" , "'  + self.c_time + '", strng ) # mid line

    # replace "$(CYCLE_TIME - XX )"
    m = re.search( '\$\(\s*CYCLE_TIME\s*-\s*(\d+)\s*\)', strng )
    if m:
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)'$",   "cycle_time.decrement( self.c_time, " + m.group(1) + ")",     strng ) # alone
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)",     "cycle_time.decrement( self.c_time, " + m.group(1) + ") + '", strng ) # start line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)'$", "' + cycle_time.decrement( self.c_time, " + m.group(1) + ")",     strng ) # mid line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)",   "' + cycle_time.decrement( self.c_time, " + m.group(1) + ") + '", strng ) # end line

    # replace "$(CYCLE_TIME + XX )"
    m = re.search( '\$\(\s*CYCLE_TIME\s*\+\s*(\d+)\s*\)', strng )
    if m:
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)'$",   "cycle_time.increment( self.c_time, " + m.group(1) + ")",     strng ) # alone
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)",     "cycle_time.increment( self.c_time, " + m.group(1) + ") + '", strng ) # start line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)'$", "' + cycle_time.increment( self.c_time, " + m.group(1) + ")",     strng ) # mid line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)",   "' + cycle_time.increment( self.c_time, " + m.group(1) + ") + '", strng ) # end line

    return strng

def require_quotes( strng, item ):
    # require enclosing quotes, then strip them off
    
    # first strip any whitespace
    str = string.strip( strng )

    m = re.match( '^".*"$', str )
    if m:
        stripped = string.strip( str, '"' )
    else:
        print 'ERROR: ' + item + ' must be enclosed in double quotes'
        sys.exit(1)

    return stripped

def time_trans( strng, hours=False ):
    # translate a time of the form:
    #  x sec, y min, z hr
    # into NUMERICAL MINUTES or HOURS,
    # and return a string thereof.

    if not re.search( '^\s*(.*)\s*min\s*$', strng ) and \
        not re.search( '^\s*(.*)\s*sec\s*$', strng ) and \
        not re.search( '^\s*(.*)\s*hr\s*$', strng ):
            print "ERROR: missing time unit on " + strng
            sys.exit(1)

    m = re.search( '^\s*(.*)\s*min\s*$', strng )
    if m:
        [ mins ] = m.groups()
        if hours:
            return str( float( mins / 60.0 ) )
        else:
            return str( float(mins) )

    m = re.search( '^\s*(.*)\s*sec\s*$', strng )
    if m:
        [ secs ] = m.groups()
        if hours:
            return str( float(secs)/3600.0 )
        else:
            return str( float(secs)/60.0 )

    m = re.search( '^\s*(.*)\s*hr\s*$', strng )
    if m:
        [ hrs ] = m.groups()
        if hours:
            return str( float(hrs) )
        else:
            return str( float(hrs)*60.0 )


#================= MAIN PROGRAM ========================================
def main( argv ):

    global parsed_def
    global FILE

    global indent, indent_unit
    indent = ''
    indent_unit = '    '

    task_class_file = 'task_classes.py'

    if len( argv ) < 2:
        usage()

    task_def_files = argv[1:]

    allowed_keys = [ 'INHERIT', 'NAME', 'OWNER', 'CYCLES', 'TASK',
            'REMOTE_HOST', 'DIRECTIVES', 'COMMANDLINE',
            'ENVIRONMENT', 'NO_NONCOTEMPORAL_DEPENDANTS', 'PREREQUISITES',
            'STARTUP_PREREQUISITES', 'OUTPUTS', 'ESTIMATED_RUN_TIME',
            'TYPE', 'CONTACT_DELAY', 'DESCRIPTION', 'OUTPUT_PATTERNS',
            'ONEOFF_FOLLOW_ON', 'ESTIMATED_RESTART_OUTPUT_TIMES' ]

    allowed_types = ['tied', 'free', 'cycling_daemon' ]
    allowed_modifiers = ['dummy', 'sequential', 'oneoff', 'contact', 'catchup_contact' ]

    # open the output file
    FILE = open( task_class_file, 'w' )
    # python interpreter location
    FILE.write( '#!/usr/bin/python\n\n' )
    # auto-generation warning
    # preamble
    FILE.write( 
'''

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


from daemon import daemon
from asynchronous import asynchronous
from tied import tied
from free import free
from mod_oneoff import oneoff
from mod_sequential import sequential
from mod_contact import contact
from mod_catchup_contact import catchup_contact
from prerequisites_fuzzy import fuzzy_prerequisites
from prerequisites import prerequisites
from outputs import outputs
from cycling_daemon import cycling_daemon
from time import sleep

import cycle_time
import task_state

import os, sys, re
from copy import deepcopy
from time import strftime
import Pyro.core
import logging

from dynamic_instantiation import get_object

''')

    n_files = len(task_def_files)
    i = 0

    seen = {}

    for task_def_file in task_def_files:

        i += 1

        DEF = open( task_def_file, 'r' )
        lines = DEF.readlines()
        DEF.close()

        print '  + ' + task_def_file

        if re.match( '^.*\.py$', task_def_file ):
            # this file is a python class definition
            for line in lines:
                FILE.write( line )

            FILE.write( '\n' )
            continue

        current_key = None

        parsed_def = {}
        for lline in lines:

            line = string.strip( lline )

            # skip blank lines
            if re.match( '^\s*$', line ):
                continue

            # skip comment lines
            if re.match( '^\s*#.*', line ):
                continue

            if re.match( '^%.*', line ):
                # new key identified
                current_key = string.lstrip( line, '%' )
                # print 'new key: ' + current_key,
                if current_key not in allowed_keys:
                    print 'ILLEGAL KEY ERROR: ' + current_key
                    sys.exit(1)
                parsed_def[ current_key ] = []

            else:
                if current_key == None:
                    # can this ever happen?
                    print "Error: no key identified"
                    sys.exit(1)
    
                # data associated with current key
                parsed_def[ current_key ].append( line ) 

        # print_parsed_info()

        inherit = False
        if 'INHERIT' in parsed_def:
            inherit = True
            inherit_from = parsed_def['INHERIT'][0]

        # quick death (DEFAULT False)
        quick_death = False
        if 'NO_NONCOTEMPORAL_DEPENDANTS' in parsed_def:
            delayed_death = parsed_def[ 'NO_NONCOTEMPORAL_DEPENDANTS' ][0]
            if delayed_death == 'True' or delayed_death == 'true' or delayed_death == 'Yes' or delayed_death == 'yes':
                quick_death = True

        delay = 0
        catchup_contact = False
        sequential = False
        contact = False
        oneoff = False
        dummy = False
        task_type = None

        if 'TYPE' not in parsed_def:
            if not inherit:
                print "ERROR: no %TYPE specified"
                sys.exit(1)

        else:

            tmp = parsed_def[ 'TYPE' ][0]
            typelist = tmp.split(',')

            task_type = typelist[0]
            if task_type not in allowed_types:
                print 'ERROR, unknown task class:', task_type
                sys.exit(1)

            if task_type == 'tied':
                if quick_death:
                    print 'ERROR, tied tasks cannot set NO_NONCOTEMPORAL_DEPENDANTS'
                    print 'because they necessarily have next-cycle dependants'
                    sys.exit(1)

            if task_type == 'cycling_daemon':
                if 'OUTPUT_PATTERNS' not in parsed_def:
                    print 'ERROR, cycling daemon tasks must define OUTPUT_PATTERNS'
                    sys.exit(1)

            derived_from = task_type

            modifiers = typelist[1:]
            if len(modifiers) > 0:
                got_modifiers = True

                # strip white space
                modifiers = [ x.strip() for x in modifiers ]

                for modifier in modifiers:
                    if modifier not in allowed_modifiers:
                        print 'ERROR, unknown task modifier:', modifier
                        print allowed_modifiers
                        sys.exit(1)

                    if modifier == 'dummy':
                        dummy = True
                    elif modifier == 'sequential':
                        sequential = True
                    elif modifier == 'oneoff':
                        oneoff = True
                    elif modifier == 'contact':
                        contact = True
                    elif modifier == 'catchup_contact':
                        contact = True
                        catchup_contact = True

                # removed 'dummy' from modifiers; it is handled below by
                # simply replacing the external task, not class derivation.

                if 'dummy' in modifiers:
                    modifiers.remove( 'dummy' )

                # this assumes the order of modifiers does not matter.
                if len( modifiers ) >= 1:
                    derived_from = ','.join( modifiers ) + ', ' + derived_from

        if 'TASK' in parsed_def:
            external_task = parsed_def[ 'TASK' ][0]
            if dummy:
                print "WARNING: this task has the 'dummy' task type modifier, and therefore its"
                print "external task, " + external_task + ", will be replaced by _cylc-dummy-task."
        else:
            # no external task specified
            if not dummy:
                print 'ERROR: no external task specified'
                sys.exit(1)

        # set external task for dummy tasks
        if dummy:
            external_task = '_cylc-dummy-task'

        oneoff_follow_on = False
        if oneoff and not quick_death:
            if 'ONEOFF_FOLLOW_ON' not in parsed_def:
                print "Error: oneoff tasks that have non-cotemporal dependants"
                print "must define %ONEOFF_FOLLOW_ON"
                sys.exit(1)
            else:
                oneoff_follow_on = parsed_def['ONEOFF_FOLLOW_ON'][0]

        task_init_def_args = 'c_time, initial_state, startup = False, no_reset = False'
        task_inherit_super_args = 'c_time, initial_state, startup, no_reset'
        task_init_args = 'initial_state, no_reset'

        if contact:
            if 'CONTACT_DELAY' not in parsed_def:
                print "Error: contact classes must define %CONTACT_DELAY"
                sys.exit(1)

        if task_type == 'tied':
            if 'ESTIMATED_RESTART_OUTPUT_TIMES' not in parsed_def:
                print 'Error: forecast models must define %ESTIMATED_RESTART_OUTPUT_TIMES'
                sys.exit(1)
            #else:
            #    restart_list = parsed_def[ 'ESTIMATED_RESTART_OUTPUT_TIMES' ][0]

        task_name = parsed_def[ 'NAME' ][0]

        if task_name in seen:
            print "ERROR: task name '" + task_name + "' has been defined already!"
            sys.exit(1)
        else:
            seen[ task_name ] = True

        short_name = task_name
        m = re.search( '^\s*(.*),\s*(.*)\s*$', task_name )
        if m:
            # short name given as well
            [ task_name, short_name ] = m.groups()

        # class definition
        if inherit:
            FILE.write( 'class ' + task_name + '(' + inherit_from + '):\n' )
        else:
            FILE.write( 'class ' + task_name + '(' + derived_from + '):\n' )

        indent_more()
 
        FILE.write( indent + '# AUTO-GENERATED FROM ' + task_def_file + '\n\n' )  
   
        # task name
        FILE.write( indent + 'name = \'' + task_name + '\'\n' )
        FILE.write( indent + 'short_name = \'' + short_name + '\'\n' )

        FILE.write( indent + 'instance_count = 0\n\n' )

        # task description
        if 'DESCRIPTION' in parsed_def:
            FILE.write( indent + 'description = [\n' )
            indent_more()
            for line in  parsed_def[ 'DESCRIPTION' ]:
                FILE.write( indent + "'" + line + "',\n" )
            indent_less()
            FILE.write( indent + ']\n\n' )
        else:
            print "ERROR: no %DESCRIPTION provided for task " + task_name
            sys.exit(1)

        # owner
        owner = None
        if 'OWNER' in parsed_def:
            owner = parsed_def[ 'OWNER' ][0]
            FILE.write( indent + 'owner = \'' + owner + '\'\n' )
        elif not inherit:
            FILE.write( indent + 'owner = None\n' )

        # external task
        FILE.write( indent + 'external_task = \'' + external_task + '\'\n\n' )

        # remote host
        remote_host = None
        if 'REMOTE_HOST' in parsed_def:
            remote_host = parsed_def[ 'REMOTE_HOST' ][0]
            FILE.write( indent + 'remote_host = \'' + remote_host + '\'\n\n' )
        else:
            FILE.write( indent + 'remote_host = None\n' )

        FILE.write( indent + 'job_submit_method = None\n' )

        if 'CYCLES' not in parsed_def:
            # ASYNC TASKS DON'T HAVE CYLCES
            #if not inherit:
            #    print "ERROR: no %CYCLES provided for task " + task_name
            #    sys.exit(1)
            pass

        else:
            # valid hours
            FILE.write( indent + 'valid_hours = [' + parsed_def[ 'CYCLES' ][0] + ']\n\n' )

        if 'NO_NONCOTEMPORAL_DEPENDANTS' in parsed_def:
            FILE.write( indent + 'quick_death = ' + str(quick_death) + '\n\n' )

        if oneoff_follow_on:
            FILE.write( indent + 'oneoff_follow_on = "' + oneoff_follow_on + '"\n\n' )

        # class init function
        FILE.write( indent + 'def __init__( self, ' + task_init_def_args + ' ):\n\n' )

        indent_more()

        if inherit:
            FILE.write( indent + 'super(' + task_name + ', self ).__init__(' + task_inherit_super_args + ' )\n\n' )

        if not inherit:
            FILE.write( indent + '# adjust cycle time to next valid for this task\n' )
            FILE.write( indent + 'self.c_time = self.nearest_c_time( c_time )\n' )
            FILE.write( indent + 'self.tag = self.c_time\n' )
            FILE.write( indent + 'self.id = self.name + \'%\' + self.c_time\n' )
            # FIXME ASYNC
            FILE.write( indent + 'hour = self.c_time[8:10]\n\n' )

        #if contact:
        if 'CONTACT_DELAY' in parsed_def: 
            for line in parsed_def[ 'CONTACT_DELAY' ]:
                line = re.sub( '\s+$', '', line )
                # look for conditionals
                m = re.match( '^([\d,]+)\s*\|\s*(.*)$', line )
                if m:
                    [ left, delay ] = m.groups()
                    # get a list of hours
                    hours = left.split(',')
                    for hour in hours:
                        FILE.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        FILE.write( indent + 'self.real_time_delay = ' + time_trans( delay, hours=True ) + '\n' )
                        indent_less()
                else:
                    delay = line
                    FILE.write( indent + 'self.real_time_delay = ' + time_trans( delay, hours=True ) + '\n' )

            FILE.write( '\n' )

        # ... prerequisites
        if not inherit or 'PREREQUISITES' in parsed_def:
            FILE.write( indent + 'self.prerequisites = prerequisites( self.id )\n' )

        if 'PREREQUISITES' in parsed_def:
            for line in parsed_def[ 'PREREQUISITES' ]:

                # look for conditionals
                m = re.match( '^([\d,]+)\s*\|\s*(.*)$', line )
                if m:
                    [ left, req ] = m.groups()
                    # get a list of hours
                    hours = left.split(',')
                    req = re.sub( '^\s+', '', req )

                    req = require_quotes( req, 'prerequisites' )

                    req = "'" + req + "'"
                    req = interpolate_cycle_times( req )
                    for hour in hours:
                        FILE.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        FILE.write( indent + 'self.prerequisites.add( ' + req + ' )\n' )
                        indent_less()
                else:
                    line = require_quotes( line, 'prerequisites' )

                    req = "'" + line + "'"
                    req = interpolate_cycle_times( req )
                    FILE.write( indent + 'self.prerequisites.add( ' + req + ' )\n' )
 

        # are the prerequisites different for the first instance?
        if 'STARTUP_PREREQUISITES' in parsed_def:
            # TO DO: use a function to re-use the normal prerequisite code (as above) here.
            FILE.write( '\n' + indent + "if startup:\n" )
            indent_more()
            FILE.write( indent + '# overwrite prerequisites for startup case\n' )
            #FILE.write( indent + 'self.prerequisites = prerequisites( self.id )\n' )
            for line in parsed_def[ 'STARTUP_PREREQUISITES' ]:

                # look for conditionals
                m = re.match( '^([\d,]+)\s*\|\s*(.*)$', line )
                if m:
                    [ left, req ] = m.groups()
                    # get a list of hours
                    hours = left.split(',')
                    req = re.sub( '^\s+', '', req )

                    req = require_quotes( req, 'prerequisites' )

                    req = "'" + req + "'"
                    req = interpolate_cycle_times( req )
                    for hour in hours:
                        FILE.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        FILE.write( indent + 'self.prerequisites.add( ' + req + ' )\n' )
                        indent_less()
                else:

                    line = require_quotes( line, 'prerequisites' )

                    req = "'" + line + "'"
                    req = interpolate_cycle_times( req )
                    FILE.write( indent + 'self.prerequisites.add( ' + req + ' )\n' )
 
            indent_less()

        # ... outputs
        if not inherit or 'OUTPUTS' in parsed_def:
            FILE.write( '\n' )
            FILE.write( indent + 'self.outputs = outputs( self.id )\n' )

        # automatic 'started' and 'finished' outputs
        if 'ESTIMATED_RUN_TIME' not in parsed_def:
            if not inherit:
                print "ERROR: %ESTIMATED_RUN_TIME not defined"
                sys.exit(1)

        else:
            FILE.write( '\n' )
            for line in parsed_def[ 'ESTIMATED_RUN_TIME' ]:
                line = re.sub( '\s+$', '', line )
                # look for conditionals
                m = re.match( '^([\d,]+)\s*\|\s*(.*)$', line )
                if m:
                    [ left, rlen ] = m.groups()
                    # get a list of hours
                    hours = left.split(',')
                    for hour in hours:
                        FILE.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        FILE.write( indent + 'self.register_run_length( ' + time_trans( rlen ) + ' )\n' )
                        indent_less()
                else:
                    rlen = line
                    FILE.write( indent + 'self.register_run_length( ' + time_trans( rlen ) + ' )\n\n' )
       
        if 'OUTPUTS' in parsed_def:
            for line in parsed_def[ 'OUTPUTS' ]:

                # look for conditionals
                m = re.match( '^([\d,]+)\s*\|\s*(.*)$', line )
                if m:
                    [ left, timed_req ] = m.groups()
                    # get a list of hours
                    hours = left.split(',')
                    [ time, req ] = timed_req.split( ':' )

                    req = require_quotes( req, 'outputs' )

                    req = "'" + req + "'"
                    req = interpolate_cycle_times( req )
                    for hour in hours:
                        FILE.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        FILE.write( indent + 'self.outputs.add( ' + time_trans( time ) + ', ' + req + ' )\n' )
                        indent_less()
                else:
                    timed_req = line
                    [ time, req ] = timed_req.split( ':' )

                    req = require_quotes( req, 'outputs' )

                    req = "'" + req + "'"
                    req = interpolate_cycle_times( req )
                    FILE.write( indent + 'self.outputs.add( ' + time_trans( time ) + ', ' + req + ' )\n' )

        # ... output patterns
        if not inherit:
            FILE.write( '\n' )
            FILE.write( indent + 'self.output_patterns = []\n' )

        if 'OUTPUT_PATTERNS' in parsed_def:
            for line in parsed_def[ 'OUTPUT_PATTERNS' ]:
                 FILE.write( indent + 'self.output_patterns.append( ' + line + ')\n' )

        # environment variables
        if not inherit:
            FILE.write( '\n' + indent + 'self.env_vars = {}\n' )

        if 'ENVIRONMENT' in parsed_def:
            for pair in parsed_def[ 'ENVIRONMENT' ]:
                ( var, val ) = pair.split( ' ', 1 )
                var = "'" + var + "'"
                # interpolate $(CYCLE_TIME [+/-n]) 
                val = interpolate_cycle_times( "'" + val + "'" )
                FILE.write( indent + 'self.env_vars[' + var + '] = ' + val + '\n' )

        # command line
        if not inherit:
            FILE.write( '\n' + indent + 'self.commandline = []\n' )

        if 'COMMANDLINE' in parsed_def:
            for line in parsed_def[ 'COMMANDLINE' ]:
                line = "'" + line + "'"
                # interpolate $(CYCLE_TIME [+/-n]) 
                line = interpolate_cycle_times( line )
                FILE.write( indent + 'self.commandline.append(' + line + ')\n' )

        # batch queue scheduler directives (qsub or loadleveler)
        if not inherit:
            FILE.write( '\n' + indent + 'self.directives = {}\n' )

        if 'DIRECTIVES' in parsed_def:
            for pair in parsed_def[ 'DIRECTIVES' ]:
                ( var, val ) = pair.split( ' ', 1 )
                var = "'" + var + "'"
                # interpolate $(CYCLE_TIME [+/-n]) 
                val = interpolate_cycle_times( "'" + val + "'" )
                FILE.write( indent + 'self.directives[' + var + '] = ' + val + '\n' )

        # forecast model restarts
        if task_type == 'tied' or ( inherit and 'ESTIMATED_RESTART_OUTPUT_TIMES' in parsed_def ):

            for line in parsed_def['ESTIMATED_RESTART_OUTPUT_TIMES']:

                line = re.sub( '\s+$', '', line )
                # look for conditionals
                m = re.match( '^([\d,]+)\s*\|\s*(.*)$', line )
                if m:
                    [ left, right ] = m.groups()
                    # get a list of hours
                    hours = left.split(',')
                    for hour in hours:
                        FILE.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        restarts = right.split( ',' )
                        transt = []
                        for t in restarts:
                            transt.append( time_trans( t ) )

                        FILE.write( indent + 'restart_times = [' + ','.join( transt ) + ']\n' )
                        FILE.write( indent + 'self.register_restarts( restart_times )\n\n' )

                        indent_less()
                else:
                    restarts = line.split( ',' )
                    transt = []
                    for t in restarts:
                        transt.append( time_trans( t ) )

                    FILE.write( indent + 'restart_times = [' + ','.join( transt ) + ']\n' )
                    FILE.write( indent + 'self.register_restarts( restart_times )\n\n' )

        if not inherit:
            # call parent init methods
            # FOR PARENT CLASS TYPES THAT HAVE INIT METHODS!
            if catchup_contact:
                FILE.write( indent + 'catchup_contact.__init__( self )\n\n' )
 
            FILE.write( indent + task_type + '.__init__( self, ' + task_init_args + ' )\n\n' )

        indent_less()
        indent_less()
 
    FILE.close()

if __name__ == '__main__':
    main( sys.argv )

