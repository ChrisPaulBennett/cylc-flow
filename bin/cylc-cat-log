#!/usr/bin/env python

# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) 2008-2015 NIWA
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
from cylc.remote import remrun
if remrun().execute():
    sys.exit(0)

import re, os
from subprocess import Popen, PIPE
from cylc.CylcOptionParsers import cop
from cylc.command_prep import prep_file
from cylc.owner import is_remote_user
from cylc.rundb import CylcRuntimeDAO
from cylc.suite_host import is_remote_host
from cylc.suite_logging import suite_log
from cylc.suite_output import suite_output
from cylc.cfgspec.globalcfg import GLOBAL_CFG
import cylc.flags
from cylc.task_id import TaskID

parser = cop("""cylc [info] cat-log|log [OPTIONS] ARGS
Print suite or task log files.""",
    argdoc=[ ("REG", "Suite name"),
    ("[TASK-ID]", """Print the stdout or stderr log
of the identified task""")])

parser.add_option("-l", "--location",
        help="Print the location of the requested log file. Exit status "
        "is 0 if the file exits, or 1 if it does not.",
        action="store_true", default=False, dest="print_location")

parser.add_option("-o", "--stdout",
        help="Suite or task stdout log "
        "(for suites, the default is to print the event log; "
        " for tasks, the default is to print job stdout).",
        action="store_true", default=False, dest="print_stdout")

parser.add_option("-e", "--stderr",
        help="Print suite or task stderr logs (see --stdout for defaults).",
        action="store_true", default=False, dest="print_stderr")

parser.add_option("-r", "--rotation",
        help="Suite logs only: log rotation number (default current)",
        metavar="INT", action="store", default="0", dest="rotation")

parser.add_option("-a", "--activity",
        help="Task job activity log.",
        action='store_true', default=False, dest="job_activity")

parser.add_option("-d", "--diff",
        help="Task job script diff (if an edit-run occured).",
        action='store_true', default=False, dest="job_diff")

parser.add_option("-u", "--status",
        help="Task job status file.",
        action='store_true', default=False, dest="job_status")

parser.add_option("-s", "--submit-number",
        help="Task logs only: job submit number (default latest).",
        metavar='INT', action="store", default="NN", dest="subnum")

parser.add_option("-t", "--try-number",
        help="(deprecated - use -s/--submit-number).",
        metavar='INT', action="store", default="NN", dest="subnum")

(options, args) = parser.parse_args()
suite, suiterc = prep_file(args[0], options).execute()
owner = options.db_owner

if len(args) == 2:
    # Task log requested.
    if options.rotation:
        parser.error("Illegal option for task logs: -r/--rotation")

    taskid = args[1]
    try:
        task, point = TaskID.split(taskid)
    except:
        sys.exit("ERROR, illegal task ID: %s" % taskid)
    if options.subnum == "NN":
        log_dir = os.path.join(point, task, "NN", "job")
    else:
        log_dir = os.path.join(point, task, "%02d" % int(options.subnum), "job")

    suite_run_dir = GLOBAL_CFG.get_derived_host_item(
        suite, 'suite run directory')
    suite_run_dao = CylcRuntimeDAO(suite_run_dir)
    host = suite_run_dao.get_task_host(task, point)
    suite_run_dao.close()
    owner = None
    if host and '@' in host:
        owner, host = host.split('@', 1)

    sjld = GLOBAL_CFG.get_derived_host_item(suite, 'suite job log directory',
                                            host=host, owner=owner)
    if options.print_stdout:
        fpath = os.path.join(sjld, log_dir + '.out')
    elif options.print_stderr:
        fpath = os.path.join(sjld, log_dir + '.err')
    elif options.job_diff:
        fpath = os.path.join(sjld, log_dir + '-edit.diff')
    elif options.job_status:
        fpath = os.path.join(sjld, log_dir + '.status')
    elif options.job_activity:
        fpath = os.path.join(sjld, log_dir + '-activity.log')
    else:
        fpath = os.path.join(sjld, log_dir)

    if is_remote_host(host) or is_remote_user(owner):
        if host and owner:
            url = owner + '@' + host
        elif host:
            url = host
        elif owner:
            url = owner + '@localhost'

        if options.print_location:
            print url + ':' + fpath
            cmd = ['ssh', '-oBatchMode=yes', url, 'test -e %s' % fpath]
        else:
            cmd = ['ssh', '-oBatchMode=yes', url, 'cat ' + fpath]
        try:
            p = Popen(cmd, stdout=PIPE, stderr=PIPE)
        except OSError as exc:
            if cylc.flags.debug:
                raise
            sys.exit(exc)
        out, err, = p.communicate()
        if out:
            print out
        if err:
            print >> sys.sderr, err
            sys.exit(1)
        sys.exit(0)

else:
    # suite log requested
    if any([options.job_activity,
            options.job_diff,
            options.job_status,
            options.subnum]):
        parser.error("Task log option(s) are not legal for suite logs.")

    sld = GLOBAL_CFG.get_derived_host_item(suite, 'suite log directory')
    if options.print_stdout:
        fpath = os.path.join(sld, 'out')
    elif options.print_stderr:
        fpath = os.path.join(sld, 'err')
    else:
        fpath = os.path.join(sld, 'log')
        if options.rotation != "0":
            fpath += '.' + options.rotation

# Local logs.
if not os.path.exists(fpath):
    sys.exit("File not found:\n %s" % fpath)

if options.print_location:
    print fpath

try:
    with open(fpath, 'rb') as LOG:
        for line in LOG: 
            print line.rstrip()
except Exception as exc:
    if cylc.flags.debug:
        raise
    sys.exit(exc)

LOG.close()
