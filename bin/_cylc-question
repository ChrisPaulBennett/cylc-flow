#!/usr/bin/python

# import standard Python modules
# cylc modules are imported after parsing the command line, so that we
# don't need access to a specific system to print the usage message.
import os
import re
import sys
import Pyro.core
from optparse import OptionParser
from time import sleep
from Pyro.errors import PyroError,NamingError

ctrl_end = "\033[0m"

def print_heading( strng ):
        print
        print strng
        underline = re.sub( '.', '-', strng )
        print underline

# construct a command line parser
usage = """cylc question [options] SYSTEM 

Interrogate a running cylc system.

If the target system is not running under your username you must use
--user=USERNAME so that the right Pyro nameserver group name can be
inferred (cylc uses USERNAME_SYSTEM).

arguments:
   SYSTEM               Registered name of the target system.""" 

parser = OptionParser( usage )

parser.add_option( "-u", "--username",
        help="Owner of the target system (i.e. the username under which "
        "the scheduler is running), defaults to $USER.",
        metavar="USERNAME", action="store", dest="username" )

parser.add_option( "-n", "--nameserver",
        help="The Pyro nameserver host. Defaults to localhost. Depending "
        "on network configuration you may not need to use this option.",
        metavar="HOSTNAME", action="store", default="localhost",
        dest="pns_host" )

parser.add_option( "--dump", 
        help="Display the current status of one or more task's prerequisites, "
        "outputs, and other information deemed relevant to scheduling.",
        metavar="NAME1,NAME2,...%CYCLE", 
        action="store", dest="dump_task_id" )

parser.add_option( "--describe-task", 
        help="Display the description of one or more task types"
        "(no cycle time required).",
        metavar="NAME1,NAME2,...", 
        action="store", dest="describe_names" )

parser.add_option( "--describe-system",
        help="Display the system description.",
        action="store_true", default=False, dest="describe_system" )

# get command line options and positional args
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

system_name = args[0]

if not options.pns_host:
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host

# Pyro nameserver groupname of the target system
if options.username:
    username = options.username
else:
    username = os.environ[ 'USER' ] 

groupname = username + '_' + system_name

# import cylc modules now (the reason for this is explained above)
import pyrex

#if len( args ) > 1:
#    parser.error( "incorrect number of arguments" )

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover( pns_host )

if ns_groups.registered( groupname ):
    #print "system: " + system_name
    pass
else:
    print "WARNING: no " + groupname + " registered yet ..." 
    ns_groups.print_info()

    # print available systems and exit
    print
    parser.print_help()
    print
    ns_groups.print_info()
    print
    sys.exit(1)


try:
    # connect to the remote switch object in cylc
    control = Pyro.core.getProxyForURI('PYRONAME://' + pns_host + '/' + groupname + '.' + 'remote' )
except NamingError:
    print "\n\033[1;37;41mfailed to connect" + ctrl_end 
    raise SystemExit

if options.describe_system:
    print
    print 'system: ' + system_name
    print 'SYSTEM DESCRIPTION NOT YET IMPLEMENTED'

if options.describe_names:
    print
    print 'system: ' + system_name

    # retrieve and print task class descriptions
    if re.search( ',', options.describe_names ):
        # multiple names
        names = options.describe_names.split( ',' )
    else:
        # one name
        names = [ options.describe_names ]

    # strip off cycle time, if given
    names = [ re.sub( '%.*', '', name ) for name in names ]

    info = control.get_task_info( names )
    for name in info.keys():
        print
        print name + ':'
        for line in info[name]:
            print '  ' + line
    print

if options.dump_task_id:
    [ tmp, ctime ] = options.dump_task_id.split( '%' )
    if re.search( ',', tmp ):
        names = tmp.split( ',' )
    else:
        names = [ tmp ]

    ids = []
    for name in names:
        id = name + '%' + ctime
        ids.append( id )

    result = control.get_task_requisites( ids )

    print
    print 'System:  ' + system_name
    print 'Task ID: ' + id
    print
    print ' + => prerequisite satisfied, or output completed' 
    print ' - => prerequisite NOT satisfied, or output NOT completed' 

    for id in ids:
        if id not in result.keys():
            print
            print 'ERROR: task not found'

    for id in result.keys():
        [ pre, out, extra_info ] = result[ id ]

        print_heading( 'Prerequisites:')
        if len( pre ) == 0:
            print '(None)'
        for item in pre:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        print_heading( 'Outputs:' )
        if len( out ) == 0:
            print '(None)'
        for item in out:
            [ msg, state ] = item
            if state:
                descr = ' + '
            else:
                descr = ' - '
            print descr + msg

        if len( extra_info.keys() ) > 0:
            print_heading( 'Other:' )
            for item in extra_info:
                print item, '...', extra_info[ item ]

    print
