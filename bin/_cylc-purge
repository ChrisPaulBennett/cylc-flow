#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


import os
import cycle_time
import check_switch
import cylc_pyro_client
from CylcOptionParsers import PromptOptionParser

parser = PromptOptionParser( """cylc purge [options] SYSTEM TASK_ID STOP

Force a task to spawn and die, and then force every task that depends on
its outputs to spawn and die, and then force every task that depends on
their outputs to spawn and die, and so on until a given stop cycle time.

WARNING: THIS COMMAND IS DANGEROUS, but you can use an instant practice
mode clone (see 'cylc restart --help') to test your planned intervention,
or in case of disaster simply restart the system from the automatic
pre-purge state dump (the filename will be logged by cylc before
actioning the purge.)""",
["TASK_ID              Task at which to start the purge (NAME%YYYYMMDDHH).",
 "STOP                 Cycle (inclusive!) at which to stop (YYYYMMDDHH)"] )

(options, args) = parser.parse_args()

if len( args ) != 3:
    parser.error( "System name, task ID, and stop cycle required." )

target = args[1]
stop = args[2]

# check inputs
try:
    ( name, start ) = target.split('%')
except ValueError:
    parser.error( "Task ID must be NAME%YYYYMMDDHH")
 
for cycle in [ start, stop ]:
    if not cycle_time.is_valid( cycle ):
        parser.error( "invalid cycle time: " + cycle )

if parser.prompt( 'Purge from ' + target + ' to ' + stop + ' in'):
    host = parser.get_pns_host()
    group = parser.get_groupname()

    god = cylc_pyro_client.client( host, group ).get_proxy( 'remote' )
    check_switch.check( god.purge( target, stop, os.environ['USER'] ))
