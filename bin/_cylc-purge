#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


import os
import cycle_time
import check_switch
from connector import connector
from CylcOptionParsers import PromptOptionParser
from Pyro.errors import NamingError

parser = PromptOptionParser( """cylc purge [options] SYSTEM 

Force a task to spawn and die, and then force every task that depends on
its outputs to spawn and die, and then force every task that depends on
their outputs to spawn and die, and so on down to a given cycle time.

WARNING: THIS COMMAND IS DANGEROUS, but if necessary you can restart
the system from the automatic pre-purge state dump (see the main log)

WARNING: This kills task proxy objects in the scheduler, NOT running
external tasks!""")

parser.add_option( "-t", "--task",
        help="ID of the task whose decendants are to be wiped out.",
        metavar="TASK%CYCLE", action="store", dest="target_id" )

parser.add_option( "-s", "--stop",
        help="Purge tasks down to this cycle time (inclusive!).",
        metavar="CYCLE", action="store", dest="stop" )

(options, args) = parser.parse_args()

if not options.target_id:
    parser.error( "Task ID required" )

if not options.stop:
    parser.error( "Stop time required" )

target = options.target_id  
stop = options.stop

# check inputs
( name, start ) = target.split('%')
for cycle in [ start, stop ]:
    if not cycle_time.is_valid( cycle ):
        parser.error( "invalid cycle time: " + cycle )

if parser.prompt( 'Purge from ' + target + ' to ' + stop + ' in'):
    try:
        god = connector( parser.get_pns_host(), parser.get_groupname(), 'remote' ).get()
    except NamingError:
        print 'ERROR: system ' + args[0] + ' not running?'
    except Exception, x:
        print 'ERROR: ', x
    else:
        check_switch.check( god.purge( target, stop, os.environ['USER'] ))
