#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# A program that masquerade's as a given task by reporting its outputs
# completed on time according to the controller's dummy clock.

# This program could (and  in fact used to) make direct calls the task proxy
# incoming() method, but now it invokes 'cylc message' as a subprocess
# in order to more exactly model real system tasks. 

import Pyro.naming, Pyro.core
from Pyro.errors import NamingError
import cycle_time
import datetime
import sys, os, re
from time import sleep
import subprocess
from connector import connector


class dummy_task:

    def __init__( self, task_id, groupname, pns_host ):

        self.id = task_id
        # get a Pyro proxy for the task that I'm masquerading as
        self.task  = connector( pns_host, groupname, task_id ).get()
        # get a Pyro proxy for the dummy mode accelerated clock
        self.clock = connector( pns_host, groupname, 'clock' ).get()


    def send( self, message ):
        # send an output message to the task proxy object that I'm masquerading as
        command_list = [ 'cylc', 'message', message  ]
        try:
            retcode = subprocess.call( command_list )
            if retcode != 0:
                # the command returned non-zero exist status
                print >> sys.stderr, ' '.join( command_list ) + ' failed: ', retcode
                sys.exit(1)
        except OSError:
                # the command was not invoked
                print >> sys.stderr, 'ERROR: unable to execute ' + command_list
                print >> sys.stderr, ' * Is [cylc]/bin in your $PATH?'
                sys.exit(1)


    def run( self ):

        # get a list of output messages to fake: outputs[ time ] = [ output, ... ]
        outputs = self.task.get_timed_outputs()

        # ordered list of times
        times = outputs.keys()
        times.sort()

        # time to stop counting and generate the output
        # [ 0, 28, 30 ] dummy minutes
        prev_time = times[0]
        for time in times:
            # wait until the stop time for each output, and then generate the output
            diff_hrs = ( time - prev_time )/60.0
            dt_diff = datetime.timedelta( 0,0,0,0,0,diff_hrs,0 )
            # timedeltas are stored as days, seconds, milliseconds.
            dt_diff_sec = dt_diff.days * 24 * 3600 + dt_diff.seconds
            dt_diff_sec_real = dt_diff_sec * clock_rate / 3600.0
            sleep( dt_diff_sec_real )

            # make sure the finished message is last
            fin = self.id + ' finished' 
            if fin in outputs[time]:
                outputs[time].remove( fin )
                outputs[time].append( fin )

            for output in outputs[ time ]:
                self.send( output )

            if failout:
                # fail after the first message (and a small delay)
                sleep(2)

                # but first report 'completed' for dependent tasks that
                # don't care if this one finishes successfully or fails
            
                self.send( self.id + ' completed' )
                self.send( self.id + ' failed' )
                
                sys.exit(1)

            prev_time = time
            

#----------------------------------------------------------------------
if __name__ == '__main__':
    task_id = os.environ['TASK_ID']
    groupname = os.environ['CYLC_NS_GROUP'] 
    pns_host = os.environ['CYLC_NS_HOST'] 

    print "This is _cylc-dummy-task, masquerading as " + task_id

    clock_rate = 3600  # seconds per hour
    if 'CYLC_CLOCK_RATE' in os.environ:
        clock_rate = int( os.environ['CYLC_CLOCK_RATE'] )

    failout = False
    if 'CYLC_FAILOUT_ID' in os.environ:
        if os.environ['CYLC_FAILOUT_ID'] == task_id:
            print 'dummy task ' + task_id + ' programmed to FAIL!'
            failout = True

    dummy = dummy_task( task_id, groupname, pns_host )
    dummy.run()
