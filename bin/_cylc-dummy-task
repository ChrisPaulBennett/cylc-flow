#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# A program that masquerade's as a given task by reporting its outputs
# completed on time according to the controller's dummy clock.

# This program could (and  in fact used to) make direct calls the task proxy
# incoming() method, but now it invokes 'cylc message' as a subprocess
# in order to more exactly model real system tasks. 

import cycle_time
import datetime
import sys, os, re
from time import sleep
import subprocess
import cylc_pyro_client

class dummy_task:

    def __init__( self, task_id, groupname, pns_host ):

        self.id = task_id
        # get a Pyro proxy for the task that I'm masquerading as
        self.task  = cylc_pyro_client.client( pns_host, groupname ).get_proxy( task_id )
        # get a Pyro proxy for the dummy mode accelerated clock
        self.clock = cylc_pyro_client.client( pns_host, groupname ).get_proxy( 'clock' )

    def send( self, message ):
        # send an output message to the task proxy object that I'm masquerading as
        command_list = [ 'cylc', 'task-message', message  ]
        try:
            retcode = subprocess.call( command_list )
            if retcode != 0:
                # the command returned non-zero exist status
                print >> sys.stderr, ' '.join( command_list ) + ' failed: ', retcode
                sys.exit(1)
        except OSError:
                # the command was not invoked
                print >> sys.stderr, 'ERROR: unable to execute ' + command_list
                print >> sys.stderr, ' * Is [cylc]/bin in your $PATH?'
                sys.exit(1)


    def run( self ):
        # get a list of output messages to fake: outputs[ time ] = [ output, ... ]
        outputs = self.task.get_ordered_outputs()
        n_outputs = len( outputs ) 

        interval_m = run_length/(n_outputs -2 )  # (send 'completed' and 'finished' at once)
        interval_s = interval_m * 60.0
        interval_rs = interval_s * clock_rate / 3600.0

        if failout:
            sleep(2)
            self.send( self.id + ' completed' )
            self.send( self.id + ' failed' )
            sys.exit(1)

        for i in range( n_outputs - 2 ):
            self.send( outputs[i] )

            sleep( interval_rs )

            # WARNING: THE FOLLOWING FAILS FOR FAILOUT TASKS WITH FEW OUTPUTS!
            #if i == 2 and failout:
            #    sleep(2)
            #    self.send( self.id + ' completed' )
            #    self.send( self.id + ' failed' )
            #    sys.exit(1)

        self.send( outputs[-2] )            
        self.send( outputs[-1] )            

#----------------------------------------------------------------------
if __name__ == '__main__':
    task_id = os.environ['TASK_ID']
    groupname = os.environ['CYLC_NS_GROUP'] 
    pns_host = os.environ['CYLC_NS_HOST'] 

    print "This is _cylc-dummy-task, masquerading as " + task_id
    sys.stdout.flush()

    clock_rate = 3600  # seconds per hour
    if 'CYLC_CLOCK_RATE' in os.environ:
        clock_rate = int( os.environ['CYLC_CLOCK_RATE'] )

    failout = False
    if 'CYLC_FAILOUT_ID' in os.environ:
        if os.environ['CYLC_FAILOUT_ID'] == task_id:
            print >> sys.stderr, 'dummy task ' + task_id + ' programmed to FAIL!'
            failout = True

    if 'CYLC_DUMMY_TASK_RUN_LENGTH' in os.environ:
        run_length = int( os.environ[ 'CYLC_DUMMY_TASK_RUN_LENGTH' ] )
        print 'dummy task ' + task_id + ' dummy task run length: ' + str( run_length )
    else:
        run_length = 20.0

    dummy = dummy_task( task_id, groupname, pns_host )
    dummy.run()


#-------
# Time arithmetic from earlier cylc versions in which an estimated
# completion time had to be registered with each output, and these
# were simulated accurately in dummy mode:

#diff_hrs = ( time - prev_time )/60.0
#dt_diff = datetime.timedelta( 0,0,0,0,0,diff_hrs,0 )
## timedeltas are stored as days, seconds, milliseconds.
#dt_diff_sec = dt_diff.days * 24 * 3600 + dt_diff.seconds
#dt_diff_sec_real = dt_diff_sec * clock_rate / 3600.0
#sleep( dt_diff_sec_real )
