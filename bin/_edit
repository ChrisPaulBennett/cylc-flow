#!/usr/bin/env python

import os, re, sys
import datetime
import tempfile
from shutil import copy
import subprocess
from optparse import OptionParser
from collections import deque
from registration import registrations, RegistrationError

included = []
modtimes = {}
backups = {}
newfiles = []

def cleanup( suitedir ):
    print 'CLEANUP REQUESTED, deleting:'
    for root, dirs, files in os.walk( suitedir ):
        for file in files:
            if re.search( '\.EDIT\..*$', file ):
                print ' + ' + re.sub( suitedir + '/', '', file )
                os.unlink( os.path.join( root, file ))

def include_files( inf ):
    # using globals here for commonality across recursive calls:
    global suitedir
    global included
    global modtimes
    outf = []
    for line in inf:
        m = re.match( '\s*%include\s+([\w/\-\.]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if inc not in included:
                # new include file detected
                # back up the original
                included.append(inc)
                backup( inc )
                # store original modtime
                modtimes[inc] = os.stat( inc ).st_mtime
                if os.path.isfile(inc):
                    #print " + inlining", inc
                    outf.append('++++ START INLINED INCLUDE FILE ' + match  + ' (DO NOT DELETE THIS LINE!)\n')
                    h = open(inc, 'rb')
                    inc = h.readlines()
                    h.close()
                    # recursive inclusion
                    outf.extend( include_files( inc ))
                    outf.append('---- END INLINED INCLUDE FILE ' + match  + ' (DO NOT DELETE THIS LINE!)\n')
                else:
                    raise SystemExit( "File not found: " + inc )
            else:
                outf.append(line)
        else:
            # no match
            outf.append(line)
    return outf

def split_file( lines, file, level=None ):
    if level == None:
        level = ''
    else:
        level += ' > '

    global suitedir
    global modtimes
    global newfiles

    # check mod time on the target file
    mtime = os.stat( file ).st_mtime
    if mtime != modtimes[file]:
        # oops - original file has changed on disk since we started editing
        f = re.sub( suitedir + '/', '', file )
        file = file + '.EDIT.NEW.' + datetime.datetime.now().isoformat()
    newfiles.append(file)

    inclines = []
    fnew = open( file, 'wb' )
    match_on = False
    for line in lines:
        if not match_on:
            m = re.match('^\+\+\+\+ START INLINED INCLUDE FILE ([\w\/\.\-]+)', line )
            if m:
                match_on = True
                inc_filename = m.groups()[0]
                inc_file = os.path.join( suitedir, m.groups()[0] )
                fnew.write( '%include ' + inc_filename + '\n')
            else:
                fnew.write(line)
        else:
            # match on, go to end of the 'on' include-file
            m = re.match('^\-\-\-\- END INLINED INCLUDE FILE ' + inc_filename, line )
            if m:
                match_on = False
                # now split this lot, in case of nested inclusions
                split_file( inclines, inc_file, level )
                # now empty the inclines list ready for the next inclusion in this file
                inclines = []
            else:
                inclines.append(line)

def backup(src):
    if not os.path.exists(src):
        raise SystemExit( "File not found: " + src )
    bkp = src + '.EDIT.' + datetime.datetime.now().isoformat()
    global backups
    copy( src, bkp )
    backups[ src ] = bkp

parser = OptionParser( """1/ cylc edit SUITE 
       2/ cylc edit -c,--cleanup SUITE
       3/ cylc edit -i,--inline SUITE

1/ Change to the suite definition directory and execute '$EDITOR suite.rc'.
This is merely a convenience so that you can edit the suite without
having to remember or move to the suite definition location.

2/ Remove backup files left by previous inlined edit sessions.

3/ Edit suite config (suite.rc) files with include-files inlined between
special markers, and, after editing split the file up again. This can be
used for quick global suite editing when parameters of interest span
several include-files. Include-files can be nested or multiply-included
(in which case only the first inclusion will be inlined).

If any of the original files are found to have changed while the inlined
file is being edited, you will be warned on exiting the editor and the
affected files will be written to safe backup copies instead of
overwriting the originals.  WARNING: this safety measure notwithstanding
it is recommended that you manage suite definitions with a revision
control system so that (a) you can easily check that new changes are as
you expect, and (b) you can easily back out in case of disaster.

NOTE: in the inlined edit mode you must save and exit the editor
before your changes are applied to the actual suite config files!

The editing process is spawned in the foreground as follows:
  (usage 1/): $EDITOR suite.rc
  (usage 3/): $EDITOR <inlined-suite.rc-file in $TMPDIR>

The $EDITOR and $TMPDIR variables must be defined. Tested with:
   export EDITOR=vim
   export EDITOR='gvim -f'  # -f: do not detach from parent shell!!
   export EDITOR=emacs
   export EDITOR='emacs -nw'

See also:
    cylc grep 
    cylc inline
    cylc validate

Arguments:
  SUITE   - registered name of the target suite.""")

parser.add_option( "--inline", "-i", 
        help="Edit with include-files inlined as described above.",
        action="store_true", default=False, dest="inline" )

parser.add_option( "--cleanup", "-c", 
        help="Remove backup files left by previous inlined edit sessions.",
        action="store_true", default=False, dest="cleanup" )

( options, args ) = parser.parse_args()

if len(args) != 1:
    parser.error( "wrong number of arguments" )

suite = args[0]

try:
    editor = os.environ['EDITOR']
except KeyError:
    raise SystemExit( 'export $EDITOR before using this command' )

# find location of the suite definition directory
global suitedir
reg = registrations()
try:
    suitedir = reg.get( suite )
except RegistrationError,x:
    raise SystemExit(x)

if options.cleanup:
    # remove backup files left by inlined editing sessions
    cleanup( suitedir )
    sys.exit(0)

suiterc = os.path.join( suitedir, 'suite.rc' )

if not options.inline:
    # plain old editing.
    # move to suite def dir
    try:
        os.chdir( suitedir )
    except OSError, x:
        print x
        sys.exit(1)

    # edit the suite.rc file
    if not os.path.isfile( suiterc ):
        print 'ERROR, file not found: ', suiterc
        sys.exit(1)
 
    # in case $EDITOR has options, e.g. 'emacs -nw':
    command_list = re.split( ' ', editor )
    command_list.append( suiterc )
    command = ' '.join( command_list )
    try:
        # THIS BLOCKS UNTIL THE COMMAND COMPLETES
        retcode = subprocess.call( command_list )
        if retcode != 0:
            # the command returned non-zero exist status
            print >> sys.stderr, command, 'failed:', retcode
            sys.exit(1)
    except OSError:
        # the command was not invoked
        print >> sys.stderr, 'ERROR: unable to execute:', command
        sys.exit(1)
 
    # !!!EDITING FINISHED!!!
    sys.exit(0)

# INLINED EDITING

try:
    tmpdir = os.environ['TMPDIR']
except KeyError:
    raise SystemExit( 'export $TMPDIR before using this command' )


# read the suite.rc file
if os.path.isfile( suiterc ):
    # back up the original
    backup( suiterc )
    # record original modtime
    modtimes[suiterc] = os.stat( suiterc ).st_mtime
    # read the file
    h = open( suiterc, 'rb' )
    lines0 = h.readlines()
    h.close()
    # inline any include files
    lines = include_files( lines0 )
else:
    parser.error("File not found: " + suiterc )

# write the inlined suite.rc to a temporary file
editfile = tempfile.mktemp( suffix = ".rc", prefix = suite + '.', dir = tmpdir )
h = open( editfile, 'wb' )
h.writelines( lines )
h.close()

print 'PRE-EDIT BACKUPS:'
for file in backups:
    src = re.sub( suitedir + '/', '', file )
    dst = re.sub( suitedir + '/', '', backups[file] )
    print ' + ' + src + ' ---> ' + dst

# in case $EDITOR has options, e.g. 'emacs -nw':
command_list = re.split( ' ', editor )
command_list.append( editfile )
command = ' '.join( command_list )
try:
    # THIS BLOCKS UNTIL THE COMMAND COMPLETES
    retcode = subprocess.call( command_list )
    if retcode != 0:
        # the command returned non-zero exist status
        print >> sys.stderr, command, 'failed:', retcode
        sys.exit(1)
except OSError:
    # the command was not invoked
    print >> sys.stderr, 'ERROR: unable to execute:', command
    sys.exit(1)
 
# !!!EDITING FINISHED!!!

# read in the edited inlined file
h = open( editfile, 'rb' )
lines = h.readlines()
h.close()

# split it back into separate files
split_file( lines, suiterc )


print '(edited:', editfile, ')'
print 'POST-EDIT FILES WRITTEN:'
for file in newfiles:
    f = re.sub( suitedir + '/', '', file )
    if re.search( '\.EDIT\.NEW\.', f ):
        print ' + ' + f + ' (!!! WARNING: original changed on disk !!!)'
    else:
        print ' + ' + f 

# DONE
