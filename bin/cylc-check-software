#!/usr/bin/env python

# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) 2008-2018 NIWA
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
    cylc-check-software
    Check for external software and version dependencies of cylc.
"""

import sys
import re
from subprocess import check_call, PIPE, Popen, CalledProcessError


TERMINAL_WIDTH = 70

# Standardised output messages
FOUND_NONVERCHECK_MSG = 'FOUND (n/a)'
MINVER_MET_MSG =        'FOUND & min. version MET'
MINVER_NOTMET_MSG =     'FOUND but min. version NOT MET'
FOUND_UNKNOWNVER_MSG =  'FOUND but could not determine version (?)'
NOTFOUND_MSG =          'NOT FOUND (-)'

# Specification of cylc full-funcionality reqs grouped as Python, tex or other
opt_py_spec = {
    'requests': (2, 4, 2),
    'pygtk': (2, 0, 0),
    'OpenSSL': None,
    'urllib3': None,
    'pygraphviz': None
}
opt_tex_spec = [
    'texlive',
    'tocloft',
    'framed',
    'preprint',
    'tex4ht'
]
opt_other_spec = {
    'graphviz': [['dot', '-V'], True],
    'imagemagick': [['magick', 'identify', '-version'], False],
    'tex': [['which'], True]
}

# Requirements for specific (optional i.e. non-core) functionalities
# N.B. ensure modules named as in specification above
functionality_reqs = {
    'HTTPS communications layer': ['OpenSSL', 'requests', 'urllib3'],
    'HTML User Guide': ['imagemagick'],
    'LaTeX User Guide': ['tex'] + opt_tex_spec,
    'cylc GUI & the dependency graph visualisation': ['pygtk', 'graphviz',
                                                      'pygraphviz']
}


def draw_table_line(single_character):
    sys.stdout.write(single_character * TERMINAL_WIDTH + '\n')
    return None


def parse_version(version):
    ret = []
    for sub_version in version.split('.'):
        try:
            ret.append(int(sub_version))
        except ValueError:
            ret.append(sub_version)
    return tuple(ret)


def string_ver(version_tuple):
    return '.'.join(str(x) for x in version_tuple)


def shell_align_write(one_delimiter, left_msg, right_msg):
    """Write 2 messages aligned with left and right of terminal assuming given
       terminal width, with minimum 2-char separation for distinct columns."""
    gap = TERMINAL_WIDTH - len(left_msg) - len(right_msg)
    if gap >= 2:
        sys.stdout.write(left_msg + one_delimiter * gap + right_msg + '\n')
        return True
    else:
        return False


def shell_centre_write(centre_msg):
    """Write message centrally in terminal assuming given terminal width."""
    spacing = int(round(TERMINAL_WIDTH - len(centre_msg)) / 2) * ' '
    sys.stdout.write(spacing + centre_msg + spacing + '\n')
    return None


def check_py_ver(min_ver, max_ver=None):
    """Check if a minimum version of python is installed."""
    if max_ver:
        msg = 'python (%s+, <%s)' % (string_ver(min_ver), string_ver(max_ver))
    else:
        msg = 'python (%s+)' % string_ver(min_ver)
    version = sys.version_info
    ret = (version >= min_ver and (not max_ver or version < max_ver))
    shell_align_write('.', msg, '%s (%s)' % (MINVER_MET_MSG if ret else
                      MINVER_NOTMET_MSG, string_ver(version)))
    return ret


def check_py_module_ver(module, min_ver):
    """Check if a minimum version of a python module is installed."""
    msg = 'python:%s (' % module + '%s)' % (string_ver(min_ver) + '+'
                                            if min_ver != (0,) else 'none')
    try:
        imported_module = __import__(module)
        try:
            # some module imports are awkward so approach like this for now
            if module == 'pygtk':
                import gtk
                version_tuple = gtk.pygtk_version
                module_version = '.'.join(map(str, version_tuple))
            else:
                module_version = imported_module.__version__
            if min_ver == (0,):
                result = ['%s (%s)' % ('FOUND' , module_version), True]
            elif parse_version(module_version) >= min_ver:
                result = ['%s (%s)' % (MINVER_MET_MSG, module_version), True]
            else:
                result = ['%s (%s)' % (MINVER_NOTMET_MSG, module_version),
                          False]
        except AttributeError:
            result = [FOUND_UNKNOWNVER_MSG, False]
    except ImportError:
        result = [NOTFOUND_MSG, False]
    shell_align_write('.', msg, result[0])
    return result[1]


def command_check(package_tag, custom_commands):
    msg = '%s (n/a)' % package_tag
    try:
        check_call(custom_commands, stdout=PIPE, stderr=PIPE)
    except (CalledProcessError, OSError):
        shell_align_write('.', msg, NOTFOUND_MSG)
        return False
    else:
        shell_align_write('.', msg, FOUND_NONVERCHECK_MSG)
        return True


def kpsepath_command(tex_module):
    """Search for tex modules using the 'kpsepath' command. Test line-count
       and not for e.g. non-zero string as 'locate' output can be large."""
    command = ("kpsepath tex | locate '*tex*" + tex_module + "*' | wc -l")
    try:
        init = Popen(command, shell=True, stdout=PIPE, stderr=PIPE)
        init.wait()
        final_command = ['test', init.communicate()[0].strip(), '-ne', '0']     
    except (CalledProcessError, OSError):
        pass
    return command_check('tex:%s' % tex_module, final_command)
    

def custom_command(package, command, append_package=False):
    """Check if some shell command is valid to test for module availability."""
    for component in command:
        if component.count('*') == 0 and not re.match('^[\w-]+$', component):
            raise Exception('Invalid command "%s"' % component)
    if append_package:
        command.append(package)
    return command_check(package, command)


def main():
    """Check external software packages with minimum versions as
       required for both minimal core and fully-functional cylc
       and print user-friendly outcomes from this check."""

    # Introductory message and table header
    sys.stdout.write('Checking your software...\n\nIndividual results:\n')
    draw_table_line('=')
    shell_align_write(' ', 'Package (version requirements)',
                      'Outcome (version found)')
    draw_table_line('=')

    # Required module results section
    shell_centre_write('REQUIRED SOFTWARE')
    # Assinging a variable so don't rewrite to stdout with another call later
    req_result = check_py_ver((2, 6), (3,))
    sys.stdout.write('\n')

    # Optional module results section
    shell_centre_write('OPTIONAL SOFTWARE')
    # Assinging to dictionary so don't rewrite to stdout with more calls later
    opt_result = {}
    for module in opt_py_spec.keys():
        if opt_py_spec[module] is not None:
            opt_result[module] = check_py_module_ver(module,
                                                     opt_py_spec[module])
        else:
            opt_result[module] = check_py_module_ver(module, (0,))
    for module in opt_other_spec.keys():
        opt_result[module] = custom_command(module, opt_other_spec[module][0],
                                            opt_other_spec[module][1])
    for module in opt_tex_spec:
        opt_result[module] = kpsepath_command(module)
    draw_table_line('=')
    sys.stdout.write('\n')

    # Print-out of specific results for core and optional functionalities
    sys.stdout.write('Overall result:\n')
    if req_result:
        req_words = ['ok', '', '&', ' also', '', ' also', '*however*']
    else:
        reqfail_text = ' once core requirements are installed,'
        req_words = ['not ok', ' not', 'but otherwise', '', reqfail_text,
                     '', '& additionally' + reqfail_text]
    shell_centre_write('You do%s have the required packages meeting minimum' %
                       req_words[1])
    shell_centre_write('version requirements, so core cylc will%s work' %
                       req_words[1])
    failed_func = []
    for functionality in functionality_reqs.keys():
        for module in functionality_reqs[functionality]:
            if not opt_result[module]:
                failed_func.append(functionality)
                break
    if len(failed_func) == 0:
        shell_centre_write('%s you have%s satisfied all optional package '
                           'requirements' % (req_words[2], req_words[3]))
        shell_centre_write('so%s all non-essential but recommended aspects '
                           'of' % req_words[4])
        shell_centre_write('cylc will%s work with full functionality.' %
                           req_words[5])
    else:
        shell_centre_write('%s' % req_words[6])
        shell_centre_write('due to lack of &/or sub-minimal versions for '
                           'optional software (see ')
        shell_centre_write("'individual results'), the following "
                           'non-essential but recommended')
        shell_centre_write('aspect%s of cylc will not work with full '
                           'functionality:\n' % ('s' if len(failed_func) > 1
                                                 else ''))
        for functionality in enumerate(failed_func, 1):
            shell_centre_write('%s) %s' % functionality)
    sys.stdout.write('\n')

    # Final summary print for clear pass/fail final outcome
    sys.stdout.write('Summary:\n')
    shell_centre_write('*' * 28)
    shell_centre_write('Requirements: %s' % req_words[0])
    shell_centre_write('Full-functionality: %s' % ('ok' if
                                                   len(failed_func) == 0 else
                                                   'not ok'))
    shell_centre_write('*' * 28)

    sys.exit()


if __name__ == '__main__':
    if 'help' in sys.argv or '--help' in sys.argv:
        print __doc__
    else:
        main()
