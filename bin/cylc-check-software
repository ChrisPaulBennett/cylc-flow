#!/usr/bin/env python

# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) 2008-2018 NIWA
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
    cylc-check-software
    Check for external software and version dependencies of cylc.
"""

import sys
import re
from subprocess import check_call, PIPE, Popen, CalledProcessError


# Standardised output messages
FOUND_NONVERCHECK_MSG = 'FOUND (n/a)'
MINVER_MET_MSG = 'FOUND & min. version MET'
MINVER_NOTMET_MSG = 'FOUND but min. version NOT MET'
FOUND_UNKNOWNVER_MSG = 'FOUND but could not determine version (?)'
NOTFOUND_MSG = 'NOT FOUND (-)'

opt_result = {}

# Specification of cylc full-functionality reqs grouped Python, tex or other
# Item format <PACKAGE>: [<VER REQ>, <FUNC TAG>, <GROUP>(, <'OTHER' COMMAND>)]
req_py_ver_range = (2, 6), (3,)
opt_spec = {
    'requests': [(2, 4, 2), 'HTTPScomms', 'py'],
    'OpenSSL': [None, 'HTTPScomms', 'py'],
    'urllib3': [None, 'HTTPScomms', 'py'],
    'pygtk': [(2, 0, 0), 'GUIorgraph', 'py'],
    'pygraphviz': [None, 'GUIorgraph', 'py'],
    'graphviz': [None, 'GUIorgraph', 'other', ['dot', '-V', 'graphviz']],
    'TeX': [None, 'LaTeXguide', 'other', ['which', 'tex']],
    'texlive': [None, 'LaTeXguide', 'tex'],
    'tocloft': [None, 'LaTeXguide', 'tex'],
    'framed': [None, 'LaTeXguide', 'tex'],
    'preprint': [None, 'LaTeXguide', 'tex'],
    'tex4ht': [None, 'LaTeXguide', 'tex'],
    'imagemagick': [None, 'HTMLuguide', 'other', ['magick', 'identify',
                                                  '-version']]
}

# Package-dep. functionality dict; item format <SHORT TAG>: <FULL DESCRIPTION>
func_tags_and_text = {
    'HTTPScomms': 'HTTPS communications layer',
    'GUIorgraph': 'GUI & dependency graph visualisation',
    'LaTeXguide': 'LaTeX User Guide',
    'HTMLuguide': 'HTML User Guide'
}


def terminal_width(default_width=70, min_width=50):
    """Return the terminal width or a specified minimum width if larger."""
    proc = Popen(['stty', 'size'], stdout=PIPE)
    if proc.wait():
        return default_width
    else:
        try:
            return max(min_width, int(proc.communicate()[0].split()[1]))
        except IndexError:
            return default_width


def draw_table_line(single_character):
    sys.stdout.write(single_character * terminal_width() + '\n')
    return None


def parse_version(version):
    ret = []
    for sub_version in version.split('.'):
        try:
            ret.append(int(sub_version))
        except ValueError:
            ret.append(sub_version)
    return tuple(ret)


def string_ver(version_tuple):
    return '.'.join(str(x) for x in version_tuple)


def shell_align_write(one_delimiter, left_msg, right_msg):
    """Write two messages aligned with the terminal edges, separated by a
       given delimiter, with a minimum separation of two characters."""
    gap = terminal_width() - len(left_msg) - len(right_msg)
    if gap >= 2:
        sys.stdout.write(left_msg + one_delimiter * gap + right_msg + '\n')
        return True
    else:
        return False


def shell_centre_write(prepend_newline, *args):
    """Write one or more lines of text centrally in the terminal."""
    if prepend_newline:
        sys.stdout.write('\n')
    for msg_line in args:
        spacing = int(round(terminal_width() - len(msg_line)) / 2) * ' '
        sys.stdout.write(spacing + msg_line + spacing + '\n')
    return


def check_py_ver(min_ver, max_ver=None):
    """Check if a version of Python within a specified range is installed."""
    if max_ver:
        msg = 'python (%s+, <%s)' % (string_ver(min_ver), string_ver(max_ver))
    else:
        msg = 'python (%s+)' % string_ver(min_ver)
    version = sys.version_info
    ret = (version >= min_ver and (not max_ver or version < max_ver))
    shell_align_write('.', msg, '%s (%s)' % (MINVER_MET_MSG if ret else
                      MINVER_NOTMET_MSG, string_ver(version)))
    return ret


def check_py_module_ver(module, min_ver=None):
    """Check if a minimum version of a Python module is installed."""
    if not min_ver:
        min_ver = (0,)
    msg = 'python:%s (' % module + '%s)' % (string_ver(min_ver) + '+'
                                            if min_ver != (0,) else 'none')
    try:
        imported_module = __import__(module)
        try:
            # some module imports are awkward so approach like this for now
            if module == 'pygtk':
                import gtk
                version_tuple = gtk.pygtk_version
                module_version = '.'.join(map(str, version_tuple))
            else:
                module_version = imported_module.__version__
            if min_ver == (0,):
                result = ['%s (%s)' % ('FOUND', module_version), True]
            elif parse_version(module_version) >= min_ver:
                result = ['%s (%s)' % (MINVER_MET_MSG, module_version), True]
            else:
                result = ['%s (%s)' % (MINVER_NOTMET_MSG, module_version),
                          False]
        except AttributeError:
            result = [FOUND_UNKNOWNVER_MSG, False]
    except ImportError:
        result = [NOTFOUND_MSG, False]
    shell_align_write('.', msg, result[0])
    return result[1]


def command_check(package_tag, custom_commands):
    """Call a module-checking command and print relevant outcome message."""
    msg = '%s (n/a)' % package_tag
    try:
        check_call(custom_commands, stdout=PIPE, stderr=PIPE)
    except (CalledProcessError, OSError):
        shell_align_write('.', msg, NOTFOUND_MSG)
        return False
    else:
        shell_align_write('.', msg, FOUND_NONVERCHECK_MSG)
        return True


def kpsepath_command(tex_module):
    """Print outcome of local TeX module search using 'kpsepath' command."""
    # Test line-count; 'locate' output can be >> for acc. string-length test
    command = ("kpsepath tex | locate '*tex*" + tex_module + "*' | wc -l")
    try:
        init = Popen(command, shell=True, stdout=PIPE, stderr=PIPE)
        init.wait()
        final_command = ['test', init.communicate()[0].strip(), '-ne', '0']
    except (CalledProcessError, OSError):
        pass
    return command_check('TeX:%s' % tex_module, final_command)


def custom_command(package, command):
    """Print outcome of local module search using custom command provided."""
    for component in command:
        if component.count('*') == 0 and not re.match('^[\w-]+$', component):
            raise Exception('Invalid command "%s"' % component)
    return command_check(package, command)


def functionality_print(func):
    """Apply and print outcome of searches, applied by relevant group, for all
       modules including minimum versions necessary for some funcionality."""
    for module, item_list in opt_spec.items():
        ver_req, func_dep, tag = item_list[:3]
        if func_dep == func:
            if tag == 'py':
                opt_result[module] = check_py_module_ver(module, ver_req)
            elif tag == 'tex':
                opt_result[module] = kpsepath_command(module)
            else:
                opt_result[module] = custom_command(module, item_list[3])
    return


def main():
    """Test for and print external software packages with minimum versions
       as required for both minimal core and fully-functional cylc."""

    # Introductory message and individual results table header
    sys.stdout.write('Checking your software...\n\nIndividual results:\n')
    draw_table_line('=')
    shell_align_write(' ', 'Package (version requirements)',
                      'Outcome (version found)')
    draw_table_line('=')

    # Individual results section in mock-table format
    shell_centre_write(False, '*REQUIRED SOFTWARE*')
    req_result = check_py_ver(*req_py_ver_range)
    for tag, text in func_tags_and_text.items():
        shell_centre_write(True, '*OPTIONAL SOFTWARE for the ' + text + '*')
        functionality_print(tag)
    draw_table_line('=')

    # Final summary print for clear pass/fail final outcome and exit
    sys.stdout.write('\nSummary:')
    shell_centre_write(True, '*' * 28, 'Core requirements: %s' % 'ok' if
                       req_result else 'not ok', 'Full-functionality: %s'
                       % ('ok' if all(opt_result.values()) else 'not ok'),
                       '*' * 28)
    sys.exit()


if __name__ == '__main__':
    if 'help' in sys.argv or '--help' in sys.argv:
        print __doc__
    else:
        main()
