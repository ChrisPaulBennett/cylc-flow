#!/usr/bin/env python

# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) 2008-2018 NIWA
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
    cylc-check-software
    Check for external software and version dependencies of cylc.
"""

import sys
import re
from subprocess import check_call, PIPE, Popen, CalledProcessError


TERMINAL_WIDTH = 70

# Standardised output messages
FOUND_NONVERCHECK_MSG = 'FOUND (n/a)'
MINVER_MET_MSG =        'FOUND & min. version MET'
MINVER_NOTMET_MSG =     'FOUND but min. version NOT MET'
FOUND_UNKNOWNVER_MSG =  'FOUND but could not determine version (?)'
NOTFOUND_MSG =          'NOT FOUND (-)'

func_tags_and_text = {
    'HTTPScomms': 'HTTPS communications layer',
    'GUIorgraph': 'GUI & dependency graph visualisation',
    'LaTeXguide': 'LaTeX User Guide',
    'HTMLuguide': 'HTML User Guide'
}

# Specification of cylc full-funcionality reqs grouped as Python, tex or other
# Item format <MODULE>: [<VER REQ>, <FUNC DEP>, <GROUP>(, <'OTHER' COMMAND>)]
req_py_ver_min, req_py_ver_max = (2, 6), (3,)
opt_spec = {
    'requests': [(2, 4, 2), 'HTTPScomms', 'py'],
    'OpenSSL': [None, 'HTTPScomms', 'py'],
    'urllib3': [None, 'HTTPScomms', 'py'],
    'pygtk': [(2, 0, 0), 'GUIorgraph', 'py'],
    'pygraphviz': [None, 'GUIorgraph', 'py'],
    'graphviz': [None, 'GUIorgraph', 'other', ['dot', '-V', 'graphviz']],
    'tex': [None, 'LaTeXguide', 'other', ['which', 'tex']],
    'texlive': [None, 'LaTeXguide', 'tex'],
    'tocloft': [None, 'LaTeXguide', 'tex'],
    'framed': [None, 'LaTeXguide', 'tex'],
    'preprint': [None, 'LaTeXguide', 'tex'],
    'tex4ht': [None, 'LaTeXguide', 'tex'],
    'imagemagick': [None, 'HTMLuguide', 'other', ['magick', 'identify',
                                                  '-version']]
}


def draw_table_line(single_character):
    sys.stdout.write(single_character * TERMINAL_WIDTH + '\n')
    return None


def parse_version(version):
    ret = []
    for sub_version in version.split('.'):
        try:
            ret.append(int(sub_version))
        except ValueError:
            ret.append(sub_version)
    return tuple(ret)


def string_ver(version_tuple):
    return '.'.join(str(x) for x in version_tuple)


def shell_align_write(one_delimiter, left_msg, right_msg):
    """Write 2 messages aligned with left and right of terminal assuming set
       terminal width, with minimum 2-char separation for distinct columns."""
    gap = TERMINAL_WIDTH - len(left_msg) - len(right_msg)
    if gap >= 2:
        sys.stdout.write(left_msg + one_delimiter * gap + right_msg + '\n')
        return True
    else:
        return False


def shell_centre_write(prepend_newline, *args):
    """Write message(s) centrally in terminal assuming set terminal width."""
    if prepend_newline:
        sys.stdout.write('\n')
    for msg_line in args:
        spacing = int(round(TERMINAL_WIDTH - len(msg_line)) / 2) * ' '
        sys.stdout.write(spacing + msg_line + spacing + '\n')
    return


def check_py_ver(min_ver, max_ver=None):
    """Check if a minimum version of python is installed."""
    if max_ver:
        msg = 'python (%s+, <%s)' % (string_ver(min_ver), string_ver(max_ver))
    else:
        msg = 'python (%s+)' % string_ver(min_ver)
    version = sys.version_info
    ret = (version >= min_ver and (not max_ver or version < max_ver))
    shell_align_write('.', msg, '%s (%s)' % (MINVER_MET_MSG if ret else
                      MINVER_NOTMET_MSG, string_ver(version)))
    return ret


def check_py_module_ver(module, min_ver):
    """Check if a minimum version of a python module is installed."""
    if not min_ver:
        min_ver = (0,)
    msg = 'python:%s (' % module + '%s)' % (string_ver(min_ver) + '+'
                                            if min_ver != (0,) else 'none')
    try:
        imported_module = __import__(module)
        try:
            # some module imports are awkward so approach like this for now
            if module == 'pygtk':
                import gtk
                version_tuple = gtk.pygtk_version
                module_version = '.'.join(map(str, version_tuple))
            else:
                module_version = imported_module.__version__
            if min_ver == (0,):
                result = ['%s (%s)' % ('FOUND' , module_version), True]
            elif parse_version(module_version) >= min_ver:
                result = ['%s (%s)' % (MINVER_MET_MSG, module_version), True]
            else:
                result = ['%s (%s)' % (MINVER_NOTMET_MSG, module_version),
                          False]
        except AttributeError:
            result = [FOUND_UNKNOWNVER_MSG, False]
    except ImportError:
        result = [NOTFOUND_MSG, False]
    shell_align_write('.', msg, result[0])
    return result[1]


def command_check(package_tag, custom_commands):
    msg = '%s (n/a)' % package_tag
    try:
        check_call(custom_commands, stdout=PIPE, stderr=PIPE)
    except (CalledProcessError, OSError):
        shell_align_write('.', msg, NOTFOUND_MSG)
        return False
    else:
        shell_align_write('.', msg, FOUND_NONVERCHECK_MSG)
        return True


def kpsepath_command(tex_module):
    """Search for tex modules using the 'kpsepath' command. Test line-count
       and not for e.g. non-zero string as 'locate' output can be large."""
    command = ("kpsepath tex | locate '*tex*" + tex_module + "*' | wc -l")
    try:
        init = Popen(command, shell=True, stdout=PIPE, stderr=PIPE)
        init.wait()
        final_command = ['test', init.communicate()[0].strip(), '-ne', '0']     
    except (CalledProcessError, OSError):
        pass
    return command_check('tex:%s' % tex_module, final_command)
    

def custom_command(package, command):
    """Check if some shell command is valid to test for module availability."""
    for component in command:
        if component.count('*') == 0 and not re.match('^[\w-]+$', component):
            raise Exception('Invalid command "%s"' % component)
    return command_check(package, command)


opt_result = {}
def functionality_print(func):
    for module, item_list in opt_spec.items():
        ver_req, func_dep, tag = item_list[:3]
        if func_dep == func:
           if tag == 'py':
               opt_result[module] = check_py_module_ver(module, ver_req)
           elif tag == 'tex':
               opt_result[module] = kpsepath_command(module)
           else:
               opt_result[module] = custom_command(module, item_list[3])
    return

def opt_software_table(func_tag, func_text):
    shell_centre_write(True, '*OPTIONAL SOFTWARE for the ' + func_text + '*')
    functionality_print(func_tag)
    return


def main():
    """Test for and print external software packages with minimum versions
       as required for both minimal core and fully-functional cylc."""

    # Introductory message and individual results table header
    sys.stdout.write('Checking your software...\n\nIndividual results:\n')
    draw_table_line('=')
    shell_align_write(' ', 'Package (version requirements)',
                      'Outcome (version found)')
    draw_table_line('=')

    # Individual results section in mock-table format
    shell_centre_write(False, '*REQUIRED SOFTWARE*')
    req_result = check_py_ver(req_py_ver_min, req_py_ver_max)
    for key, value in func_tags_and_text.items():
        opt_software_table(key, value)
    draw_table_line('=')

    # Final summary print for clear pass/fail final outcome and exit
    sys.stdout.write('\nSummary:')
    shell_centre_write(True, '*' * 28, 'Core requirements: %s' % 'ok' if
                       req_result else 'not ok', 'Full-functionality: %s'
                       % ('ok' if all(opt_result.values()) else 'not ok'),
                       '*' * 28)
    sys.exit()


if __name__ == '__main__':
    if 'help' in sys.argv or '--help' in sys.argv:
        print __doc__
    else:
        main()
