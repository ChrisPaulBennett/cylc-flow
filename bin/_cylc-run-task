#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# standard Python modules
import re, os, sys
import datetime
import logging
from time import sleep
from optparse import OptionParser
from dynamic_instantiation import get_object
from interp_env import interp_self, interp_local, replace_delayed
from job_submit import job_submit

# cycl source modules
from registration import registrations
import cycle_time
import pimp_my_logger

usage = """cylc run-task [options] SYSTEM

Run a single task just as the scheduler would run it. This can be used
as an easy way to invoke single system tasks for any reason, but it is
particularly useful for testing external task scripts during the system
development phase. When the cylc messaging interface is invoked by
standalone tasks it simply directs all messages to stdout.

arguments:
   SYSTEM     Registered name of the target system.""" 

def commandline_parser():
    parser = OptionParser( usage )

    parser.add_option( "-t", "--task",
            help="ID of the task to run.",
            metavar="TASK%CYCLE", action="store", dest="task_id" )

    parser.add_option( "-d", "--dry-run",
            help="Generate the cylc job submission file for the "
            "task and report how it would be submitted to run.",
            action="store_true", default=False, dest="dry_run" )

    return parser

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

# get system name------------------------------------------------------
name = args[0]

# get task ------------------------------------------------------------
if not options.task_id:
    parser.error( "Please specify which task to run" )
else:
    task_id = options.task_id

( task_name, ctime ) = task_id.split( '%' )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

# find location of the system task and config modules------------------
reg = registrations()
if reg.is_registered( name ):
    system_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "System " + name + " is not registered!" )

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.

# add system scripts to $PATH
os.environ[ 'PATH' ] += ':' + system_dir + '/scripts'
# add system Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + system_dir

# provide access to the system source modules for THIS program---------
sys.path.append( system_dir )

# import system-specific cylc modules now------------------------------ 
from system_config import system_config 
import task
import remote_switch

# load system configuration--------------------------------------------
config = system_config( name )
config.put( 'logging_dir', config.get('logging_dir') + '-run-task' ) 
config.create_logging_dir( False )
config.job_submit_config()

# create the task log
log = logging.getLogger( 'main.' + task_name )
pimp_my_logger.pimp_it( log, task_name, config.get('logging_dir'), \
        logging.DEBUG, False, None )

# set global (all tasks) environment variables-------------------------
config.put_env( 'CYLC_MODE', 'run-task' )
config.put_env( 'CYLC_NS_HOST', 'NOT USED BY RUN-TASK' ) 
config.put_env( 'CYLC_NS_GROUP', 'NOT USED BY RUN-TASK' )
config.put_env( 'CYLC_DIR', os.environ[ 'CYLC_DIR' ] )
config.put_env( 'CYLC_SYSTEM_DIR', system_dir )
config.put_env( 'CYLC_SYSTEM_NAME', name )

# intantiate the task--------------------------------------------------
global_env = config.get('environment')
global_env = interp_self( global_env )
global_env = interp_local( global_env )
global_env = replace_delayed( global_env )
job_submit.global_env = global_env
 
jsc = config.get('job submit class')
clsmod = __import__( 'task_classes' )
cls = getattr( clsmod, task_name )
setattr( cls, 'job_submit_method', jsc[ task_name ] )

task = get_object( 'task_classes', task_name )( ctime, 'waiting', startup=True )

# SUBMIT THE TASK TO RUN-----------------------------------------------
task.run_external_task( options.dry_run )
