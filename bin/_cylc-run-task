#!/usr/bin/python

# standard Python modules
import re, os, sys, shutil
import datetime
import logging
from time import sleep
from optparse import OptionParser
from dynamic_instantiation import get_object

# cycl source modules
import cycle_time
import pimp_my_logger

usage = """cylc run-task [-t TASK] [-c CYCLE] SYSTEM

Submit a single task just as the scheduler would, but without running
the scheduler. This can be used as an easy way to invoke single system
tasks for any reason, but it is particularly useful for testing external
task scripts during the development phase when you are defining the
interface between cylc and your forecasting system.

arguments:
   SYSTEM     Registered name of the target system.""" 

def commandline_parser():
    parser = OptionParser( usage )

    parser.add_option( "-t", 
            help="Name of the task to run.",
            metavar="TASK", action="store", dest="task_name" )

    parser.add_option( "-c", 
            help="Task cycle time (YYYYMMDDHH).",
            metavar="CYCLE", action="store", dest="ctime" )

    return parser

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

# get system name------------------------------------------------------
reg_name = args[0]

# get task name--------------------------------------------------------
if not options.task_name:
    parser.error( "Please supply a task name" )
else:
    task_name = options.task_name

# get cycle time-=-----------------------------------------------------
if not options.ctime:
    parser.error( "Please supply a cycle time" )
else:
    ctime = options.ctime

if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

# find location of the system task and config modules------------------
registration_file = os.environ['HOME'] + '/.cylc/registered/' + reg_name
if os.path.exists( registration_file ):
    FILE = open( registration_file, 'r' )
    line = FILE.read()
    system_dir = line.rstrip() 
    FILE.close()
else:
    raise SystemExit( "No such system name registered: " + reg_name )

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.
print system_dir
# add system scripts to $PATH
os.environ[ 'PATH' ] += ':' + system_dir + '/scripts'
# add system Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + system_dir

# provide access to the system source modules for THIS program---------
sys.path.append( system_dir )

# import system-specific cylc modules now------------------------------ 
import system_config # loads config_defaults.py and config_override.py 
import task_base     # loads system_tasks.py
import remote_switch # ditto

# load system configuration--------------------------------------------
config = system_config.system_config( reg_name )

# logging dir
logging_dir = config.get('logging_dir')

# set up main log already, for use in this module
log = logging.getLogger( 'main' )
pimp_my_logger.pimp_it( \
        log, 'main', config.get('logging_dir'), \
        config.get('logging_level'), False, None )

# intantiate the task
task = get_object( 'system_tasks', task_name ) \
        ( ctime, False, 'waiting', config.get('job submit class')[ task_name ], True )

# create the task log
log = logging.getLogger( 'main.' + task_name )
pimp_my_logger.pimp_it( log, task_name, config.get('logging_dir'), \
        config.get('logging_level'), False, None )

# set global (all tasks) environment variables-------------------------
os.environ[ 'CYLC_NS_HOST' ] = 'NULL'
os.environ[ 'CYLC_NS_GROUP' ] = 'NULL'

# extra global vars set in the system config file
env = config.get('environment')
for VAR in env.keys():
    #print "! setting", VAR, '=', env[VAR]
    os.environ[ VAR ] = str( env[ VAR ] )

task.run_external_task()

