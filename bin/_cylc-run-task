#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# standard Python modules
import re, os, sys, datetime, socket, logging
from time import sleep
from optparse import OptionParser

# cycl source modules
from dynamic_instantiation import get_object
from registration import registrations
from job_submit import job_submit
import pyrex, cycle_time, pimp_my_logger
import cylcrc
from lockserver import syslock

usage = """cylc run-task [options] SYSTEM

Run a single task just as the scheduler would run it. This can be used
as an easy way to invoke single system tasks for any reason, but it is
particularly useful for testing external task scripts during the system
development phase. When the cylc messaging interface is invoked by
standalone tasks it simply directs all messages to stdout.

arguments:
   SYSTEM     Registered name of the target system.""" 

def commandline_parser():
    parser = OptionParser( usage )

    parser.set_defaults( pns_host= socket.getfqdn() )

    parser.add_option( "-t", "--task",
            help="ID of the task to run.",
            metavar="TASK%CYCLE", action="store", dest="task_id" )

    parser.add_option( "-d", "--dry-run",
            help="Generate the cylc task execution file for the "
            "task and report how it would be submitted to run.",
            action="store_true", default=False, dest="dry_run" )

    parser.add_option( "--host",
            help="Pyro nameserver host, defaults to the local hostname. Use "
            "if not auto-detected (which depends on network config).", 
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "--rcfile", help="Use an alternative cylc rc file "
            "(default $HOME/.cylcrc).", default=None,
            metavar="PATH", action="store", dest="rcfile" )

    return parser

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

# get system name------------------------------------------------------
name = args[0]

# find location of the system task and config modules------------------
reg = registrations()
if reg.is_registered( name ):
    system_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "System " + name + " is not registered!" )

# get task ------------------------------------------------------------
if not options.task_id:
    parser.error( "Please specify which task to run" )
else:
    task_id = options.task_id

( task_name, ctime ) = task_id.split( '%' )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

# get Pyro nameserver hostname-----------------------------------------
if not options.pns_host:
    # (this won't happen; defaults to local hostname)
    parser.error( "Required: Pyro nameserver hostname" )
else:
    pns_host = options.pns_host


groupname = os.environ['USER'] + '^' + name

# load cylcrc file----------------------------------------------------
rcfile = cylcrc.rc( options.rcfile )
logging_dir = rcfile.get_system_logging_dir( name + '-run-task' ) 

use_lockserver = False
if rcfile.get( 'cylc', 'use lockserver' ) == 'True':
    use_lockserver = True
    # request system access from the lock server
    # run-task does not need to call release_system_access()
    if not syslock( pns_host, groupname, system_dir, 'run-task' ).request_system_access():
        raise SystemExit( 'locked out!' )

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.

# add system scripts to $PATH
os.environ[ 'PATH' ] += ':' + system_dir + '/scripts'
# add system Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + system_dir

# provide access to the system source modules for THIS program---------
sys.path.append( system_dir )

# import system-specific cylc modules now------------------------------ 
from system_config import system_config 
import task
import remote_switch

# load system configuration--------------------------------------------
config = system_config( name )
config.put( 'logging_dir', logging_dir ) 
config.job_submit_config()

# create the task log
log = logging.getLogger( 'main.' + task_name )
pimp_my_logger.pimp_it( log, task_name, logging_dir, \
        logging.DEBUG, False, None, True )

# LOCATE THE PYRO NAMESERVER-------------------------------------------
# (required for system locking)
nameserver = pyrex.discover( pns_host )

# set global (all tasks) environment variables-------------------------
config.put_env( 'CYLC_MODE', 'run-task' )
config.put_env( 'CYLC_NS_HOST', pns_host ) 
config.put_env( 'CYLC_NS_GROUP', groupname )
config.put_env( 'CYLC_DIR', os.environ[ 'CYLC_DIR' ] )
config.put_env( 'CYLC_SYSTEM_DIR', system_dir )
config.put_env( 'CYLC_SYSTEM_NAME', name )
config.put_env( 'CYLC_USE_LOCKSERVER', str( use_lockserver) )

config.check_environment()
job_submit.global_env = config.get( 'environment' )

jsc = config.get('job submit class')
clsmod = __import__( 'task_classes' )
cls = getattr( clsmod, task_name )
setattr( cls, 'job_submit_method', jsc[ task_name ] )

# intantiate the task--------------------------------------------------
task = get_object( 'task_classes', task_name )( ctime, 'waiting', startup=True )

# SUBMIT THE TASK TO RUN-----------------------------------------------
print
if not options.dry_run:
    print "Cylc messages will be directed to stdout (=> the task log file)."
    print "Logging directory is " + logging_dir
    print
task.run_external_task( options.dry_run )
print
