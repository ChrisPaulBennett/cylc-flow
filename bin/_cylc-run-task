#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# standard Python modules
import re, os, sys
import datetime
import logging
from time import sleep
from optparse import OptionParser
from dynamic_instantiation import get_object

# cycl source modules
from registration import registrations
import cycle_time
import pimp_my_logger

usage = """cylc run-task [options] SYSTEM

Run a single task just as the scheduler would run it. This can be used
as an easy way to invoke single system tasks for any reason, but it is
particularly useful for testing external task scripts during the system
development phase. When the cylc messaging interface is invoked by
standalone tasks it simply directs all messages to stdout.

arguments:
   SYSTEM     Registered name of the target system.""" 

def commandline_parser():
    parser = OptionParser( usage )

    parser.add_option( "-t", "--task",
            help="ID of the task to run.",
            metavar="TASK%CYCLE", action="store", dest="task_id" )

    return parser

# parse commandline options and arguments------------------------------
parser = commandline_parser()
( options, args ) = parser.parse_args()

if len( args ) == 0:
    parser.error( "Please supply a target system name" )
elif len( args ) > 1:
    parser.error( "Too many arguments" )

# get system name------------------------------------------------------
name = args[0]

# get task ------------------------------------------------------------
if not options.task_id:
    parser.error( "Please specify which task to run" )
else:
    task_id = options.task_id

( task_name, ctime ) = task_id.split( '%' )
if not cycle_time.is_valid( ctime ):
    parser.error( "invalid cycle time: " + ctime )

# find location of the system task and config modules------------------
reg = registrations()
if reg.is_registered( name ):
    system_dir = reg.get( name )
else:
    reg.print_all()
    raise SystemExit( "System " + name + " is not registered!" )

# provide access to the system scripts and source modules--------------
# for external processes launched by this program.
print system_dir
# add system scripts to $PATH
os.environ[ 'PATH' ] += ':' + system_dir + '/scripts'
# add system Python modules to $PYTHONPATH
os.environ[ 'PYTHONPATH' ] += ':' + system_dir

# provide access to the system source modules for THIS program---------
sys.path.append( system_dir )

# import system-specific cylc modules now------------------------------ 
from system_config import system_config 
import task     # loads task_classes.py
import remote_switch # ditto

# load system configuration--------------------------------------------
config = system_config( name )
config.put( 'logging_dir', config.get('logging_dir') + '-run-task' ) 
config.create_logging_dir( False )
config.job_submit_config()

# create the task log
log = logging.getLogger( 'main.' + task_name )
pimp_my_logger.pimp_it( log, task_name, config.get('logging_dir'), \
        logging.DEBUG, False, None )

# set global (all tasks) environment variables-------------------------
config.put_env( 'CYLC_MODE', 'run-task' )
config.put_env( 'CYLC_NS_HOST',  'NULL' )  # may be an IP number
config.put_env( 'CYLC_NS_GROUP',  'NULL' )
config.put_env( 'CYLC_DIR', os.environ[ 'CYLC_DIR' ] )
config.put_env( 'CYLC_SYSTEM_DIR', system_dir )
config.put_env( 'CYLC_SYSTEM_NAME', name )

# intantiate the task--------------------------------------------------
glbl_env = config.get('environment')
job_sub_method = config.get('job submit class')[ task_name ]
launcher = get_object( 'job_submit_methods', job_sub_method )( False, glbl_env )
task = get_object( 'task_classes', task_name )( ctime, 'waiting', launcher, startup=True )

# SUBMIT THE TASK TO RUN-----------------------------------------------
task.run_external_task()
