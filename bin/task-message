#!/usr/bin/python

""" 
Standalone interface between external EcoConnect tasks/models and the
task objects that represent them in the controller.

Sends a message to a task proxy object in a cyclon instance, by calling
[task object].incoming(<priority>, <message>). The task is identified by
its unique task ID, <NAME>%<REFTIME>.
"""

import os
import sys
import Pyro.core
import config
from optparse import OptionParser

# construct a command line parser
parser = OptionParser( "%prog [options] <message>\n" )

parser.add_option( "-p", "--priority", 
        metavar="PRIORITY",
        help="message priority "
             "(NORMAL, WARNING, CRITICAL) "
             "defaults to NORMAL.",
        action="store", dest="priority" )

parser.add_option( "-n", "--name", 
        metavar='TASKNAME',
        help="task name, defaults to $TASK_NAME",
        action="store", dest="taskname" )

parser.add_option( "-r", "--reftime", 
        metavar="YYYYMMDDHH",
        help="task reference time, defaults to $REFERENCE_TIME",
        action="store", dest="reftime" )

# get command line options and positional args
( options, args ) = parser.parse_args()

#if not options.priority or not options.taskname or not options.reftime:
#    parser.error( "options -p, -t, -r are not optional!" )

if options.priority:
    priority = options.priority
else:
    # Default to NORMAL
    priority = 'NORMAL'

if options.taskname:
    taskname = options.taskname
else:
    # Default to $TASK_NAME
    if 'TASK_NAME' in os.environ.keys():
        taskname = os.environ[ 'TASK_NAME' ]
    else:
        print 'ERROR, task-message: no task name provided!'
        sys.exit(1)
    
if options.reftime:
    reftime = options.reftime
else:
    # Default to $REFERENCE_TIME
    if 'REFERENCE_TIME' in os.environ.keys():
        reftime = os.environ[ 'REFERENCE_TIME' ]
    else:
        print 'ERROR, task-message: no reference time provided!'
        sys.exit(1)
 
if len( args ) == 0:
    parser.error( "no message supplied" )
elif len( args ) == 1:
    # user sent a quoted string
    message = args[0]
else:
    # user sent a bar string, so join all the words together
    message = ' '.join(args)

# load the configured system (the system's enviroment.sh script must
# have been sourced in the current shell)
config = config.config()
config.user_override()
config.check()

# TO DO: use exception handling when I know how to report the real error
# (which is generally more useful than my own error message)

# connect to the task object inside the control program
#try:
task = Pyro.core.getProxyForURI('PYRONAME://' +  config.get('system_name') + '.' + taskname + '%' + reftime )
task.incoming( priority, message )
#except:
#    # nameserver not found, or object not registered with it?
#    print "ERROR: failed to connect to " + task_name + "_" + ref_time
#    print "Trying dead letter box"

#    try:
#        dead_box = Pyro.core.getProxyForURI('PYRONAME://' + config.get('system_name') + '.' + 'dead_letter_box' )
#        dead_box.incoming( message )
#    except:
#        # nameserver not found, or object not registered with it?
#        print "ERROR: failed to connect to pyro nameserver"
#        sys.exit(1)
