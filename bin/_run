#!/usr/bin/env python

import sys
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

global debug
debug = True

class start( scheduler ):
    def __init__( self ):
        usage = """cylc [control] run|start [options] SUITE YYYYMMDDHHH

Start a suite running at a specified initial cycle time. To restart a
suite from a previous state (which may contain tasks at multiple cycle
times), see 'cylc restart SUITE'.

There are three startup modes that differ in how initial intercycle
dependencies are handled (at startup there is no previous cycle for
tasks, such as warm cycled forecast models, that normally depend on
tasks in previous cycles): 
  1/ Cold start (the default) -- start from scratch with special tasks 
  2/ Warm start (-w,--warm)   -- assume a previous cycle 
  3/ Raw  start (-r,--raw)    -- assume nothing
(These are all the same for a suite that has no intercycle dependencies).

1/ COLDSTART -- start from scratch, with special oneoff "coldstart
tasks" to satisfy the initial dependencies of any tasks that normally
depend on tasks from a previous cycle (most notably the restart
dependencies of warm cycled forecast models). Coldstart tasks
can run real processes (e.g. a special forecast to generate the initial
restart files for a warm cycled model) or, with no task command defined,
just act as a dummy proxy for some external process that has to occur
before the suite is started (e.g. a spinup run of some kind). For a
suite with no intercycle dependencies there is no distinction between
the cold, warm, and raw start methods. For a coldstart, each task,
including designated cold start tasks, starts in the 'waiting' state
(i.e. prerequisites not satisfied) at the initial cycle time or at the
next valid cycle time thereafter for the task. 
  SUITE.RC: [special tasks] -> coldstart = task1, task2, ...

2/ WARMSTART:
    This assumes that there was a previous cycle (from a previous suite
run - in which case a 'cylc restart' may be an option too) or that files
required from previous cycles have been put in place by some external
means. Startup is as for a cold start, except that designated
cold start tasks are inserted in the 'finished' state (i.e. outputs
completed). The cold start task list must be defined in the suite config
file:
  SUITE.RC: [special tasks] -> coldstart = task1, task2, ...

3/ RAWSTART:
    This starts the suite as if in mid run without any special handling
- any tasks that depend on previous cycles will have to be triggered
manually. Startup is as for a cold start, except that designated
cold start tasks are excluded from the suite. The cold start task list
must be defined in the suite config file:
  SUITE.RC: [special tasks] -> coldstart = task1, task2, ...
 
NOTE:
  SUITE.RC: [special tasks]-> startup = task1, task2, ...
Startup tasks are oneoff tasks that are used only in a coldstart; any
dependence on a startup task is ignored in subsequent cycles. This 
allows you to make everything wait on one or more startup tasks that
could, for example, clean out suite workspaces when a suite is started
from scratch (cold start).

NOTE: daemonize important suites with the POSIX nohup command:
  $ nohup cylc [con] run SUITE YYYYMMDDHH > suite.out 2> suite.err &

See also:
    cylc [control] restart
    cylc [control] stop|shutdown

Arguments:
   SUITE                Registered GROUP:NAME of the suite to run.
   YYYYMMDDHH           Initial cycle time.""" 

        self.parser = OptionParser( usage )

        self.parser.add_option( "-w", "--warm", help="Warm start the suite",
        action="store_true", default=False, dest="warm" )

        self.parser.add_option( "-r", "--raw", help="Raw start the suite",
        action="store_true", default=False, dest="raw" )

        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        if len( self.args ) != 2:
            self.parser.error( "Please supply a suite name and initial cycle time." )

        if cycle_time.is_valid( self.args[1] ):
            self.start_time = self.args[1]
        else:
            self.parser.error( "Invalid cycle time: " + self.args[1])

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug

        if self.options.warm:
            self.banner[ "WARM START" ] = self.start_time
            self.load_tasks = self.load_tasks_warm
        elif self.options.raw:
            self.banner[ "RAW START" ] = self.start_time
            self.load_tasks = self.load_tasks_raw
        else:
            self.banner[ "COLD START" ] = self.start_time
            self.load_tasks = self.load_tasks_cold

    def load_tasks_cold( self ):
        self.log.info( 'Cold Start ' + self.start_time )

        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
    
        for name in task_list:
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', stopctime=None, startup=True )
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.insert( itask )

    def load_tasks_warm( self ):
        self.log.info( 'Warm Start ' + self.start_time )

        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        startup_tasks = self.config.get_startup_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'coldstart task list' CONFIG ITEM" )
        for name in task_list:
            # (startup=True is only for coldstart)
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', stopctime=None, startup=False )
            if name in coldstart_tasks:
                itask.log( 'WARNING', "warm start: starting in finished state" )
                itask.state.set_status( 'finished' )
                itask.prerequisites.set_all_satisfied()
                itask.outputs.set_all_complete()
            if name in startup_tasks:
                itask.log( 'WARNING', "This is a warm start: I will self-destruct." )
                itask.prepare_for_death()
                del itask
                continue
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.insert( itask )

    def load_tasks_raw( self ):
        self.log.info( 'Raw Start ' + self.start_time )
        
        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        startup_tasks = self.config.get_startup_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'coldstart task list' CONFIG ITEM" )

        for name in task_list:
            # startup=True only for coldstart
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', stopctime=None, startup=False )
            if name in coldstart_tasks or name in startup_tasks:
                itask.log( 'WARNING', "This is a raw start: I will self-destruct." )
                itask.prepare_for_death()
                del itask
                continue
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
                continue
            self.insert( itask )

if __name__ == '__main__':
    try:
        server = start()
    except Exception, x:
        if debug:
            raise
        else:
            print >> sys.stderr, x
            print >> sys.stderr, "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print >> sys.stderr, "ERROR CAUGHT, will clean up before exit"
        # this assumes no exceptions in shutdown()
        server.shutdown()

        if debug:
            raise
        else:
            print >> sys.stderr, "THE ERROR WAS:"
            print >> sys.stderr, x
            print >> sys.stderr, "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print >> sys.stderr, "ERROR CAUGHT; will clean up before exit"
        server.shutdown()
        raise
    else:
        # success!
        server.shutdown()
