#!/usr/bin/env python

from OrderedDict import OrderedDict
import os, re, sys
from execute import execute

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def is_help( str ):
    if str == '-h' or \
        str == '--help' or \
        str == '--hlep' or \
        str == 'help' or \
        str == 'hlep' or \
        str == '?':
        return True
    else:
        return False

def match_command( abbrev, commands, title ):
    # allow any unique abbreviation to cylc topics and commands
    matches = []
    for com in commands:
        if re.match( '^' + abbrev + '.*', com ):
            matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, title + ' not found: ' + abbrev
    elif len( matches ) > 1:
        raise CommandNotUniqueError, title + ' not unique: ' + abbrev + ' -> ' + ', '.join( matches )
    else:
        return matches[0]

def pretty_print( incom, choose = None, indent=True, numbered=False ):
    # pretty print commands or topics from a dict:
    # (com[item] = description)
    if choose != None:
        if len(choose) == 0:
            print " (none)"
            return
    com = OrderedDict()
    for item in incom:
        if choose:
            if item not in choose:
                continue
        com[ item ] = incom[ item ]

    if indent:
        spacer = ' '
    else:
        spacer = ''

    items = com.keys()

    longest = len(items[0])
    for item in items:
        if len( item )> longest:
            longest = len( item )
    count = 0
    pad = False
    if len(items) > 9:
        pad = True
    for item in items:
        print spacer,
        if numbered:
            count += 1
            if pad and count < 10:
                digit = ' ' + str(count)
            else:
                digit = str(count)
            print digit + '/', 
        print item, '.'*(longest-len(item)) + '...', com[item]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

categories = \
    [
    'db',
    'prepare',
    'discover',
    'control',
    'utility',
    'task',
    ]

control_commands = \
    [
    'start',
    'stop',
    'restart',
    'trigger',
    'insert',
    'remove',
    'purge',
    'pause',
    'resume',
    'block',
    'unblock',
    'reset',
    'dump',
    'show',
    'log',
    'tmon',
    'lockserver',
    'lockclient',
    'verbosity',
    ]
 
utility_commands = \
    [ 
    'cycletime',
    'checkvars',
    'template',
    'housekeep',
    'transfer',
    ]

db_commands = \
    [
    'register',
    'print',
    'copy',
    'reregister',
    'unregister',
    'export',
    'import',
    ]

prepare_commands = \
    [
    'edit',
    'inline',
    'graph',
    'grep',
    'validate',
    'list',
    ]

discover_commands = \
    [
    'scan',
    'ping',
    ]

task_commands = \
    [
    'wrap',
    'started',
    'message',
    'finished',
    'failed',
    ]


# all commands; uniquify in case any appear in multiple categories:
allcoms = OrderedDict()
for command in db_commands + prepare_commands + \
    control_commands + discover_commands + utility_commands + task_commands:
    if command not in allcoms:
        allcoms[ command ] = True
all_commands = allcoms.keys()

general_usage = """
USAGE:
  cylc help,--help,-h,?                           # this help page
  cylc -v,--version                               # release version
  cylc help CATEGORY                              # help by category
  cylc [CATEGORY] COMMAND help,--help             # command-specific help
  cylc [CATEGORY] COMMAND [options] SUITE [args]  # command usage syntax"""

# topic summaries
catsum = OrderedDict()
catsum['db'       ] = "manage local and central suite registration databases."
catsum['prepare'  ] = "validation, editing, searching, and graphing of suites."
catsum['discover' ] = "discovering what suites are running at the moment."
catsum['control'  ] = "running, monitoring, and controlling suites."
catsum['task'     ] = "running single tasks, task wrapping and messaging."
catsum['utility'  ] = "cycle time arithmetic, filename templating, etc."

# was in help doc:
##Cylc suites are not artificially grouped by forecast cycle; tasks from
##multiple cycles run at once, during catchup operation, to the maximum
##extent allowed by the suite dependency graph.

usage = """
This is the command line interface to the cylc ('silk') forecast suite
metascheduler. ***The cylc graphical user interface is gcylc***.

Version: """ + cylc_version + """
""" + general_usage + """

The cylc command set is organised into categories to help elucidate
available functionality. Categories can optionally be omitted in command
invocation. Any unique abbreviation can be used for a COMMAND or CATEGORY: 
  $ cylc help prep .......... (category: prepare)
  $ cylc [prep] ed [ARGS] ... (category: prepare; command: edit) 
  $ cylc ed [ARGS] .......... (category: prepare; command: edit) 

Command CATEGORIES (which include lists of relevant COMMANDS):"""

if len(sys.argv) == 1:
    print usage
    pretty_print( catsum )
    sys.exit(1)

# command summaries
comsum = OrderedDict()
comsum[ 'register'   ] = 'Add a suite to your local registration database'
comsum[ 'reregister' ] = 'Reregister local or central suite registrations'
comsum[ 'unregister' ] = 'Unregister suites from the local or central database'
comsum[ 'print'      ] = 'Print local or central suite registrations'
comsum[ 'export'     ] = 'Export local registrations to the central database'
comsum[ 'import'     ] = 'Import central registrations to your local database'
comsum[ 'copy'       ] = 'Copy a suite or group of suites.'
comsum[ 'edit'       ] = 'Edit a suite.rc file in $EDITOR, optionally inlined'
comsum[ 'validate'   ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'graph'      ] = 'A dependency graph viewer that updates as you edit'
comsum[ 'grep'       ] = 'An intelligent search tool for cylc suites'
comsum[ 'inline'     ] = 'View suite.rc files in $EDITOR, include-files inlined'
comsum[ 'start'      ] = 'Cold, warm, or raw start a suite at a given cycle time'
comsum[ 'stop'       ] = 'Shut down a running suite (now or later)'
comsum[ 'restart'    ] = 'Restart a suite from a previous state'
comsum[ 'trigger'    ] = 'Manually trigger a task in a running suite'
comsum[ 'insert'     ] = 'Insert a task or group into a running suite'
comsum[ 'remove'     ] = 'Remove a task from a running suite'
comsum[ 'purge'      ] = 'Remove a full dependency tree from a running suite'
comsum[ 'pause'      ] = 'Pause a running suite (stop submitting tasks)'
comsum[ 'resume'     ] = 'Resume submitting tasks in a paused suite'
comsum[ 'reset'      ] = 'Force a task to waiting, ready, or finished state'
comsum[ 'block'      ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'    ] = 'Comply with subsequent intervention commands'
comsum[ 'dump'       ] = 'Print the state of each task in a running suite'
comsum[ 'show'       ] = 'Print task-specific information (prerequisites...)'
comsum[ 'list'       ] = 'Print a suite\'s configured task list'
comsum[ 'ping'       ] = 'Check that a named suite is running'
comsum[ 'scan'       ] = 'Scan a host for running cylc suites'
comsum[ 'log'        ] = 'Print or view suite logs, with filtering'
comsum[ 'tmon'       ] = 'An in-terminal suite monitor (deprecated, see gcylc)'
comsum[ 'submit'     ] = 'Run a single task just as its parent suite would'
comsum[ 'lockserver' ] = 'Lockserver interrogation and lock management'
comsum[ 'verbosity'  ] = 'Change a suite\'s logging verbosity level'
comsum[ 'wrap'       ] = 'Use an existing script or program as a cylc task'
comsum[ 'started'    ] = 'Acquire a task lock and report started'
comsum[ 'message'    ] = 'Report completion of outputs, etc.'
comsum[ 'finished'   ] = 'Release task lock and report finished'
comsum[ 'failed'     ] = 'Release task lock and report failure'
comsum[ 'lockserver' ] = 'The cylc lockserver daemon'
comsum[ 'lockclient' ] = 'Manual suite and task lock management'
comsum[ 'cycletime'  ] = 'Cycle time arithmetic'
comsum[ 'checkvars'  ] = 'Check required environment variables en masse'
comsum[ 'template'   ] = 'Powerful cycle time offset filename templating'
comsum[ 'housekeep'  ] = 'Parallel archiving and cleanup on cycle time offsets'
comsum[ 'transfer'   ] = 'An scp-based file transfer tool'
 
# check that the cylc core modules are accessible
try:
    import cylc
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "SOLUTION: source $CYLC_DIR/cylc-env.sh in your shell." 
    sys.exit(1)

# main help
if len( sys.argv ) == 2 and is_help( sys.argv[1] ):
    print usage
    pretty_print( catsum )
    sys.exit(0)

# cylc release version
if len( sys.argv ) == 2 and \
        ( sys.argv[1] == '-v' or sys.argv[1] == '--version' ):
    print cylc_version
    sys.exit(0)

if len( sys.argv ) == 3 and \
        ( is_help( sys.argv[1] ) or is_help( sys.argv[2] )):
    # cylc CATEGORY help
    # cylc help CATEGORY
    if is_help( sys.argv[1] ):
        category = sys.argv[2]
    else:
        category = sys.argv[1]
    try:
        category = match_command( category, categories, 'CATEGORY' )
    #except CommandNotUniqueError, x:
    #    raise SystemExit(x)
    except CommandError, x:
        print x
        # carry on in case the user omitted the category
        ##print 'Available categories (cylc help):'
        ##print categories
        ##sys.exit(1)

    else:
        print 'CATEGORY: ' + category + ' - ' + catsum[ category ]
        print
        print 'USAGE: cylc [' + category + '] COMMAND help,--help'
        print '  You can abbreviate "' + category + '" and COMMAND.'
        print '  The category "' + category + '" may be omitted.'
        print
        print 'COMMANDS:'
        commands = eval( category + '_commands')
        pretty_print( comsum, choose=commands )
        sys.exit(0)

# cylc [CATEGORY] COMMAND ARGS
arglist = []
try:
    category = match_command( sys.argv[1], categories, 'CATEGORY' )
except CommandError, y:
    # carry on in case the user omitted the category
    ##print 'Available categories (cylc help):'
    ##print categories
    ##sys.exit(1)
    try:
        command = match_command( sys.argv[1], all_commands, ' COMMAND' )
    except CommandError, x:
        print y
        print x
        sys.exit(1)
    else:
        if len(sys.argv) > 2:
            arglist = sys.argv[2:]
else:
    commands = eval( category + '_commands')
    try:
        command = match_command( sys.argv[2], commands, category + ' COMMAND' )
    except CommandError, y:
        print y
        print 'Available commands in category ' + category + ':'
        print commands
        sys.exit(1)
    else:
        if len(sys.argv) > 3:
            arglist = sys.argv[3:]

if len(arglist) > 0 and is_help( arglist[0] ):
        # commands only take '--help'; extend this to help,-h,...
        arglist[0] = '--help'

notify=False
if command not in ['cycletime', 'template']:
    # notify => print 'DONE' when command is completed, which is 
    # helpful for gui command capture windows. But some utilities return
    # specific results by stdout, which we don't want to contaminate.
    notify=True

# construct command to execute
command = '_' + command 
commandlist = [ command ]
for f in arglist:
    commandlist.append( f )
execute( commandlist, notify=notify )
