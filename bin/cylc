#!/usr/bin/env python

from OrderedDict import OrderedDict
import os, re, sys
from execute import execute

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def match_command( abbrev, commands, title ):
    # allow any unique abbreviation to cylc topics and commands
    matches = []
    for com in commands:
        if re.match( '^' + abbrev + '.*', com ):
            matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, title + ' not found: ' + abbrev
    elif len( matches ) > 1:
        raise CommandNotUniqueError, title + ' not unique: ' + abbrev + ' -> ' + ', '.join( matches )
    else:
        return matches[0]

def pretty_print( incom, choose = None, indent=True, numbered=False ):
    # pretty print commands or topics from a dict:
    # (com[item] = description)
    if choose != None:
        if len(choose) == 0:
            print " (none)"
            return
    com = OrderedDict()
    for item in incom:
        if choose:
            if item not in choose:
                continue
        com[ item ] = incom[ item ]

    if indent:
        spacer = ' '
    else:
        spacer = ''

    items = com.keys()

    longest = len(items[0])
    for item in items:
        if len( item )> longest:
            longest = len( item )
    count = 0
    pad = False
    if len(items) > 9:
        pad = True
    for item in items:
        print spacer,
        if numbered:
            count += 1
            if pad and count < 10:
                digit = ' ' + str(count)
            else:
                digit = str(count)
            print digit + '/', 
        print item, '.'*(longest-len(item)) + '...', com[item]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

topics = \
     [
     'core',
     'gui',
     'registration',
     'editing',
     'discovery',
     'starting',
     'stopping',
     'intervention',
     'interrogation',
     'monitoring',
     'task',
     'locking',
     'security',
     'alerting',
     'utilities',
     ]

alerting_commands = []
gui_commands = []

locking_commands = \
    [
    'lockserver',
    'lockclient',
    ]

security_commands = \
    [
    'lockserver',
    'lockclient',
    'block',
    'unblock',
     ]

utilities_commands = \
    [ 
    'cycletime',
    'checkvars',
    'template',
    'housekeeping',
    'file-transfer',
    ]

registration_commands = \
    [
    'register',
    'centraldb',
    'import',
    'export',
    ]

editing_commands = \
    [
    'edit',
    'validate',
    'graph',
    'grep',
    'inline',
    ]

starting_commands = \
    [
    'coldstart', 
    'warmstart', 
    'rawstart', 
    'restart',
    'submit',
    ]

stopping_commands = \
    [
    'stop',
    ]

discovery_commands = \
    [
    'scan',
    'ping',
    ]

monitoring_commands = \
    [
    'tmon',
    'dump',
    'ping',
    'scan',
    ]

intervention_commands = \
    [
    'trigger',
    'insert',
    'remove',
    'purge',
    'pause',
    'resume',
    'block',
    'unblock',
    'reset',
    ]

interrogation_commands = \
    [
    'ping',
    'scan',
    'list',
    'dump',
    'show',
    'log',
    'tmon',
    'verbosity',
    ]

task_commands = \
    [
    'wrap',
    'task-started',
    'task-message',
    'task-finished',
    'task-failed',
    ]

general_usage = """
USAGE:
  cylc help,--help,-h,?                # this help page
  cylc -v,--version                    # cylc release version
  cylc help TOPIC                      # quick help by topic
  cylc COMMAND help,--help             # command-specific help
  cylc COMMAND [options] SUITE [args]  # command usage syntax"""

command_usage = """
USAGE: cylc COMMAND help,--help
       cylc help"""

# topic summaries
topsum = OrderedDict()
topsum['gui'          ] = "the cylc graphical user interface."
topsum['core'         ] = "everything but utilities and the task interface."
topsum['registration' ] = "local and central suite registration."
topsum['editing'      ] = "tools to help with building and editing suites."
topsum['discovery'    ] = "finding out which suites are running."
topsum['starting'     ] = "starting a suite or running a single task."
topsum['stopping'     ] = "shutting down a running suite."
topsum['intervention' ] = "interacting with a running suite."
topsum['interrogation'] = "getting information from running suites."
topsum['monitoring'   ] = "monitoring a running suite."
topsum['locking'      ] = "suite and task locking by the cylc lockserver."
topsum['security'     ] = "access, locking, blocking, and passphrases."
topsum['alerting'     ] = "centralized task failure and timeout hooks."
topsum['task'         ] = "task wrapping and the messaging interface."
topsum['utilities'    ] = "extra programs intended for use in suites."

usage = """This is the cylc metascheduler commandline interface.
See also gcylc, the graphical user interface.

Release version: """ + cylc_version + """
""" + general_usage + """

You can use any unique abbreviation for a COMMAND or TOPIC, e.g.:
  $ cylc help mon ............... (topic: monitoring)
  $ cylc reg foo /path/to/foo ... (command: register) 

Help TOPICS (which include lists of relevant COMMANDS):"""

if len(sys.argv) == 1:
    print usage
    pretty_print( topsum )
    sys.exit(1)

topic_help = {}
topic_help[ 'security' ] = """
Cylc commands allow only the suite owner to intervene in a running suite.

The cylc lockserver prevents accidental simultaneous runs of the same
suite (unless the suite allows it) even if it is registered under
several names, or of the same task at the same cycle time (even by
single task submit).

Suite blocking guards against inadvertent intervention in your own suites,
but it can be annoying so it is disabled by default. To turn blocking on:
 + SUITE.RC: use suite blocking = True

A secure passphrase prevents other users from accessing your suite even
if they hack command source code to subvert the owner-only restriction.
 + SUITE.RC: use secure passphrase = True
The passphrase must be stored in $HOME/.cylc/security/[SUITE_NAME] with
private file permissions, or cylc will refuse to run the suite. If your
suite contains tasks that run on a remote host or under another
username, those accounts must also hold the passphrase. The passphrase
is never sent across the network; a secure md5 checksum is exchanged."""

topic_help[ 'gui' ] = """
The cylc Graphical User Interface is 'gcylc'. It starts an app from
which you can manage suite registrations and choose which suites to
edit, graph, or run, etc., or direct suite control apps for particular
suites.  For help, see the GUI 'help' menu items and buttons."""

topic_help[ 'alerting' ] = """
Cylc can call a designated alert script on any of the following events:
 + a task is submitted
 + a task fails to submit
 + a task times out in job submission
 + a task starts running
 + a task finishes successfully
 + a task fails to finish successfully
 + a task times out in execution.

Alert scripts can be configured for the suite as a whole and/or on a per
task basis. This can be used to send an email or an SMS to operation
support staff, update task status in a dedicated monitoring system such
as Nagios, or whatever you like. See suite config (suite.rc)
documentation for configuration details."""

topic_help['registration'] = """
A cylc suite must be registered in your local (user-specific)
registration database before you can use it. This associates a name
with the suite definition directory so that you can target the suite by
name when you run it and so on. In addition, suite names can be
organized into groups, for example:
    foo
    nwp:oper1
    nwp:oper2
    test:a
Suite names without a group prefix are implicitly in the 'default' group.

Registered suites can also be exported to, or imported from, the central
suite database, to enable easy sharing of suites between users. The
central database is currently local to the cylc host machine; it may be
extended to server suites across a network in the future."""

# command summaries
comsum = OrderedDict()
comsum[ 'register'  ] = 'Create, view, and delete suite registrations'
comsum[ 'export'    ] = 'Export suites to the central suite database'
comsum[ 'import'    ] = 'Import suites from the central suite database'
comsum[ 'centraldb' ] = 'View or delete central database registrations'
comsum[ 'edit'      ] = 'Edit a suite.rc file in $EDITOR, optionally inlined'
comsum[ 'validate'  ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'graph'     ] = 'A dependency graph viewer that updates as you edit'
comsum[ 'grep'      ] = 'An intelligent search tool for cylc suites'
comsum[ 'inline'    ] = 'View suite.rc files in $EDITOR, include-files inlined'
comsum[ 'coldstart' ] = 'Cold start a suite at a given cycle time'
comsum[ 'warmstart' ] = 'Warm start a suite at a given cycle time'
comsum[ 'rawstart'  ] = 'Raw start a suite at a given cycle time'
comsum[ 'restart'   ] = 'Restart a suite from a previous state'
comsum[ 'stop'      ] = 'Shut down a running suite (now or later)'
comsum[ 'trigger'   ] = 'Manually trigger a task in a running suite'
comsum[ 'insert'    ] = 'Insert a task or group into a running suite'
comsum[ 'remove'    ] = 'Remove a task from a running suite'
comsum[ 'purge'     ] = 'Remove a full dependency tree from a running suite'
comsum[ 'pause'     ] = 'Pause a running suite (stop submitting tasks)'
comsum[ 'resume'    ] = 'Resume submitting tasks in a paused suite'
comsum[ 'reset'     ] = 'Force a task to waiting, ready, or finished state'
comsum[ 'block'     ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'   ] = 'Comply with subsequent intervention commands'
comsum[ 'dump'      ] = 'Print the state of each task in a running suite'
comsum[ 'show'      ] = 'Print task-specific information (prerequisites...)'
comsum[ 'list'      ] = 'Print a suite\'s configured task list'
comsum[ 'ping'      ] = 'Check that a named suite is running'
comsum[ 'scan'      ] = 'Scan a host for running cylc suites'
comsum[ 'log'       ] = 'Print or view suite logs, with filtering'
comsum[ 'tmon'      ] = 'A terminal-based suite monitor (deprecated)'
comsum[ 'submit'    ] = 'Run a single task just as its parent suite would'
comsum[ 'lockserver'] = 'Lockserver interrogation and lock management'
comsum[ 'verbosity' ] = 'Change a suite\'s logging verbosity level'
comsum[ 'wrap'         ] = 'Use an existing script or program as a cylc task'
comsum[ 'task-started' ] = 'Acquire a task lock and report started'
comsum[ 'task-message' ] = 'Report completion of outputs, etc.'
comsum[ 'task-finished'] = 'Release task lock and report finished'
comsum[ 'task-failed'  ] = 'Release task lock and report failure'
comsum[ 'lockserver' ] = 'The cylc lockserver daemon'
comsum[ 'lockclient' ] = 'Manual suite and task lock management'
comsum[ 'cycletime'  ] = 'Cycle time arithmetic'
comsum[ 'checkvars'  ] = 'Check required environment variables en masse'
comsum[ 'template'   ] = 'Powerful cycle time offset filename templating'
comsum[ 'housekeeping' ] = 'Parallel archiving and cleanup on cycle time offsets'
comsum[ 'file-transfer'] = 'An scp-based file transfer tool'
 
# check that the cylc core modules are accessible
try:
    import cylc
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "SOLUTION: source $CYLC_DIR/cylc-env.sh in your shell." 
    sys.exit(1)

# main help
if len( sys.argv ) == 2 and \
        (sys.argv[1] == '-h' or \
        sys.argv[1] == '--help' or \
        sys.argv[1] == '--hlep' or \
        sys.argv[1] == 'help' or \
        sys.argv[1] == 'hlep' or \
        sys.argv[1] == '?'):
    print usage
    pretty_print( topsum )
    sys.exit(0)

# cylc release version
if sys.argv[1] == '-v' or sys.argv[1] == '--version':
    print cylc_version
    sys.exit(0)

# uniquify the 'core commands' list (some may be in multiple topics)
corecom = OrderedDict()
for command in registration_commands + editing_commands + starting_commands + stopping_commands + \
        intervention_commands + interrogation_commands + monitoring_commands + \
        locking_commands + security_commands + discovery_commands:
            if command not in corecom:
                corecom[ command ] = True
core_commands = corecom.keys()

# secret command lists used by documentation generation script
if len(sys.argv) == 2 and sys.argv[1] == 'commands':
    for command in core_commands + task_commands:
        print command
    sys.exit(0)
if len(sys.argv) == 2 and sys.argv[1] == 'utilities':
    for command in utilities_commands:
        print command
    sys.exit(0)
if len(sys.argv) == 2 and sys.argv[1] == 'topics':
    for topic in topics:
        print topic
    sys.exit(0)

if sys.argv[1] == 'help' or sys.argv[1] == 'hlep':
    # cylc help TOPIC
    try:
        top = match_command( sys.argv[2], topics, 'TOPIC' )
    except CommandError, x:
        # TOPIC not found, try matching COMMAND
        try:
            command = match_command( sys.argv[2], core_commands + utilities_commands + task_commands, 'COMMAND' )
        except CommandError, y:
            # COMMAND not found either
            print x
            raise SystemExit(y)
        else:
            # found COMMAND
            print x
            print 'Did you mean COMMAND?...\n'
            # construct command to execute
            command = '_' + command 
            commandlist = [ command ]
            execute( commandlist )
            sys.exit(0)
    else:
        # found TOPIC
        print 'TOPIC:' + top + ' - ' + topsum[ top ]
        commands = eval( top + '_commands')
        if top in topic_help:
            print topic_help[top]
        if len( commands ) != 0: 
            print command_usage
        if len( commands ) != 0:
            print
            print 'COMMANDs:'
            pretty_print( comsum, commands )
        sys.exit(0)

# cylc COMMAND ARGS
arglist = sys.argv[1:]
try:
    command = match_command( arglist[0], core_commands + utilities_commands + task_commands, 'COMMAND' )
except CommandError, x:
    # COMMAND not found
    try:
        if arglist[1] == 'help' or \
                arglist[1] == '--help' or \
                arglist[1] == 'hlep' or \
                arglist[1] == '--hlep':
            # if 2nd arg is 'help', try matching TOPIC
            try:
                top = match_command( arglist[0], topics, 'TOPIC' )
            except CommandError, y:
                # TOPIC not found either
                print x
                raise SystemExit(y)
            else:
                # TOPIC found
                print x
                print 'Did you mean TOPIC?...\n'
                print 'TOPIC:' + top + ' - ' + topsum[ top ]
                commands = eval( top + '_commands')
                if len( commands ) != 0: 
                    print command_usage
                if top in topic_help:
                    print topic_help[top]
                if len( commands ) != 0:
                    print
                    print 'COMMANDs:'
                    pretty_print( comsum, commands )
                sys.exit(0)
    except IndexError:
        # len( arglist ) only 1
        raise SystemExit(x)
else:
    # COMMAND found, carry on and execut the command
    pass

options = []
if len(arglist) > 1:
    options = arglist[1:]

try:
    if options[0] == 'help' or options[0] == 'hlep':
        # catch 'cylc COMMAND help' (should be --help)
        options[0] = '--help'
except IndexError:
    pass

# construct command to execute
command = '_' + command 
commandlist = [ command ]
for f in options:
    commandlist.append( f )
execute( commandlist )
