#!/usr/bin/env python

from OrderedDict import OrderedDict
import os, re, sys
from execute import execute

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def find_command( abbrev, commands, title ):
    # allow any unique abbreviation to cylc categories and commands
    matches = []
    for com in commands:
        if re.match( '^' + abbrev + '.*', com ):
            matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, title + ' not found: ' + abbrev
    elif len( matches ) > 1:
        raise CommandNotUniqueError, title + ' not unique: ' + abbrev + ' -> ' + ', '.join( matches )
    else:
        return matches[0]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

categories = \
     [
     'core',
     'other',
     'preparation',
     'starting',
     'stopping',
     'running',
     'information',
     'utilities',
     'tasks',
     'all',
     'locking',
     'security',
     ]

core_commands = \
    [
    'register',
    'edit',
    'validate',
    'graph',
    'grep',
    'submit',
    'control',
    'coldstart',
    'warmstart',
    'restart',
    'pause',
    'resume',
    'stop',
    'insert',
    'remove',
    'purge',
    'ping',
    'scan',
    'list',
    'dump',
    'show',
    ]

locking_commands = \
    [
    #'cylclockd',
    'lockserver',
    ]

security_commands = \
    [
    'block',
    'unblock',
     ]

utilities_commands = \
    [ 
    'cycletime',
    'checkvars',
    'template',
    'housekeeping',
    'file-transfer',
    ]

preparation_commands = \
    [
    'register',
    'edit',
    'validate',
    'graph',
    'grep',
    'inline',
    ]

starting_commands = \
    [
    'control',
    'coldstart', 
    'warmstart', 
    'rawstart', 
    'restart',
    ]

stopping_commands = \
    [
    'control',
    'stop',
    ]

running_commands = \
    [
    'control',
    'coldstart', 
    'warmstart', 
    'rawstart', 
    'restart',
    'pause',
    'resume',
    'stop',
    'insert',
    'reset',
    'remove',
    'purge',
    'block',
    'unblock',
    'verbosity',
    'submit',
    ]

information_commands = \
    [
    'ping',
    'scan',
    'list',
    'graph',
    'dump',
    'show',
    'log',
    'view',
    'monitor',
    ]

tasks_commands = \
    [
    'wrap',
    'submit',
    'task-started',
    'task-message',
    'task-finished',
    'task-failed',
    ]

# uniquify the 'all commands' list (some may reside in multiple categories)
allcom = OrderedDict()
for command in preparation_commands + running_commands + information_commands + locking_commands + \
        security_commands + tasks_commands:
            allcom[ command ] = True
all_commands = allcom.keys()

other_commands = all_commands[:]
for command in core_commands:
    other_commands.remove( command )

general_usage = """
USAGE: cylc help                                # top level help
       cylc help CATEGORY                       # commands by category
       cylc COMMAND --help                      # command-specific help
       cylc COMMAND [options] SUITE [arguments] # command usage syntax"""

usage = """
This is the cylc metascheduler commandline interface.
""" + general_usage + """

You can use any unique abbreviation for a COMMAND or CATEGORY, e.g.:
 $ cylc help prep[aration]

 + Main CATEGORIES:
    core .......... essential commands for preparing and running suites
    other ......... additional commands not in the core category
    all ........... core + other commands (not the 'utilities' category)
 + Finer-grained categories: 
    preparation ... suite preparation and editing
    running ....... running and controlling suites
    starting ...... commands for starting a cylc suite
    stopping ...... commands for stopping a cylc suite
    information ... getting information about suites
    tasks ......... task wrapping and the task messaging interface
    locking ....... suite and task locking by the cylc lockserver daemon
    security ...... suite security
 + Other categories:
    utilities ..... some useful commands designed for use in cylc suites

Cylc release version:
    $ cylc -v,--version

Main help (this page):
    $ cylc help,-h,--help,?
    """

if len(sys.argv) == 1:
    print >> sys.stderr, usage
    sys.exit(1)

preparation_help = """
CATEGORY:preparation - commands for suite preparation and editing."""

starting_help  = """
CATEGORY:starting - commands for starting cylc suites."""

stopping_help  = """
CATEGORY:stopping - commands for stopping cylc suites."""

rrunning_help  = """
CATEGORY:running - commands for running and controlling suites."""

information_help = """
CATEGORY:information - commands for getting information about running suites."""

core_help = """
CATEGORY:core - essential commands for preparing and running suites."""

other_help = """
CATEGORY:other - commands not in CATEGORY:core."""

security_help = """
CATEGORY:security - owner-only access, blocking, and secure passphrases.

Cylc commands allow only the suite owner to intervene in a running suite.

Suite blocking guards against inadvertent intervention in your own suites.
 + SUITE.RC: use suite blocking = True

A secure passphrase prevents other users from accessing your suite even
if they hack command source code to subvert the owner-only restriction.
 + SUITE.RC: use secure passphrase = True

The passphrase must be stored in $HOME/.cylc/security/[SUITE_NAME] with
private file permissions, or cylc will refuse to run the suite. If your
suite contains tasks that run on a remote host or under another
username, those accounts must also hold the passphrase. The passphrase
is never sent across the network; a secure md5 checksum is exchanged."""

locking_help = """
CATEGORY:locking - the cylc lockserver daemon and its user interface."""

tasks_help = """
CATEGORY:tasks - task wrapping and the task messaging interface.""" 

utilities_help = """
CATEGORY:utilities - utility commands designed for use with cylc."""

all_help = "The complete cylc command set, sans utilities."

# command summaries
comsum = {}
comsum[ 'register'  ] = 'Manage suite registrations (name -> definition dir)'
comsum[ 'cylclockd' ] = 'The cylc lockserver daemon'
comsum[ 'grep'      ] = 'An intelligent search tool for cylc suites'
comsum[ 'graph'     ] = 'A dependency graph viewer that updates as you edit'
comsum[ 'validate'  ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'inline'    ] = 'View suite.rc files with include-files inlined'
comsum[ 'edit'      ] = 'Edit a suite config file, optionally inlined'
comsum[ 'coldstart' ] = 'Cold start a suite at a given cycle time'
comsum[ 'warmstart' ] = 'Warm start a suite at a given cycle time'
comsum[ 'rawstart'  ] = 'Raw start a suite at a given cycle time'
comsum[ 'restart'   ] = 'Restart a suite from a previous state'
comsum[ 'stop'      ] = 'Shut down a running suite (now or later)'
comsum[ 'pause'     ] = 'Pause a running suite (stop submitting tasks)'
comsum[ 'resume'    ] = 'Unpause a running suite (resume submitting tasks)'
comsum[ 'block'     ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'   ] = 'Comply with subsequent intervention commands'
comsum[ 'insert'    ] = 'Insert a task or group into a running suite'
comsum[ 'reset'     ] = 'Force a task to change state (manual triggering!)'
comsum[ 'remove'    ] = 'Remove tasks from a running suite'
comsum[ 'purge'     ] = 'Remove a full dependency tree from a running suite'
comsum[ 'submit'    ] = 'Submit a single task exactly as its suite would'
comsum[ 'control'   ] = 'The cylc suite control and monitoring GUI'
comsum[ 'view'      ] = 'Suite monitoring GUI (control functions disabled)'
comsum[ 'dump'      ] = 'Print the state of each task in a running suite'
comsum[ 'show'      ] = 'Retrieve information from a running suite'
comsum[ 'list'      ] = 'Print a suite\'s configured task list'
comsum[ 'ping'      ] = 'Check that a named suite is running'
comsum[ 'scan'      ] = 'Scan cylc ports for running suites'
comsum[ 'log'       ] = 'Print or view suite logs, with filtering'
comsum[ 'monitor'   ] = 'An in-terminal suite monitor (deprecated)'
comsum[ 'lockserver'] = 'Lockserver interrogation and lock management'
comsum[ 'verbosity' ] = 'Change a suite\'s logging verbosity level'
comsum[ 'cycletime' ] = 'Cycle time arithmetic'
comsum[ 'checkvars' ] = 'Process required environment variables en masse'
comsum[ 'template'  ] = 'Cycle time based filename templating'
comsum[ 'housekeeping' ] = 'Cycle time based parallel archiving and cleanup'
comsum[ 'file-transfer'] = 'An scp-based file transfer tool'
comsum[ 'wrap'         ] = 'A wrapper for running non-cylc-aware tasks'
comsum[ 'task-started' ] = 'Acquire a task lock and report started'
comsum[ 'task-message' ] = 'Report completion of outputs, etc.'
comsum[ 'task-finished'] = 'Release task lock and report finished'
comsum[ 'task-failed'  ] = 'Release task lock and report failure'
 
# check that the cylc core modules are accessible
try:
    import cylc
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "SOLUTION: source $CYLC_DIR/cylc-env.sh in your shell." 
    sys.exit(1)

# main help
if len( sys.argv ) == 2 and \
        (sys.argv[1] == '-h' or \
        sys.argv[1] == '--help' or \
        sys.argv[1] == '--hlep' or \
        sys.argv[1] == 'help' or \
        sys.argv[1] == 'hlep' or \
        sys.argv[1] == '?'):
    print usage
    sys.exit(0)

# cylc release version
if sys.argv[1] == '-v' or sys.argv[1] == '--version':
    print cylc_version
    sys.exit(0)

# secret command list used by documentation generation script
if len(sys.argv) == 2 and sys.argv[1] == 'commands':
    for command in all_commands:
        print command
    sys.exit(0)

# secret category list used by documentation generation script
if len(sys.argv) == 2 and sys.argv[1] == 'categories':
    for category in categories:
        print category
    sys.exit(0)

if sys.argv[1] == 'help' or sys.argv[1] == 'hlep':
    # cylc help CATEGORY
    try:
        cat = find_command( sys.argv[2], categories, 'CATEGORY' )
    except CommandError, x:
        raise SystemExit(x)
    print eval (cat + '_help')
    print general_usage
    print
    print 'COMMANDs:'
    output = []
    commands = eval( cat + '_commands')
    longest = len(commands[0])
    for command in commands:
        if len( command )> longest:
            longest = len( command )
    count = 0
    pad = False
    if len(commands) > 10:
        pad = True
    for command in commands:
        count += 1
        if pad and count < 10:
            digit = ' ' + str(count)
        else:
            digit = str(count)
        print ' ' + digit + '/', command, '.'*(longest-len(command)) + '...', comsum[command]
    sys.exit(0)

# cylc COMMAND ARGS
arglist = sys.argv[1:]
try:
    command = find_command( arglist[0], all_commands + utilities_commands, 'COMMAND' )
except CommandError, x:
    raise SystemExit(x)

options = []
if len(arglist) > 1:
    options = arglist[1:]

try:
    if options[0] == 'help' or options[0] == 'hlep':
        # catch 'cylc COMMAND help'
        options[0] = '--help'
except IndexError:
    pass

# construct command to execute
command = '_' + command 
commandlist = [ command ]
for f in options:
    commandlist.append( f )
execute( commandlist )
