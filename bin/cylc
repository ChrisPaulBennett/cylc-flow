#!/usr/bin/env python

from OrderedDict import OrderedDict
import os, re, sys
from execute import execute

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def match_command( abbrev, commands, title ):
    # allow any unique abbreviation to cylc topics and commands
    matches = []
    for com in commands:
        if re.match( '^' + abbrev + '.*', com ):
            matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, title + ' not found: ' + abbrev
    elif len( matches ) > 1:
        raise CommandNotUniqueError, title + ' not unique: ' + abbrev + ' -> ' + ', '.join( matches )
    else:
        return matches[0]

def pretty_print( incom, choose = None, indent=True, numbered=False ):
    # pretty print commands or topics from a dict:
    # (com[item] = description)
    if choose != None:
        if len(choose) == 0:
            print " (none)"
            return
    com = OrderedDict()
    for item in incom:
        if choose:
            if item not in choose:
                continue
        com[ item ] = incom[ item ]

    if indent:
        spacer = ' '
    else:
        spacer = ''

    items = com.keys()

    longest = len(items[0])
    for item in items:
        if len( item )> longest:
            longest = len( item )
    count = 0
    pad = False
    if len(items) > 9:
        pad = True
    for item in items:
        print spacer,
        if numbered:
            count += 1
            if pad and count < 10:
                digit = ' ' + str(count)
            else:
                digit = str(count)
            print digit + '/', 
        print item, '.'*(longest-len(item)) + '...', com[item]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

topics = \
     [
     'core',
     'preparation',
     'discovery',
     'starting',
     'stopping',
     'intervention',
     'interrogation',
     'monitoring',
     'task',
     'locking',
     'security',
     'alerting',
     'utilities',
     ]

alerting_commands = []

locking_commands = \
    [
    #'cylclockd',
    'lockserver',
    ]

security_commands = \
    [
    'lockserver',
    'block',
    'unblock',
     ]

utilities_commands = \
    [ 
    'cycletime',
    'checkvars',
    'template',
    'housekeeping',
    'file-transfer',
    ]

preparation_commands = \
    [
    'register',
    'edit',
    'validate',
    'graph',
    'grep',
    'inline',
    ]

starting_commands = \
    [
    'control',
    'coldstart', 
    'warmstart', 
    'rawstart', 
    'restart',
    'submit',
    ]

stopping_commands = \
    [
    'control',
    'stop',
    ]

discovery_commands = \
    [
    'scan',
    'ping',
    'control',
    ]

monitoring_commands = \
    [
    'control',
    'view',
    'tmon',
    'dump',
    # 'ping',
    # 'scan',
    ]

intervention_commands = \
    [
    'control',
    'trigger',
    'insert',
    'remove',
    'purge',
    'pause',
    'resume',
    'block',
    'unblock',
    'reset',
    ]

interrogation_commands = \
    [
    'control',
    'ping',
    'scan',
    'list',
    'dump',
    'show',
    'log',
    'view',
    'tmon',
    'verbosity',
    ]

task_commands = \
    [
    'wrap',
    'task-started',
    'task-message',
    'task-finished',
    'task-failed',
    ]

general_usage = """
USAGE:
  cylc help,--help,-h,?                # this help page
  cylc -v,--version                    # cylc release version
  cylc help TOPIC                      # quick help by topic
  cylc COMMAND help,--help             # command-specific help
  cylc COMMAND [options] SUITE [args]  # command usage syntax"""

command_usage = """
USAGE: cylc COMMAND help,--help
       cylc help"""

# topic summaries
topsum = OrderedDict()
topsum['core'         ] = "everything but utilities and task interface."
topsum['preparation'  ] = "suite preparation and editing."
topsum['discovery'    ] = "finding what suites are running."
topsum['starting'     ] = "starting a suite or running a single task."
topsum['stopping'     ] = "shutting down a running suite."
topsum['intervention' ] = "interacting with a running suite."
topsum['interrogation'] = "getting information from running suites."
topsum['monitoring'   ] = "monitoring a running suite."
topsum['locking'      ] = "suite and task locking by the cylc lockserver."
topsum['security'     ] = "access, locking, blocking, and passphrases."
topsum['alerting'     ] = "centralized task failure and timeout hooks."
topsum['task'         ] = "task wrapping and the messaging interface."
topsum['utilities'    ] = "extra programs intended for use in suites."

usage = """This is the cylc metascheduler commandline interface.
""" + general_usage + """

You can use any unique abbreviation for a COMMAND or TOPIC, e.g.:
  $ cylc help prep .............. (topic: preparation)
  $ cylc reg foo /path/to/foo ... (command: register) 

Help TOPICS (which include lists of relevant COMMANDS):"""

if len(sys.argv) == 1:
    print usage
    pretty_print( topsum )
    sys.exit(1)

topic_help = {}
topic_help[ 'security' ] = """
Cylc commands allow only the suite owner to intervene in a running suite.

The cylc lockserver prevents accidental simultaneous runs of the same
suite (unless the suite allows it) even if it is registered under
several names, or of the same task at the same cycle time (even by
single task submit).

Suite blocking guards against inadvertent intervention in your own suites,
but it can be annoying so it is disabled by default. To turn blocking on:
 + SUITE.RC: use suite blocking = True

A secure passphrase prevents other users from accessing your suite even
if they hack command source code to subvert the owner-only restriction.
 + SUITE.RC: use secure passphrase = True
The passphrase must be stored in $HOME/.cylc/security/[SUITE_NAME] with
private file permissions, or cylc will refuse to run the suite. If your
suite contains tasks that run on a remote host or under another
username, those accounts must also hold the passphrase. The passphrase
is never sent across the network; a secure md5 checksum is exchanged."""

topic_help[ 'alerting' ] = """
Cylc can call a designated alert script on any of the following events:
 + a task is submitted
 + a task fails to submit
 + a task times out in job submission
 + a task starts running
 + a task finishes successfully
 + a task fails to finish successfully
 + a task times out in execution.

Alert scripts can be configured for the suite as a whole and/or on a per
task basis. This can be used to send an email or an SMS to operation
support staff, update task status in a dedicated monitoring system such
as Nagios, or whatever you like. See suite config (suite.rc)
documentation for configuration details."""

# command summaries
comsum = OrderedDict()
comsum[ 'register'  ] = 'Manage suite registrations (name -> definition dir)'
comsum[ 'edit'      ] = 'Edit a suite config file, optionally inlined'
comsum[ 'validate'  ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'graph'     ] = 'A dependency graph viewer that updates as you edit'
comsum[ 'grep'      ] = 'An intelligent search tool for cylc suites'
comsum[ 'inline'    ] = 'View suite.rc files with include-files inlined'
comsum[ 'control'   ] = 'The cylc suite control and monitoring GUI'
comsum[ 'coldstart' ] = 'Cold start a suite at a given cycle time'
comsum[ 'warmstart' ] = 'Warm start a suite at a given cycle time'
comsum[ 'rawstart'  ] = 'Raw start a suite at a given cycle time'
comsum[ 'restart'   ] = 'Restart a suite from a previous state'
comsum[ 'stop'      ] = 'Shut down a running suite (now or later)'
comsum[ 'trigger'   ] = 'Manually trigger a task in a running suite'
comsum[ 'insert'    ] = 'Insert a task or group into a running suite'
comsum[ 'remove'    ] = 'Remove a task from a running suite'
comsum[ 'purge'     ] = 'Remove a full dependency tree from a running suite'
comsum[ 'pause'     ] = 'Pause a running suite (stop submitting tasks)'
comsum[ 'resume'    ] = 'Unpause a running suite (resume submitting tasks)'
comsum[ 'reset'     ] = 'Force a task to waiting, ready, or finished state'
comsum[ 'block'     ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'   ] = 'Comply with subsequent intervention commands'
comsum[ 'view'      ] = 'Suite monitoring GUI (control functions disabled)'
comsum[ 'dump'      ] = 'Print the state of each task in a running suite'
comsum[ 'show'      ] = 'Print task-specific information (prerequisites...)'
comsum[ 'list'      ] = 'Print a suite\'s configured task list'
comsum[ 'ping'      ] = 'Check that a named suite is running'
comsum[ 'scan'      ] = 'Scan a host for running cylc suites'
comsum[ 'log'       ] = 'Print or view suite logs, with filtering'
comsum[ 'tmon'      ] = 'A terminal-based suite monitor (deprecated)'
comsum[ 'submit'    ] = 'Run a single task just as its parent suite would'
comsum[ 'lockserver'] = 'Lockserver interrogation and lock management'
comsum[ 'verbosity' ] = 'Change a suite\'s logging verbosity level'
comsum[ 'wrap'         ] = 'Use an existing script or program as a cylc task'
comsum[ 'task-started' ] = 'Acquire a task lock and report started'
comsum[ 'task-message' ] = 'Report completion of outputs, etc.'
comsum[ 'task-finished'] = 'Release task lock and report finished'
comsum[ 'task-failed'  ] = 'Release task lock and report failure'
comsum[ 'cylclockd' ] = 'The cylc lockserver daemon'
comsum[ 'cycletime' ] = 'Cycle time arithmetic'
comsum[ 'checkvars' ] = 'Process required environment variables en masse'
comsum[ 'template'  ] = 'Cycle time based filename templating'
comsum[ 'housekeeping' ] = 'Cycle time based parallel archiving and cleanup'
comsum[ 'file-transfer'] = 'An scp-based file transfer tool'
 
# check that the cylc core modules are accessible
try:
    import cylc
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "SOLUTION: source $CYLC_DIR/cylc-env.sh in your shell." 
    sys.exit(1)

# main help
if len( sys.argv ) == 2 and \
        (sys.argv[1] == '-h' or \
        sys.argv[1] == '--help' or \
        sys.argv[1] == '--hlep' or \
        sys.argv[1] == 'help' or \
        sys.argv[1] == 'hlep' or \
        sys.argv[1] == '?'):
    print usage
    pretty_print( topsum )
    sys.exit(0)

# cylc release version
if sys.argv[1] == '-v' or sys.argv[1] == '--version':
    print cylc_version
    sys.exit(0)

# uniquify the 'core commands' list (some may be in multiple topics)
corecom = OrderedDict()
for command in preparation_commands + starting_commands + stopping_commands + \
        intervention_commands + interrogation_commands + monitoring_commands + \
        locking_commands + security_commands + discovery_commands:
            if command not in corecom:
                corecom[ command ] = True
core_commands = corecom.keys()

# secret command lists used by documentation generation script
if len(sys.argv) == 2 and sys.argv[1] == 'commands':
    for command in core_commands + task_commands:
        print command
    sys.exit(0)
if len(sys.argv) == 2 and sys.argv[1] == 'utilities':
    for command in utilities_commands:
        print command
    sys.exit(0)
if len(sys.argv) == 2 and sys.argv[1] == 'topics':
    for topic in topics:
        print topic
    sys.exit(0)

if sys.argv[1] == 'help' or sys.argv[1] == 'hlep':
    # cylc help TOPIC
    try:
        top = match_command( sys.argv[2], topics, 'TOPIC' )
    except CommandError, x:
        raise SystemExit(x)
    print 'TOPIC:' + top + ' - ' + topsum[ top ]
    commands = eval( top + '_commands')
    if len( commands ) != 0: 
        print command_usage
    if top in topic_help:
        print topic_help[top]
    if len( commands ) != 0:
        print
        print 'COMMANDs:'
        pretty_print( comsum, commands )
    sys.exit(0)

# cylc COMMAND ARGS
arglist = sys.argv[1:]
try:
    command = match_command( arglist[0], core_commands + utilities_commands + task_commands, 'COMMAND' )
except CommandError, x:
    raise SystemExit(x)

options = []
if len(arglist) > 1:
    options = arglist[1:]

try:
    if options[0] == 'help' or options[0] == 'hlep':
        # catch 'cylc COMMAND help'
        options[0] = '--help'
except IndexError:
    pass

# construct command to execute
command = '_' + command 
commandlist = [ command ]
for f in options:
    commandlist.append( f )
execute( commandlist )
