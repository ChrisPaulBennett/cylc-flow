#!/usr/bin/env python

from OrderedDict import OrderedDict
import os, re, sys
from execute import execute

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def is_help( str ):
    if str == '-h' or \
        str == '--help' or \
        str == '--hlep' or \
        str == 'help' or \
        str == 'hlep' or \
        str == '?':
        return True
    else:
        return False

def match_dict( abbrev, categories ):
    # allow any unique abbreviation to cylc categories
    cats = categories.keys()
    matches = []
    for cat in cats:
        if re.match( '^' + abbrev + '.*', cat ):
            matches.append( cat )
    if len( matches ) == 0:
        raise CommandNotFoundError, 'THING not found: ' + abbrev
    elif len( matches ) > 1:
        # multiple matches, but they might be aliases for the same command
        resolve = []
        for match in matches:
            res = categories[match]
            if res not in resolve:
                resolve.append(res)
        if len( resolve ) > 1:
            #raise CommandNotUniqueError, 'THING not unique: ' + abbrev + ' -> ' + ', '.join( resolve )
            raise CommandNotUniqueError, 'THING not unique: ' + abbrev + ' -> ' + ', '.join( matches )
        else:
            category = resolve[0]
    else:
        category = categories[matches[0]]
    return category

def match_list( abbrev, commands ):
    # allow any unique abbreviation to cylc topics and commands
    matches = []
    for com in commands:
        if re.match( '^' + abbrev + '.*', com ):
            matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, 'Command not found: ' + abbrev
    elif len( matches ) > 1:
        raise CommandNotUniqueError, 'Command not unique: ' + abbrev + ' -> ' + ', '.join( matches )
    else:
        return matches[0]

def pretty_print( incom, choose, indent=True, numbered=False ):
    # pretty print commands or topics from a dict:
    # (com[item] = description)
    
    if indent:
        spacer = ' '
    else:
        spacer = ''

    longest = len(choose[0])
    for item in choose:
        if len( item )> longest:
            longest = len( item )

    count = 0
    pad = False
    if len(choose) > 9:
        pad = True

    for item in choose:
        if item not in incom:
            raise SystemExit( "ERROR: summary for '" + item + "' not found" )

        print spacer,
        if numbered:
            count += 1
            if pad and count < 10:
                digit = ' ' + str(count)
            else:
                digit = str(count)
            print digit + '/', 
        print item, '.'*(longest-len(item)) + '...', incom[item]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

# categories[ alias ] = category
categories = {}
categories['db'          ] = 'database'
categories['database'    ] = 'database'
categories['information' ] = 'information'
categories['prepare'     ] = 'prepare'
categories['preparation' ] = 'prepare'
categories['discover'    ] = 'discover'
categories['control'     ] = 'control'
categories['utility'     ] = 'utility'
categories['utilities'   ] = 'utility'
categories['tasks'       ] = 'task'
 
information_commands = {}
information_commands['gcylc'    ] = 'gcycl'
information_commands['gcycl'    ] = 'gcycl'
information_commands['list'     ] = 'list'
information_commands['ls'       ] = 'list'
information_commands['describe' ] = 'describe'

control_commands = OrderedDict()
control_commands['gcylc'  ] = 'gcylc'
control_commands['gcycl'  ] = 'gcylc'
control_commands['run'    ] = 'run' 
control_commands['start'  ] = 'run' 
control_commands['stop'   ] = 'stop' 
control_commands['restart'] = 'restart' 
control_commands['trigger'] = 'trigger' 
control_commands['insert' ] = 'insert' 
control_commands['remove' ] = 'remove' 
control_commands['delete' ] = 'remove' 
control_commands['kill'   ] = 'remove' 
control_commands['purge'  ] = 'purge' 
control_commands['pause'  ] = 'pause' 
control_commands['resume' ] = 'resume' 
control_commands['block'  ] = 'block' 
control_commands['unblock'] = 'unblock' 
control_commands['reset'  ] = 'reset' 
control_commands['dump'   ] = 'dump' 
control_commands['show'   ] = 'show' 
control_commands['log'    ] = 'log' 
control_commands['tmon'   ] = 'tmon' 
control_commands['lockserver'] = 'lockserver' 
control_commands['lockclient'] = 'lockclient' 
control_commands['verbosity' ] = 'verbosity' 
 
utility_commands = {}
utility_commands['cycletime'] = 'cycletime'
utility_commands['checkvars'] = 'checkvars'
utility_commands['template' ] = 'template'
utility_commands['housekeep'] = 'housekeep'
utility_commands['transfer' ] = 'transfer'

database_commands = {}
database_commands['gcylc'     ] = 'gcylc'
database_commands['register'  ] = 'register'
database_commands['reregister'] = 'reregister'
database_commands['unregister'] = 'unregister'
database_commands['copy'      ] = 'copy'
database_commands['cp'        ] = 'copy'
database_commands['print'     ] = 'print'
database_commands['export'    ] = 'export'
database_commands['import'    ] = 'import'

prepare_commands = {}
prepare_commands['gcylc'   ] = 'gcylc'
prepare_commands['gcycl'   ] = 'gcylc'
prepare_commands['edit'    ] = 'edit'
prepare_commands['inline'  ] = 'inline'
prepare_commands['validate'] = 'validate'
prepare_commands['search'  ] = 'search'
prepare_commands['grep'    ] = 'search'
prepare_commands['graph'   ] = 'graph'

discover_commands = {}
discover_commands['ping'] = 'ping'
discover_commands['scan'] = 'scan'

task_commands = {}
task_commands['wrap'] = 'wrap'
task_commands['submit'] = 'submit'
task_commands['single'] = 'submit'
task_commands['started'] = 'started'
task_commands['message'] = 'message'
task_commands['finished'] = 'finished'
task_commands['failed'] = 'failed'

task_commands['task-started' ] = 'started'
task_commands['task-finished'] = 'finished'
task_commands['task-failed'  ] = 'failed'
task_commands['task-message' ] = 'message'

general_usage = """
USAGE:
  cylc help,--help,-h,?                           # this help page
  cylc -v,--version                               # release version
  cylc help CATEGORY                              # help by category
  cylc CATEGORY help                              # (ditto)
  cylc help [CATEGORY] COMMAND                    # command help
  cylc [CATEGORY] COMMAND help,--help             # (ditto)

  cylc [CATEGORY] COMMAND [options] SUITE [args]  # command syntax"""

# topic summaries
catsum = OrderedDict()
catsum['database'  ]     = "(or db) local and central suite registration."
catsum['information' ] = "retrieve and print information about a suite."
catsum['prepare'  ]      = "suite editing, graphing, validiation etc."
catsum['discover' ]      = "what suites are running at the moment?"
catsum['control'  ]      = "running, monitoring, and controlling suites."
catsum['task'     ]      = "running single tasks, task wrapping and messaging."
catsum['utility'  ]      = "cycle time arithmetic, filename templating, etc."

# was in help doc:
##Cylc suites are not artificially grouped by forecast cycle; tasks from
##multiple cycles run at once, during catchup operation, to the maximum
##extent allowed by the suite dependency graph.

usage = """
This is the cylc ('silk') metascheduler command line interface.
       *** The graphical user interface is gcylc. ***

Version: """ + cylc_version + """
""" + general_usage + """

CATEGORIES help to organise this documentation, but their use on the
commandline is [optional]. Any unique abbreviation can be used for a
COMMAND or CATEGORY, and some common typos (cylc|cycl) are corrected.
  $ cylc help prep ......... (cylc help prepare)
  $ cylc help [prep] ed .... (cylc help [prepare] edit)
  $ cylc [prep] ed help .... (cylc [prepare] edit help)
  $ cylc [info] li SUITE ... (cylc [information] list SUITE) 

Command CATEGORIES (which include lists of relevant COMMANDS):"""

if len(sys.argv) == 1:
    print usage
    pretty_print( catsum, catsum.keys() )
    sys.exit(1)

# command summaries
comsum = OrderedDict()
# database
comsum[ 'register'   ] = 'Add a suite to your local registration database'
comsum[ 'reregister' ] = 'Reregister local or central suite registrations'
comsum[ 'unregister' ] = 'Unregister suites from the local or central database'
comsum[ 'copy'       ] = 'Copy a suite or group of suites.'
comsum[ 'cp'         ] = comsum['copy']
comsum[ 'print'      ] = 'Print local or central suite registrations'
comsum[ 'import'     ] = 'Import central registrations to your local database'
comsum[ 'export'     ] = 'Export local registrations to the central database'
# prepare
comsum[ 'edit'       ] = 'Edit a suite.rc file in $EDITOR, optionally inlined'
comsum[ 'inline'     ] = 'View suite.rc files in $EDITOR, include-files inlined'
comsum[ 'validate'   ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'search'     ] = 'An intelligent search tool for cylc suites'
comsum[ 'grep'       ] = comsum['search']
comsum[ 'graph'      ] = 'A dependency graph viewer that updates as you edit'
# information
comsum[ 'list'       ] = 'Print a suite\'s task list'
comsum[ 'ls'         ] = comsum['list']
comsum[ 'describe'   ] = 'Print a suite\'s title and description'
# control
comsum[ 'gcylc'      ] = 'The cylc Graphical User Interface'
comsum[ 'gcycl'      ] = comsum['gcylc']
comsum[ 'run'        ] = 'Cold, warm, or raw start a suite at a given cycle time'
comsum[ 'start'      ] = comsum['run']
comsum[ 'stop'       ] = 'Shut down a running suite (now or later)'
comsum[ 'restart'    ] = 'Restart a suite from a previous state'
comsum[ 'trigger'    ] = 'Manually trigger a task in a running suite'
comsum[ 'insert'     ] = 'Insert a task or group into a running suite'
comsum[ 'remove'     ] = 'Remove a task from a running suite'
comsum[ 'purge'      ] = 'Remove a full dependency tree from a running suite'
comsum[ 'pause'      ] = 'Pause a running suite (stop submitting tasks)'
comsum[ 'resume'     ] = 'Resume submitting tasks in a paused suite'
comsum[ 'block'      ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'    ] = 'Comply with subsequent intervention commands'
comsum[ 'reset'      ] = 'Force a task to waiting, ready, or finished state'
comsum[ 'dump'       ] = 'Print the state of each task in a running suite'
comsum[ 'show'       ] = 'Print task-specific information (prerequisites...)'
comsum[ 'log'        ] = 'Print or view suite logs, with filtering'
comsum[ 'tmon'       ] = 'An in-terminal suite monitor (deprecated, see gcylc)'
comsum[ 'lockserver' ] = 'The cylc lockserver daemon'
comsum[ 'lockclient' ] = 'Manual suite and task lock management'
comsum[ 'verbosity'  ] = 'Change a suite\'s logging verbosity level'
# discover
comsum[ 'ping'       ] = 'Check that a named suite is running'
comsum[ 'scan'       ] = 'Scan a host for running cylc suites and lockservers'
# task
comsum[ 'wrap'       ] = 'Use an existing script or program as a cylc task'
comsum[ 'submit'     ] = 'Run a single task just as its parent suite would'
comsum[ 'single'     ] = comsum['submit']
comsum[ 'started'    ] = 'Acquire a task lock and report started'
comsum[ 'message'    ] = 'Report completion of outputs, etc.'
comsum[ 'finished'   ] = 'Release task lock and report finished'
comsum[ 'failed'     ] = 'Release task lock and report failure'

comsum[ 'task-started'  ] = 'DEPRECATED: use started'
comsum[ 'task-message'  ] = 'DEPRECATED: use message.'
comsum[ 'task-finished' ] = 'DEPRECATED: use finished'
comsum[ 'task-failed'   ] = 'DEPRECATED: use failed'

# utility
comsum[ 'cycletime'  ] = 'Cycle time arithmetic'
comsum[ 'checkvars'  ] = 'Check required environment variables en masse'
comsum[ 'template'   ] = 'Powerful cycle time offset filename templating'
comsum[ 'housekeep'  ] = 'Parallel archiving and cleanup on cycle time offsets'
comsum[ 'transfer'   ] = 'An scp-based file transfer tool'
 
def category_help(category):
    coms = eval( category + '_commands')
    commands = coms.keys()
    print 'CATEGORY: ' + category + ' - ' + catsum[ category ]
    print
    print 'USAGE: cylc [' + category + '] COMMAND help,--help'
    print '  You can abbreviate "' + category + '" and COMMAND.'
    print '  The category "' + category + '" may be omitted.'
    print
    print 'COMMANDS:'
    pretty_print( comsum, commands )

# check that the cylc core modules are accessible
try:
    import cylc
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "SOLUTION: source $CYLC_DIR/cylc-env.sh in your shell." 
    sys.exit(1)

# manipulate command arguments

args = sys.argv[1:]

# cylc help
if len( args ) == 1 and is_help( args[0] ):
    print usage
    pretty_print( catsum, catsum.keys() )
    sys.exit(0)

# cylc -v,--version
if len( args ) == 1 and \
        ( args[0] == '-v' or args[0] == '--version' ):
    print cylc_version
    sys.exit(0)

all_commands = comsum.keys()
command_args = []

# TWO ARGUMENTS, one help
# cylc help CATEGORY
# cylc CATEGORY help
# cylc help COMMAND
# cylc COMMAND help

if len( args ) == 2 and ( is_help(args[0]) or is_help(args[1])):
    if is_help( args[1] ):
        item = args[0]
    else:
        item = args[1]
    try:
        category = match_dict( item, categories )
    except CommandError, x:
        # no matching category, try command
        print x
        print 'Trying Commands...'
        try:
            command = match_list( item, all_commands )
        except CommandError, y:
            raise SystemExit(y)
        else:
            # cylc COMMAND --help
            command_args = [ '--help' ]
    else:
        # cylc help CATEGORY
        category_help( category )
        sys.exit(0)

elif len( args ) == 3 and ( is_help(args[0]) or is_help(args[2])):
    # cylc help CATEGORY COMMAND
    # cylc CATEGORY COMMAND help
    if is_help( args[2] ):
        category = args[0]
        command = args[1]
    else:
        category = args[1]
        command = args[2]
    try:
        category = match_dict( category, categories )
    except CommandError, x:
        raise SystemExit(x)

    coms = eval( category + '_commands')
    try:
        command = match_dict( command, coms )
    except CommandError, y:
        print y
        print 'Commands available in category ' + category + ':'
        print coms.keys()
        sys.exit(1)
    
    # cylc COMMAND --help
    command_args = [ '--help' ]

else:
    # two or more args, neither of first two are help
    # cylc CATEGORY COMMAND [ARGS]
    # cylc COMMAND [ARGS]
    try:
        category = args[0]
        category = match_dict( category, categories )
    except CommandError, x:
        # no matching category, try command
        print x
        print 'Trying Commands...'
        try:
            command = args[0]
            command = match_list( command, all_commands )
        except CommandError, y:
            raise SystemExit(y)
        else:
            # cylc COMMAND [ARGS]
            command_args = args[1:]
    else:
        # cylc CATEGORY COMMAND [ARGS]
        commands = eval( category + '_commands')
        command = args[1]
        try:
            command = match_dict( command, coms )
        except CommandError, y:
            print y
            print 'Commands available in category ' + category + ':'
            print commands
            sys.exit(1)
 
        else:
            # cylc COMMAND [ARGS]
            if len(args) > 1:
                command_args = args[2:]
            else:
                command_args = []

# check for help anywhere in the arg list and transform to '--help'
args_new = []
for item in command_args:
    if is_help( item ):
        args_new.append( '--help' )
    else:
        args_new.append( item )
args = args_new

notify=False
if command not in ['cycletime', 'template']:
    # notify => print 'DONE' when command is completed, which is 
    # helpful for gui command capture windows. But some utilities return
    # specific results by stdout, which we don't want to contaminate.
    notify=True

# construct command to execute
# DEPRECATED TASK COMMANDS (backward compatibility):
if command in [ 'task-started', 'task-finished', 'task-failed', 'task-message' ]:
    command = re.sub( '^task-', '', command )

execute( [ '_' + command ] + args, notify=notify )
