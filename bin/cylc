#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os, re, sys

sys.path.append(os.path.dirname(os.path.abspath(__file__)) + '/../lib')

from OrderedDict import OrderedDict
from cylc.execute import execute

# check Pyro is installed
try:
    import Pyro.constants
except Exception, x:
    raise SystemExit('ERROR: Pyro is not installed (or not accessible)')

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def is_help( str ):
    if str == '-h' or \
        str == '--help' or \
        str == '--hlep' or \
        str == 'help' or \
        str == 'hlep' or \
        str == '?':
        return True
    else:
        return False

def match_dict( abbrev, categories, title ):
    # allow any unique abbreviation to cylc categories
    matches = []
    for cat in categories.keys():
        for alias in categories[cat]:
            if re.match( '^' + abbrev + '.*', alias ):
                if cat not in matches:
                    matches.append( cat )
    if len( matches ) == 0:
        raise CommandNotFoundError, title + ' not found: ' + abbrev
    elif len( matches ) > 1:
        # multiple matches
        res = ''
        for cat in matches:
            res += ' ' + '|'.join(categories[cat])
        raise CommandNotUniqueError, title + ' "' + abbrev + '" not unique:' + res
    else:
        return matches[0]

def match_command( abbrev ):
    # allow any unique abbreviation to commands when no category is specified
    matches = []
    for dct in [ 
        admin_commands,
        license_commands,
        database_commands, 
        preparation_commands, 
        information_commands, 
        discovery_commands, 
        control_commands, 
        utility_commands,
        task_commands ]:
        for com in dct.keys():
            for alias in dct[com]:
                if re.match( '^' + abbrev + '.*', alias ):
                    if com not in matches:
                        matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, 'COMMAND not found: ' + abbrev
    elif len( matches ) > 1:
        # multiple matches
        res = ''
        for com in matches:
            res += ' ' + '|'.join(all_commands[com])
        raise CommandNotUniqueError, 'COMMAND "' + abbrev + '" not unique:' + res
    else:
        return matches[0]

def pretty_print( incom, choose_dict, indent=True, numbered=False ):
    # pretty print commands or topics from a dict:
    # (com[item] = description)
    
    if indent:
        spacer = ' '
    else:
        spacer = ''

    label = {}
    choose = []
    longest = 0
    for item in choose_dict:
        choose.append( item )
        lbl = '|'.join(choose_dict[item])
        label[item] = lbl
        if len( lbl ) > longest:
            longest = len( lbl )

    count = 0
    pad = False
    if len(choose) > 9:
        pad = True

    for item in choose:
        if item not in incom:
            raise SystemExit( "ERROR: summary for '" + item + "' not found" )

        print spacer,
        if numbered:
            count += 1
            if pad and count < 10:
                digit = ' ' + str(count)
            else:
                digit = str(count)
            print digit + '/', 
        print label[item], '.'*(longest-len(label[item])) + '...', incom[item]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

# categories[ categorey ] = [ aliases ] 
categories = OrderedDict()
categories['all'         ] = ['all' ]
categories['database'    ] = ['db', 'database' ]
categories['preparation' ] = ['preparation' ]
categories['information' ] = ['information'    ]
categories['discovery'   ] = ['discovery' ]
categories['control'     ] = ['control' ]
categories['utility'     ] = ['utility' ]
categories['task'        ] = ['task' ]
categories['admin'       ] = ['admin' ]
categories['license'     ] = ['license', 'GPL' ]
 
information_commands = OrderedDict()
information_commands['gcylc'    ] = ['gcylc'      ]
information_commands['list'     ] = ['list', 'ls' ]
information_commands['describe' ] = ['describe'   ]
information_commands['dump'     ] = ['dump'       ]
information_commands['show'     ] = ['show'       ]
information_commands['log'      ] = ['log'        ]
information_commands['monitor'  ] = ['monitor'  ]
information_commands['nudge'    ] = ['nudge' ]

control_commands = OrderedDict()
control_commands['gcylc'  ] = information_commands[ 'gcylc' ]
# NOTE: don't change 'run' to 'start' or the category [control]
# becomes compulsory to disambiguate from 'cylc [task] started'.
# Keeping 'start' as an alias however: 'cylc con start'.
control_commands['run'    ] = ['run', 'start' ]
control_commands['stop'] = ['stop', 'shutdown' ]
control_commands['restart'] = ['restart' ]
control_commands['trigger'] = ['trigger' ]
control_commands['insert' ] = ['insert' ]
control_commands['remove' ] = ['remove', 'kill' ]
control_commands['purge'  ] = ['purge' ]
control_commands['hold'   ] = ['hold' ]
control_commands['release' ] = ['release', 'unhold' ]
control_commands['block'  ] = ['block' ]
control_commands['unblock'] = ['unblock' ] 
control_commands['reset'  ] = ['reset'  ]
control_commands['nudge'  ] = ['nudge' ]
control_commands['depend' ] = ['depend']
control_commands['maxrunahead'] = ['maxrunahead']
control_commands['lockserver'] = ['lockserver' ]
control_commands['lockclient'] = ['lockclient', 'lc' ]
control_commands['verbosity' ] = ['verbosity' ]
 
utility_commands = OrderedDict()
utility_commands['cycletime'    ] = ['cycletime' ]
utility_commands['checkvars'    ] = ['checkvars'] 
utility_commands['template'     ] = ['template'] 
utility_commands['jobscript'    ] = ['jobscript'] 
utility_commands['housekeeping' ] = ['housekeeping'] 
utility_commands['scp-transfer' ] = ['scp-transfer'] 
utility_commands['email-alert'  ] = ['email-alert'] 
admin_commands = OrderedDict()
admin_commands['create-cdb'  ] = [ 'create-cdb']
admin_commands['test-db'     ] = [ 'test-db']
admin_commands['test-suite'  ] = [ 'test-suite']

license_commands = OrderedDict()
license_commands['warranty'  ] = [ 'warranty']
license_commands['conditions'] = [ 'conditions']

database_commands = OrderedDict()
database_commands['gcylc'     ] = information_commands['gcylc']
database_commands['register'  ] = [ 'register' ]
database_commands['reregister'] = [ 'reregister' ]
database_commands['alias']      = [ 'alias' ]
database_commands['unregister'] = [ 'unregister' ]
database_commands['copy'      ] = [ 'copy', 'cp' ]
database_commands['print'     ] = [ 'print' ]
database_commands['get-dir'   ] = [ 'get-dir' ]
database_commands['export'    ] = [ 'export' ]
database_commands['import'    ] = [ 'import' ]
database_commands['check-registrations'   ] = [ 'check-registrations' ]

preparation_commands = OrderedDict()
preparation_commands['gcylc'   ] = information_commands['gcylc']
preparation_commands['edit'    ] = [ 'edit'    ]
preparation_commands['inline'  ] = [ 'inline'    ]
preparation_commands['validate'] = [ 'validate'    ]
preparation_commands['search'  ] = [ 'search', 'grep' ]
preparation_commands['graph'   ] = [ 'graph'    ]
preparation_commands['diff'    ] = [ 'diff', 'compare' ]

discovery_commands = OrderedDict()
discovery_commands['ping'] = [ 'ping' ]
discovery_commands['scan'] = [ 'scan' ]

task_commands = OrderedDict()
task_commands['submit'] = [ 'submit', 'single' ]
task_commands['started'] = [ 'started', 'task-started' ]
task_commands['message'] = [ 'message', 'task-message' ]
task_commands['succeeded'] = [ 'succeeded', 'task-succeeded' ]
task_commands['failed'] = [ 'failed', 'task-failed' ]

all_commands = OrderedDict()
for dct in [ 
        database_commands, 
        preparation_commands, 
        information_commands, 
        discovery_commands, 
        control_commands, 
        utility_commands,
        task_commands,
        admin_commands,
        license_commands ]:
    for com in dct.keys():
        all_commands[com] = dct[com]
 
general_usage = """
USAGE:
  cylc help,--help,-h,?                           # this help page
  cylc -v,--version                               # release version
  cylc help CATEGORY                              # help by category
  cylc CATEGORY help                              # (ditto)
  cylc help [CATEGORY] COMMAND                    # command help
  cylc [CATEGORY] COMMAND help,--help             # (ditto)

  cylc [CATEGORY] COMMAND [options] SUITE [args]  # command syntax"""

# topic summaries
catsum = OrderedDict()
catsum['all'    ]        = "the complete cylc command set"
catsum['admin'       ]   = "commands for use by the cylc administrator."
catsum['license'     ]   = "Software licensing information (GPL v3.0)."
catsum['database'    ]   = "private and central suite registration."
catsum['information' ]   = "retrieve and print information about a suite."
catsum['preparation' ]   = "suite editing, graphing, validation etc."
catsum['discovery'   ]   = "what suites are running at the moment?"
catsum['control'     ]   = "running, monitoring, and controlling suites."
catsum['task'        ]   = "running single tasks, and task messaging commands."
catsum['utility'     ]   = "cycle time arithmetic, filename templating, etc."

# was in help doc:
##Cylc suites are not artificially grouped by forecast cycle; tasks from
##multiple cycles run at once, during catchup operation, to the maximum
##extent allowed by the suite dependency graph.

usage = """cylc release version: """ + cylc_version + """
""" + general_usage + """

Any unique abbreviation can be used for a COMMAND or CATEGORY, e.g.:
  $ cylc control trigger SUITE TASK  # manually trigger TASK in SUITE
  $ cylc con trig SUITE TASK         # ditto
  $ cylc c t SUITE TASK              # ditto!
Use of categories is optional,
  $ cylc trig SUITE TASK             # ditto
but they provide structure to the command set, and they disambiguate
highly abbreviated commands. Some commands are aliased (ls|list), and 
some common typos are automatically corrected (cylc,cycl; help,hlep).

Note that 'SUITE' refers to a suite's registered [OWNER:]GROUP:NAME, 
and 'TASK' refers to the unique NAME%TAG of a task in a suite. For 
cycling tasks TAG is a cycle time (e.g. foo%2011080806), and for 
asynchronous tasks it is an integer preceded by 'a:' (e.g. foo%a:1).

How to drill down to usage help for a particular command:
  $ cylc help ............... list all available categories (this page)
  $ cylc help prep .......... list commands in category 'preparation'
  $ cylc help [prep] edit ... command usage help for 'cylc [prep] edit'

Command CATEGORIES:"""

# command summaries
comsum = OrderedDict()
# admin
comsum[ 'create-cdb' ] = '(ADMIN) Create the central suite database'
comsum[ 'test-db'    ] = '(ADMIN) Automated suite database test'
comsum[ 'test-suite' ] = '(ADMIN) Automated cylc scheduler test'
# license
comsum[ 'warranty'   ] = 'Print the GPLv3 disclaimer of warranty'
comsum[ 'conditions' ] = 'Print the GNU General Public License v3.0'
# database
comsum[ 'register'   ] = 'Add a suite to your private registration database'
comsum[ 'reregister' ] = 'Change private or central suite registrations'
comsum[ 'alias'      ] = 'Register an alias for another registered suite'
comsum[ 'unregister' ] = 'Remove suites from the private or central database'
comsum[ 'copy'       ] = 'Copy a suite or group of suites.'
comsum[ 'print'      ] = 'Print private or central suite registrations'
comsum[ 'get-dir'    ] = 'Print a suite definition directory path'
comsum[ 'import'     ] = 'Import central registrations to your private database'
comsum[ 'export'     ] = 'Export private registrations to the central database'
comsum[ 'check-registrations'] = 'Report invalid registrations and update suite titles'
# preparation
comsum[ 'edit'       ] = 'Edit a suite.rc file in $EDITOR, optionally inlined'
comsum[ 'inline'     ] = 'View suite.rc files in $EDITOR, include-files inlined'
comsum[ 'validate'   ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'search'     ] = 'An intelligent search tool for cylc suites'
comsum[ 'graph'      ] = 'A dependency graph viewer that updates as you edit'
comsum[ 'diff'       ] = 'Compare two suite definitions and print differences'
# information
comsum[ 'list'       ] = 'Print a suite\'s task list'
comsum[ 'describe'   ] = 'Print a suite\'s title and description'
comsum[ 'dump'       ] = 'Print the state of each task in a running suite'
comsum[ 'show'       ] = 'Print task-specific information (prerequisites...)'
comsum[ 'log'        ] = 'Print or view suite logs, with filtering'
comsum[ 'monitor'    ] = 'An in-terminal suite monitor (see also gcylc)'
# control
comsum[ 'gcylc'      ] = 'The cylc Graphical User Interface'
comsum[ 'run'        ] = 'Start a suite running at a specified cycle time'
comsum[ 'stop'       ] = 'Stop a suite running by various means'
comsum[ 'restart'    ] = 'Restart a suite from a previous state'
comsum[ 'trigger'    ] = 'Cause a task to trigger immediately'
comsum[ 'insert'     ] = 'Insert a task or group into a running suite'
comsum[ 'remove'     ] = 'Remove a task from a running suite'
comsum[ 'purge'      ] = 'Remove a full dependency tree from a running suite'
comsum[ 'hold'       ] = 'Put a hold on a suite or a single task'
comsum[ 'release'    ] = 'Release a  hold on a suite or a single task'
comsum[ 'block'      ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'    ] = 'Comply with subsequent intervention commands'
comsum[ 'reset'      ] = 'Force a task to waiting, ready, or succeeded state'
comsum[ 'nudge'      ] = 'Cause the cylc task processing loop to be invoked'
comsum[ 'depend'     ] = 'Add prerequisites to tasks on the fly'
comsum[ 'maxrunahead'   ] = 'Change the runahead limit in a running suite.'
comsum[ 'lockserver' ] = 'The cylc lockserver daemon'
comsum[ 'lockclient' ] = 'Manual suite and task lock management'
comsum[ 'verbosity'  ] = 'Change a suite\'s logging verbosity level'
# discovery
comsum[ 'ping'       ] = 'Check that a suite is running'
comsum[ 'scan'       ] = 'Scan a host for running suites and lockservers'
# task
comsum[ 'submit'     ] = 'Run a single task just as its parent suite would'
comsum[ 'started'    ] = 'Acquire a task lock and report started'
comsum[ 'message'    ] = 'Report progress and completion of outputs'
comsum[ 'succeeded'   ] = 'Release task lock and report succeeded'
comsum[ 'failed'     ] = 'Release task lock and report failure'

# utility
comsum[ 'cycletime'    ] = 'Cycle time arithmetic'
comsum[ 'checkvars'    ] = 'Check required environment variables en masse'
comsum[ 'template'     ] = 'Powerful cycle time offset filename templating'
comsum[ 'jobscript'    ] = 'Generate a task job script and print it to stdout'
comsum[ 'housekeeping' ] = 'Parallel archiving and cleanup on cycle time offsets'
comsum[ 'scp-transfer' ] = 'Scp-based file transfer for cylc suites'
comsum[ 'email-alert'  ] = 'Send alerts by email when tasks fail (for example)'

def typo( str ):
    corrected = str
    if str == 'gcycl':
        corrected = 'gcylc'
    return corrected
 
def category_help(category):
    coms = eval( category + '_commands')
    alts = '|'.join(categories[category])
    print 'CATEGORY: ' + alts + ' - ' + catsum[ category ]
    print
    print 'HELP: cylc [' + alts + '] COMMAND help,--help'
    print '  You can abbreviate ' + alts + ' and COMMAND.'
    print '  The category ' + alts + ' may be omitted.'
    print
    print 'COMMANDS:'
    pretty_print( comsum, coms )

# no arguments: print help and exit
if len(sys.argv) == 1:
    print usage
    pretty_print( catsum, categories )
    sys.exit(1)

args = sys.argv[1:]

if '--notify-completion' in args:
    notify = True
    args.remove('--notify-completion')
else:
    notify = False

if len(args) == 1:
    if args[0] == 'categories':
        # secret argument for document processing
        keys = catsum.keys()
        keys.sort()
        for key in keys:
            print key
        sys.exit(0)
    if args[0] == 'commands':
        # secret argument for document processing
        keys = comsum.keys()
        keys.sort()
        for key in keys:
            print key
        sys.exit(0)
    if args[0] == 'print-cdb-dir':
        # temporary secret argument used by create-cdb
        from cylc.conf.CylcGlobals import central_regdb_dir
        print central_regdb_dir
        sys.exit(0)
    if is_help( args[0] ):
        # cylc help
        print usage
        pretty_print( catsum, categories)
        sys.exit(0)
    if ( args[0] == '-v' or args[0] == '--version' ):
        # cylc -v,--version
        print cylc_version
        sys.exit(0)

    # cylc CATEGORY with no args => category help
    try:
        category = match_dict( args[0], categories, 'CATEGORY' )
    except CommandError, x:
        # No matching category
        # print >> sys.stderr, x # (no need to print this, the exception will recur below)
        # Carry on in case of a no-argument command (e.g. 'cylc scan')
        pass
    else:
        category_help( category )
        sys.exit(0)
 
command_args = []

if len( args ) == 2 and ( is_help(args[0]) or is_help(args[1])):
    # TWO ARGUMENTS, one help
    # cylc help CATEGORY
    # cylc CATEGORY help
    # cylc help COMMAND
    # cylc COMMAND help
    if is_help( args[1] ):
        item = args[0]
    else:
        item = args[1]
    try:
        category = match_dict( item, categories, 'CATEGORY' )
    except CommandError, x:
        # no matching category, try command
        try:
            command = match_command( typo(item) )
        except CommandError, y:
            print >> sys.stderr, x
            raise SystemExit(y)
        else:
            # cylc COMMAND --help
            command_args = [ '--help' ]
    else:
        # cylc help CATEGORY
        category_help( category )
        sys.exit(0)

elif len( args ) == 3 and ( is_help(args[0]) or is_help(args[2])):
    # cylc help CATEGORY COMMAND
    # cylc CATEGORY COMMAND help
    if is_help( args[2] ):
        category = args[0]
        command = args[1]
    else:
        category = args[1]
        command = args[2]
    try:
        category = match_dict( category, categories, 'CATEGORY' )
    except CommandError, x:
        raise SystemExit(x)

    coms = eval( category + '_commands')
    try:
        command = match_dict( command, coms, category + ' COMMAND' )
    except CommandNotUniqueError, y:
        print y
        sys.exit(1)
    except CommandNotFoundError, y:
        print y
        print 'COMMANDS available in CATEGORY "' + category + '":'
        print coms.keys()
        sys.exit(1)
    
    # cylc COMMAND --help
    command_args = [ '--help' ]

else:
    # two or more args, neither of first two are help
    # cylc CATEGORY COMMAND [ARGS]
    # cylc COMMAND [ARGS]
    try:
        category = args[0]
        category = match_dict( category, categories, 'CATEGORY' )
    except CommandError, x:
        # no matching category, try command
        try:
            command = args[0]
            command = match_command( typo(command) )
        except CommandError, y:
            print >> sys.stderr, x
            raise SystemExit(y)
        else:
            # cylc COMMAND [ARGS]
            command_args = args[1:]
    else:
        # cylc CATEGORY COMMAND [ARGS]
        coms = eval( category + '_commands')
        command = args[1]
        try:
            command = match_dict( command, coms, category + ' COMMAND' )
        except CommandNotUniqueError, y:
            print y
            sys.exit(1)
        except CommandNotFoundError, y:
            print y
            print 'COMMANDS available in CATEGORY "' + category + '":'
            print coms.keys()
            sys.exit(1)
 
        else:
            # cylc COMMAND [ARGS]
            if len(args) > 1:
                command_args = args[2:]
            else:
                command_args = []

# check for help anywhere in the arg list and transform to '--help'
args_new = []
for item in command_args:
    if is_help( item ):
        args_new.append( '--help' )
    else:
        args_new.append( item )
args = args_new

# construct command to execute
# DEPRECATED TASK COMMANDS (backward compatibility):
if command in [ 'task-started', 'task-succeeded', 'task-failed', 'task-message' ]:
    command = re.sub( '^task-', '', command )

try:
    execute( [ '_' + command ] + args, notify=notify )
except KeyboardInterrupt:
    pass
