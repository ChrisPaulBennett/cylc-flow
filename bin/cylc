#!/bin/bash
#
# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) 2008-2017 NIWA
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
CATEGORIES=('control' 'con' 'information' 'info' 'all' 'task' 'license' \
            'GPL' 'admin' 'prep' 'preparation' 'hook' 'discovery' 'utility' \
            'util')
                
HELP_OPTS=('help' '--help' '-h' 'h' '?')

get_version() {
    # If there is a version file present, use that
    if [[ -f "${CYLC_HOME}/VERSION" ]]; then
        CYLC_VERSION="$(cat ${CYLC_HOME}/VERSION)"
    # Otherwise, use git (if in a git repo) to determine version
    elif [[ -d "${CYLC_HOME}/.git" ]]; then
        local DESC=
        DESC="$(cd ${CYLC_HOME} && git describe --abbrev=4 2>/dev/null)"
        CYLC_VERSION="${DESC}"
        # Append "-dirty" if there are uncommitted changes.
        if [[ -n "$(cd ${CYLC_HOME} && git status \
                --untracked-files=no --porcelain)" ]]; then
            CYLC_VERSION="${CYLC_VERSION}-dirty"
        fi
    # Else we must be in a standalone cylc folder/tarball with no verion info.
    # (make has not yet been run)
    # TODO what if the user has just run git init? That would not be a proper
    # git clone of the cylc repo...
    else
        echo "No version is set, cylc must be built first"
    fi
}

print_version() {
    get_version
    if [[ "$#" -eq 0 ]]; then
        echo "$CYLC_VERSION"
    fi
    if [[ "$@" == 'long' ]]; then
        echo "Cylc ${CYLC_VERSION} (${CYLC_HOME})"
    fi
}

init_cylc() {
    set -eu
    CYLC_HOME_BIN="$(dirname "$(readlink -f "$0")")"
    CYLC_HOME="$(dirname "${CYLC_HOME_BIN}")"
    CYLC_NS="$(basename $0)"
    CYLC_DIR="${CYLC_HOME}"
    
    get_version
    
    PATH="$(path_lead "${PATH:-}" "${CYLC_HOME_BIN}")"
    PYTHONPATH="$(path_lead "${PYTHONPATH:-}" "${CYLC_HOME}/lib/")"
    PYTHONUNBUFFERED='true'
    
    export PATH PYTHONPATH PYTHONUNBUFFERED CYLC_DIR CYLC_VERSION
}

help_util() {
    # Deals with form 'cylc [COMMAND] --help'
    cd "${CYLC_HOME_BIN}"
   # deal with graph which is a weird edge case...
    if [[ "$@" == "graph" ]]; then
        local COMMAND="${CYLC_HOME_BIN}/cylc-graph"
        exec "${COMMAND}" "--help"
    fi
    # Check if this is a help command, not containing a category qualifier
    if [[ (( "$#" -gt 1 )) && "${HELP_OPTS[*]} " == *" ${UTIL} "* && 
          "${CATEGORIES[*]} " != *" $1 "* &&
          "${CATEGORIES[*]} " != *" $2 "* ]]; then
        local COMMAND="${CYLC_HOME_BIN}/cylc-$1"
        exec "${COMMAND}" "--help"
    fi
    # Deal with cases like 'cylc --help [COMMAND/CATEGORY] or cylc [CATEGORY]'   
    if [[ (( "$#" -ge 1 )) && -f "$(ls cylc-${1}* 2>/dev/null)" ]]; then
        local COMMAND="${CYLC_HOME_BIN}/$(ls "cylc-$1"*)"
        exec "${COMMAND}" "--help"
    fi
    # Deal with cases like 'cylc --help [COMMAND/CATEGORY]'
    if [[ (( "$#" -gt 1 )) && -f "$(ls cylc-${2}* 2>/dev/null)" ]]; then
        local COMMAND="${CYLC_HOME_BIN}/$(ls "cylc-$2"*)"
        exec "${COMMAND}" "--help"
    fi
    
    # If category name is used, call the help func with the category
    if [[ " ${CATEGORIES[*]} " == *" ${UTIL} "* 
            || " ${HELP_OPTS[*]} " == *" ${UTIL} "* ]]; then
        local COMMAND="${CYLC_HOME_BIN}/cylc-help"
        exec "${COMMAND}" "$@"
    fi
    
    # If not a category or not an actual command in the bin dir, exit
    if [[ ! -f "$(ls "cylc-${UTIL}"*)" ]]; then
        echo "${UTIL}: unknown utility. Abort." >&2
        echo "Type 'cylc help' for a list of utilities."
        return 1
    fi
    
    echo "Something has gone terribly wrong if you are here..."
    return 1 
}

category_help_command() {
# Special case for printing categories and the gcylc gui
    local COMMAND="${CYLC_HOME_BIN}/cylc-help"
    exec "${COMMAND}" "categories"
}

path_lead() {
# Ensure that ITEM_STR is at the beginning of PATH_STR
    local PATH_STR="$1"
    local ITEM_STR="$2"
    if [[ -z "${PATH_STR:-}" ]]; then
        echo "${ITEM_STR}"
    elif [[ "${PATH_STR}" != "${ITEM_STR}" \
            && "${PATH_STR}" != "${ITEM_STR}":* ]]; then
        while [[ "${PATH_STR}" == *:"${ITEM_STR}" ]]; do
            PATH_STR=${PATH_STR%:$ITEM_STR}
        done
        while [[ "${PATH_STR}" == *:"${ITEM_STR}":* ]]; do
            local PATH_HEAD="${PATH_STR%:$ITEM_STR:*}"
            local PATH_TAIL="${PATH_STR##*:$ITEM_STR:}"
            PATH_STR="${PATH_HEAD}:${PATH_TAIL}"
        done
        echo "${ITEM_STR}:${PATH_STR}"
    else
        echo "${PATH_STR}"
    fi
}

abort_bad_command() {
    echo "${CYLC_NS}: ${UTIL}: unknown utility. Abort." >&2
    echo "Type \"${CYLC_NS} help all\" for a list of utilities." >&2
    exit 1
}

abort_ambiguous_command() {
    echo "\"${UTIL}\" is too ambiguous to be a valid Cylc command abbreviation."
    echo "These commands match the abbreviation \"${UTIL}\":"
    ls "${CYLC_HOME_BIN}/cylc-${UTIL}"* 2>/dev/null \
        | sed -r "s,${CYLC_HOME_BIN}/cylc-,,"
    exit 1
}

run_cylc_command_matched() {
    COMMAND=$(ls "${CYLC_HOME_BIN}/cylc-${UTIL}"*)
    if [[ ! -f "${COMMAND}" || ! -x "${COMMAND}" ]]; then
        abort_bad_command
    fi
    CYLC_UTIL="$(sed -r "s,${CYLC_HOME_BIN}/cylc-,," <<<"${COMMAND}")"
    export CYLC_UTIL
    exec "${COMMAND}" "$@"
}

run_cylc_command() {
    COMMAND=$(ls "${CYLC_HOME_BIN}/cylc-${UTIL}")
    if [[ ! -f "${COMMAND}" || ! -x "${COMMAND}" ]]; then
        abort_bad_command
    fi
    CYLC_UTIL="${UTIL}"
    export CYLC_UTIL
    exec "${COMMAND}" "$@"
}

init_cylc

UTIL="help"
if (( "$#" > 0 )); then
    UTIL="$1"
    shift 1
fi
# Test if the user has provided a valid cylc command, if so, run it.
if [[ -f "${CYLC_HOME_BIN}/cylc-${UTIL}" && "${UTIL}" != 'help'  ]]; then
    run_cylc_command "$@" 
fi

case "${UTIL}" in
# Deal with categories
control|information|all|task|license|GPL|admin|preparation|hook|discovery\
        |utility|util|prep)
    if (( "$#" == 0 )); then
        help_util "${UTIL}"
    elif (( "$#" > 0 )); then
        UTIL="$1"
        # Discard the category qualifier argument by shifting
        # the arguments along by 1.
        shift 1
    fi
    :;;
help|h|?|--help|-h)
    help_util "$@"
    exit 0
    :;;
version|--version|-V)
    print_version "$@"
    exit 0
    :;;
categories)
    category_help_command "$@"
    exit 0
    :;;
esac

# User has not given an exact cylc command, or a help, category, or version
# command.
# So now deal with matching commands and disambiguation.

# Store any matching file glob as a number for later use
# Minimises re-running ls
num_commands_match="$(ls "${CYLC_HOME_BIN}/cylc-${UTIL}"* 2>/dev/null | wc -l)"

# Abort if no matches to command abbrev, list matches if multiple matches
if (( "$num_commands_match" == 0 )); then
    abort_bad_command

# Check if command (singular) exists first.
# Needed for handling "graph" and "graph-diff"
# This is now handled above - TODO remove after testing 
#if [[ "$(ls "${CYLC_HOME_BIN}/cylc-${UTIL}" 2>/dev/null | wc -l )" \
#    -eq 1 && { run_cylc_command "$@"; }
# Now try and match abbreviated commands.

elif (( "$num_commands_match" == 1 )); then
    run_cylc_command_matched "$@"
# Now try and match abbreviated commands.
elif (( "$num_commands_match" > 1 )); then
    abort_ambiguous_command 
fi

