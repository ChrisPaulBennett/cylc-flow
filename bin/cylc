#!/usr/bin/python

import os
import sys
import subprocess

allowed_commands = \
    [ 
    'help',
    'configure',
    'schedule', 
    'control',
    'monitor',
    'monitor-r',
    'monitor-d',
    'monitor-p',
    'show-pyro',
    ]

# extract basename of the invoked command, so that we 
# can access commands at first invocation, when the
# environment has not yet been configured for cylc.
invoked_name = sys.argv[0]
basename = os.path.basename( invoked_name )
dirname = os.path.dirname( invoked_name )
if dirname != '':
    dirname = dirname + '/'

usage = \
    [ 
    'Usage: ' + basename + ' COMMAND [options] ',
    '',
    'COMMANDS:',
    '  help          Print this usage message and exit.',
    '',
    '  configure     Configure a system for scheduling.', 
    '  schedule      Start scheduling a configured system.',
    '  control       Interact with a running system.',
    '',
    '  monitor       Monitor all task proxy objects.',
    '  monitor-r     Monitor running task proxies.',
    '  monitor-d     Monitor running dummy task programs.',
    '  monitor-p     Monitor the Pyro namesever.',
    '',
    '  show-pyro [TO DO]   List systems registered with Pyro.',
    '',
    'Command Options:',
    '  ' + basename + ' COMMAND --help'
    ]

def print_usage():
    for line in usage:
        print line

if len( sys.argv ) < 1:
    # COMMAND must be supplied
    print_usage()
    sys.exit(1)

# first argument must be COMMAND
command = sys.argv[1]
if command not in allowed_commands:
    print_usage()
    sys.exit(1)

if command == 'help': 
    print_usage()
    sys.exit(0)

# remaining arguments must be command options
if len( sys.argv ) == 1:
    command_options = []
else:
    command_options = sys.argv[2:]

# construct command to execute
execute = ''

# If command options include '--system SYSTEM-NAME' or '-s SYSTEM-NAME'
# then find the named system's environment configuration script and
# source it before executing the command. 
if command != "configure":
    # configure's -s option is used in *creating* the environment
    # script; so it doesn't actually exist yet.

    for i in range( 0, len( command_options) ):
        if command_options[i] == '-s' or command_options[i] == '--system':
            sysname = command_options[i+1]

            FILE = open( os.environ['HOME'] + '/.cylc/configured/' + sysname, 'r' )
            line = FILE.read()
            system_dir = line.rstrip() 
            FILE.close()

            execute = ". " + system_dir + "/cylc-env.sh; "
            break

execute += dirname + '_cylc-' + command + ' ' + ' '.join( command_options )
# print "cylc command: " + execute 

try:
    # use of shell=True here provides access to PATH in the subprocess
    retcode = subprocess.call( execute, shell=True )
    if retcode < 0:
        # the command returned non-zero exist status
        print >> sys.stderr, execute + ' failed: ', retcode
        sys.exit(1)

except OSError:
    # the command was not invoked
    print >> sys.stderr, 'CYLC ERROR: unable to run command ' + execute
    print >> sys.stderr, "Is everything under your cylc bin directory executable?"
    print >> sys.stderr, "Have you run 'cylc configure' yet?"
    sys.exit(1)
