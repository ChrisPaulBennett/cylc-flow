#!/usr/bin/env python

from OrderedDict import OrderedDict
import os, re, sys
from execute import execute

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

categories = \
     [
     'core',
     'other',
     'prep',
     'run',
     'info',
     'lock',
     'util',
     'task',
     'all',
     ]

lock_commands = \
    [
    'cylclockd',
    'lockserver',
    'block',
    'unblock',
     ]

util_commands = \
    [ 
    'cycletime',
    'checkvars',
    'template',
    'housekeeping',
    'file-transfer',
    ]

prep_commands = \
    [
    'register',
    'edit',
    'graph',
    'search',
    'inline',
    ]

run_commands = \
    [
    'control',
    'coldstart', 
    'warmstart', 
    'rawstart', 
    'restart',
    'pause',
    'resume',
    'stop',
    'insert',
    'reset',
    'kill',
    'purge',
    'block',
    'unblock',
    'verbosity',
    'submit',
    ]

info_commands = \
    [
    'ping',
    'scan',
    'list',
    'graph',
    'dump',
    'show',
    'log',
    'view',
    'monitor',
    'lockserver',
    ]

task_commands = \
    [
    'wrap',
    'task-started',
    'task-message',
    'task-finished',
    'task-failed',
    ]

# uniquify the command list (some may reside in multiple categories)
allcom = OrderedDict()
for command in prep_commands + run_commands + info_commands + \
        task_commands + util_commands:
            allcom[ command ] = True
all_commands = allcom.keys()

# ... same for suite-related commands
corecom = OrderedDict()
for command in prep_commands + run_commands + info_commands: 
            corecom[ command ] = True
core_commands = corecom.keys()
core_commands.remove( 'monitor' )
core_commands.remove( 'inline' )
core_commands.remove( 'view' )
core_commands.remove( 'lockserver' )
core_commands.remove( 'block' )
core_commands.remove( 'unblock' )
core_commands.remove( 'verbosity' )
core_commands.remove( 'rawstart' )

other_commands = all_commands[:]
for command in core_commands:
    other_commands.remove( command )

usage = """This is the cylc metascheduler commandline interface.

Command usage:
    $ cylc COMMAND [options] SUITE [arguments]

Command-specific help:
    $ cylc COMMAND --help

Commands by category:
    $ cylc help CATEGORY

  Main categories:
    core ...... essential commands
    other ..... other commands
    all ....... the complete command set
  Finer categories: 
    prep ....... suite preparation and editing
    run ........ running and controlling suites
    info ....... getting information from suites
    lock ....... suite and task locking
    util ....... utility commands
    task ....... task wrapping and messaging

Cylc release version:
    $ cylc -v,--version

This help page:
    $ cylc help,-h,-help,--help,?,-?
    """

if len(sys.argv) == 1:
    print >> sys.stderr, usage
    sys.exit(1)

general_usage = """
USAGE: cylc COMMAND [options] SUITE [arguments]
       cylc COMMAND --help
       cylc help"""

prep_help = """
CATEGORY:prep - suite preparation and editing."""

run_help  = """
CATEGORY:run - running and controlling suites."""

info_help = """
CATEGORY:info - getting information from registered or running suites."""

core_help = """
CATEGORY:core - essential commands set for preparing and running suites."""

other_help = """
CATEGORY:other - commands not in CATEGORY:core."""

lock_help = """
CATEGORY:lock - the cylc lockserver, and operator suite locking."""

task_help = """
CATEGORY:task - task wrapping and messaging""" 

util_help = """
CATEGORY:util - utility commands designed for use with cylc."""

all_help = "The complete cylc command set."

# command summaries
comsum = {}
comsum[ 'register'  ] = 'Manage suite registrations (name -> definition dir)'
comsum[ 'cylclockd' ] = 'The cylc lockserver daemon (suite and task locking)'
comsum[ 'search'    ] = 'An intelligent search tool for cylc suites'
comsum[ 'graph'     ] = 'View a updating dependency graph as you edit a suite'
comsum[ 'inline'    ] = 'View suite.rc files with include-files inlined'
comsum[ 'edit'      ] = 'Edit suite.rc files with include-files inlined'
comsum[ 'coldstart' ] = 'Cold start a suite at a given cycle time'
comsum[ 'warmstart' ] = 'Warm start a suite at a given cycle time'
comsum[ 'rawstart'  ] = 'Raw start a suite at a given cycle time'
comsum[ 'restart'   ] = 'Restart a suite from a previous state'
comsum[ 'stop'      ] = 'Shut down a running suite (now or later)'
comsum[ 'pause'     ] = 'Pause a running suite (stop submitting ready tasks)'
comsum[ 'resume'    ] = 'Unpause a running suite (resume submitting tasks)'
comsum[ 'block'     ] = 'Tell a suite to ignore subsequent commands'
comsum[ 'unblock'   ] = 'Tell a suite to action subsequent commands'
comsum[ 'insert'    ] = 'Insert a task or group into a running suite'
comsum[ 'reset'     ] = 'Force a task to change state (manual triggering!)'
comsum[ 'kill'      ] = 'Remove tasks from a running suite'
comsum[ 'purge'     ] = 'Remove a full dependency tree from a running suite'
comsum[ 'submit'    ] = 'Submit a single task exactly as the suite would'
comsum[ 'control'   ] = 'Suite control and monitoring GUI'
comsum[ 'view'      ] = 'Suite monitoring GUI (control functions disabled)'
comsum[ 'dump'      ] = 'Print the state of each task in a running suite'
comsum[ 'show'      ] = 'Retrieve various information from a running suite'
comsum[ 'list'      ] = 'Print a suite\'s configured task list'
comsum[ 'ping'      ] = 'Check that a named suite is running'
comsum[ 'scan'      ] = 'Scan cylc ports for running suites'
comsum[ 'log'       ] = 'Print or view suite logs, with filtering'
comsum[ 'monitor'   ] = 'An in-terminal suite monitor (deprecated)'
comsum[ 'lockserver'] = 'Lockserver interrogation and management'
comsum[ 'verbosity' ] = 'Change a suite\'s logging verbosity level'
comsum[ 'cycletime' ] = 'Cycle time arithmetic'
comsum[ 'checkvars' ] = 'Check required environment variables en masse'
comsum[ 'template'  ] = 'Cycle time based filename templating'
comsum[ 'housekeeping' ] = 'Cycle time based parallel archiving and cleanup'
comsum[ 'file-transfer'] = 'An scp-based file transfer tool'
comsum[ 'wrap'         ] = 'A wrapper for running non-cylc-aware tasks'
comsum[ 'task-started' ] = 'Acquire a task lock and report started'
comsum[ 'task-message' ] = 'Report completion of outputs, etc.'
comsum[ 'task-finished'] = 'Release task lock and report finished'
comsum[ 'task-failed'  ] = 'Release task lock and report failure'
 
# check that the cylc core modules are accessible
try:
    import scheduler
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "SOLUTION: source $CYLC_DIR/cylc-env.sh in your shell." 
    sys.exit(1)

# main help
if len( sys.argv ) == 2 and \
        (sys.argv[1] == '-h' or \
        sys.argv[1] == '--help' or \
        sys.argv[1] == '-help' or \
        sys.argv[1] == 'help' or \
        sys.argv[1] == '?' or \
        sys.argv[1] == '-?'):
    print usage
    sys.exit(0)

# cylc release version
if sys.argv[1] == '-v' or sys.argv[1] == '--version':
    print cylc_version
    sys.exit(0)

# category help
cathelp = False
if sys.argv[1] == 'help' and sys.argv[2] in categories:
    # cylc help CATEGORY
    cathelp = True
    cat = sys.argv[2]
if sys.argv[1] in categories and \
        ( sys.argv[2] == 'help' or sys.argv[2] == '--help' ):
    # cylc CATEGORY help
    # cylc CATEGORY --help
    cathelp = True
    cat = sys.argv[1]

if cathelp:
    print eval (cat + '_help')
    print general_usage
    print
    print 'COMMAND:'
    output = []
    commands = eval( cat + '_commands')
    longest = len(commands[0])
    for command in commands:
        if len( command )> longest:
            longest = len( command )
    count = 0
    pad = False
    if len(commands) > 10:
        pad = True
    for command in commands:
        count += 1
        if pad and count < 10:
            digit = ' ' + str(count)
        else:
            digit = str(count)
        print ' ' + digit + '/', command, '.'*(longest-len(command)) + '...', comsum[command]
    sys.exit(0)

arglist = sys.argv[1:]
if len(arglist) == 2:
    # catch reversed usage: 'cylc help COMMAND'
    if arglist[0] == 'help' and arglist[1] in all_commands:
        arglist[0] = arglist[1]
        arglist[1] = '--help'

command = arglist[0]
options = []
if len(arglist) > 1:
    options = arglist[1:]

if command not in all_commands:
    print "ERROR, illegal cylc command: " + command
    print >> sys.stderr, usage
    sys.exit(1)

try:
    if options[0] == 'help':
        # catch 'cylc COMMAND help'
        options[0] = '--help'
except IndexError:
    pass

# construct command to execute
command = '_' + command 
commandlist = [ command ]
for f in options:
    commandlist.append( f )
execute( commandlist )
