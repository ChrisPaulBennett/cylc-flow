#!/usr/bin/env python

from OrderedDict import OrderedDict
import os, re, sys
from execute import execute

class CommandError( Exception ):
    """
    Attributes:
        message - what the problem is. 
    """
    def __init__( self, msg ):
        self.msg = msg
    def __str__( self ):
        return repr(self.msg)

class CommandNotFoundError( CommandError ):
    pass

class CommandNotUniqueError( CommandError ):
    pass

def find_command( abbrev, commands, title ):
    # allow any unique abbreviation to cylc categories and commands
    matches = []
    for com in commands:
        if re.match( '^' + abbrev + '.*', com ):
            matches.append( com )
    if len( matches ) == 0:
        raise CommandNotFoundError, title + ' not found: ' + abbrev
    elif len( matches ) > 1:
        raise CommandNotUniqueError, title + ' not unique: ' + abbrev + ' -> ' + ', '.join( matches )
    else:
        return matches[0]

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

categories = \
     [
     'preparation',
     'discovery',
     'startup',
     'shutdown',
     'monitoring',
     'interaction',
     'information',
     'tasks',
     'locking',
     'security',
     'all',
     'utilities',
     ]

locking_commands = \
    [
    #'cylclockd',
    'lockserver',
    ]

security_commands = \
    [
    'lockserver',
    'block',
    'unblock',
     ]

utilities_commands = \
    [ 
    'cycletime',
    'checkvars',
    'template',
    'housekeeping',
    'file-transfer',
    ]

preparation_commands = \
    [
    'register',
    'edit',
    'validate',
    'list',
    'graph',
    'grep',
    'inline',
    ]

startup_commands = \
    [
    'control',
    'coldstart', 
    'warmstart', 
    'rawstart', 
    'restart',
    ]

shutdown_commands = \
    [
    'control',
    'stop',
    ]

discovery_commands = \
    [
    'scan',
    'ping',
    'control',
    ]

monitoring_commands = \
    [
    'control',
    'view',
    'dump',
    'monitor',
    'ping',
    'scan',
    ]

interaction_commands = \
    [
    'control',
    'trigger',
    'insert',
    'remove',
    'purge',
    'pause',
    'resume',
    'block',
    'unblock',
    'verbosity',
    'reset',
    ]

information_commands = \
    [
    'control',
    'ping',
    'scan',
    'list',
    #    'graph',
    'dump',
    'show',
    'log',
    'view',
    'monitor',
    ]

tasks_commands = \
    [
    'wrap',
    'submit',
    'task-started',
    'task-message',
    'task-finished',
    'task-failed',
    ]

# uniquify the 'all commands' list (some may reside in multiple categories)
allcom = OrderedDict()
for command in preparation_commands + startup_commands + \
                shutdown_commands + interaction_commands + \
                monitoring_commands + information_commands + \
                locking_commands + security_commands + \
                tasks_commands:
            allcom[ command ] = True
all_commands = allcom.keys()

general_usage = """
USAGE:
  cylc help,--help,-h,?                # top level help page
  cylc -v,--version                    # cylc release version
  cylc help CATEGORY                   # commands by category
  cylc COMMAND help,--help             # command-specific help
  cylc COMMAND [options] SUITE [args]  # command usage syntax"""

cat_usage = """
USAGE: cylc COMMAND help,--help
       cylc help"""

usage = """This is the cylc metascheduler commandline interface.
""" + general_usage + """

You can use any unique abbreviation for a COMMAND or CATEGORY, e.g.:
  $ cylc help prep .............. (category: preparation)
  $ cylc reg foo /path/to/foo ... (command: register) 

Overlapping Command CATEGORIES:
  all ........... all core cylc commands (sans utilities)
  preparation ... suite preparation and editing
  discovery ..... finding what suites are running
  startup ....... starting a suite running
  shutdown ...... stopping a running suite
  interaction ... interacting with a running suite
  monitoring .... monitoring a running suite
  information ... getting task-specific information on a suite
  tasks ......... single-task submit, wrapping, and messaging
  locking ....... suite and task locking by the cylc lockserver
  security ...... access, locking, blocking and secure passphrases

  utilities ..... some useful programs intended for use in suites
"""

if len(sys.argv) == 1:
    print >> sys.stderr, usage
    sys.exit(1)

discovery_help = """CATEGORY:discovery - finding out what suites are running."""

preparation_help = """CATEGORY:preparation - suite preparation and editing."""

startup_help  = """CATEGORY:startup - starting suites."""

shutdown_help  = """CATEGORY:shutdown - stopping suites."""

monitoring_help  = """CATEGORY:monitoring - monitoring running suites."""

interaction_help  = """CATEGORY:interaction - interacting with running suites."""

information_help = """CATEGORY:information - getting information about running suites."""

security_help = """CATEGORY:security - owner-only access, locking, blocking, secure passphrases.

Cylc commands allow only the suite owner to intervene in a running suite.

Using the cylc lockserver prevents accidental simultaneous runs of the
exact same suite (unless the suite allows it) even if it is registered
under several names, or of the same task at the same cycle time, by
suite or single task submit.

Suite blocking guards against inadvertent intervention in your own suites.
 + SUITE.RC: use suite blocking = True

A secure passphrase prevents other users from accessing your suite even
if they hack command source code to subvert the owner-only restriction.
 + SUITE.RC: use secure passphrase = True

The passphrase must be stored in $HOME/.cylc/security/[SUITE_NAME] with
private file permissions, or cylc will refuse to run the suite. If your
suite contains tasks that run on a remote host or under another
username, those accounts must also hold the passphrase. The passphrase
is never sent across the network; a secure md5 checksum is exchanged."""

locking_help = """CATEGORY:locking - the cylc lockserver daemon and its user interface."""

tasks_help = """CATEGORY:tasks - single-task submit, wrapping, and task messaging.""" 

utilities_help = """CATEGORY:utilities - utility commands designed for use with cylc."""

all_help = "The complete cylc command set, sans utilities."

# command summaries
comsum = {}
comsum[ 'register'  ] = 'Manage suite registrations (name -> definition dir)'
comsum[ 'cylclockd' ] = 'The cylc lockserver daemon'
comsum[ 'grep'      ] = 'An intelligent search tool for cylc suites'
comsum[ 'graph'     ] = 'A dependency graph viewer that updates as you edit'
comsum[ 'validate'  ] = 'Parse and validate a suite config (suite.rc) file'
comsum[ 'inline'    ] = 'View suite.rc files with include-files inlined'
comsum[ 'edit'      ] = 'Edit a suite config file, optionally inlined'
comsum[ 'coldstart' ] = 'Cold start a suite at a given cycle time'
comsum[ 'warmstart' ] = 'Warm start a suite at a given cycle time'
comsum[ 'rawstart'  ] = 'Raw start a suite at a given cycle time'
comsum[ 'restart'   ] = 'Restart a suite from a previous state'
comsum[ 'stop'      ] = 'Shut down a running suite (now or later)'
comsum[ 'pause'     ] = 'Pause a running suite (stop submitting tasks)'
comsum[ 'resume'    ] = 'Unpause a running suite (resume submitting tasks)'
comsum[ 'block'     ] = 'Do not comply with subsequent intervention commands'
comsum[ 'unblock'   ] = 'Comply with subsequent intervention commands'
comsum[ 'insert'    ] = 'Insert a task or group into a running suite'
comsum[ 'trigger'   ] = 'Manually trigger a task'
comsum[ 'reset'     ] = 'Force a task to waiting, ready, or finished state'
comsum[ 'remove'    ] = 'Remove tasks from a running suite'
comsum[ 'purge'     ] = 'Remove a full dependency tree from a running suite'
comsum[ 'submit'    ] = 'Run a single task outside of its suite'
comsum[ 'control'   ] = 'The cylc suite control and monitoring GUI'
comsum[ 'view'      ] = 'Suite monitoring GUI (control functions disabled)'
comsum[ 'dump'      ] = 'Print the state of each task in a running suite'
comsum[ 'show'      ] = 'Retrieve task-specific information from a running suite'
comsum[ 'list'      ] = 'Print a suite\'s configured task list'
comsum[ 'ping'      ] = 'Check that a named suite is running'
comsum[ 'scan'      ] = 'Scan a host for running cylc suites'
comsum[ 'log'       ] = 'Print or view suite logs, with filtering'
comsum[ 'monitor'   ] = 'An in-terminal suite monitor (deprecated)'
comsum[ 'lockserver'] = 'Lockserver interrogation and lock management'
comsum[ 'verbosity' ] = 'Change a suite\'s logging verbosity level'
comsum[ 'cycletime' ] = 'Cycle time arithmetic'
comsum[ 'checkvars' ] = 'Process required environment variables en masse'
comsum[ 'template'  ] = 'Cycle time based filename templating'
comsum[ 'housekeeping' ] = 'Cycle time based parallel archiving and cleanup'
comsum[ 'file-transfer'] = 'An scp-based file transfer tool'
comsum[ 'wrap'         ] = 'Run a task that has no cylc messaging added'
comsum[ 'task-started' ] = 'Acquire a task lock and report started'
comsum[ 'task-message' ] = 'Report completion of outputs, etc.'
comsum[ 'task-finished'] = 'Release task lock and report finished'
comsum[ 'task-failed'  ] = 'Release task lock and report failure'
 
# check that the cylc core modules are accessible
try:
    import cylc
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "SOLUTION: source $CYLC_DIR/cylc-env.sh in your shell." 
    sys.exit(1)

# main help
if len( sys.argv ) == 2 and \
        (sys.argv[1] == '-h' or \
        sys.argv[1] == '--help' or \
        sys.argv[1] == '--hlep' or \
        sys.argv[1] == 'help' or \
        sys.argv[1] == 'hlep' or \
        sys.argv[1] == '?'):
    print usage
    sys.exit(0)

# cylc release version
if sys.argv[1] == '-v' or sys.argv[1] == '--version':
    print cylc_version
    sys.exit(0)

# secret command lists used by documentation generation script
if len(sys.argv) == 2 and sys.argv[1] == 'commands':
    for command in all_commands:
        print command
    sys.exit(0)
if len(sys.argv) == 2 and sys.argv[1] == 'utilities':
    for command in utilities_commands:
        print command
    sys.exit(0)
if len(sys.argv) == 2 and sys.argv[1] == 'categories':
    for category in categories:
        print category
    sys.exit(0)

if sys.argv[1] == 'help' or sys.argv[1] == 'hlep':
    # cylc help CATEGORY
    try:
        cat = find_command( sys.argv[2], categories, 'CATEGORY' )
    except CommandError, x:
        raise SystemExit(x)
    print eval (cat + '_help')
    print cat_usage
    print
    print 'COMMANDs:'
    output = []
    commands = eval( cat + '_commands')
    longest = len(commands[0])
    for command in commands:
        if len( command )> longest:
            longest = len( command )
    count = 0
    pad = False
    if len(commands) > 9:
        pad = True
    for command in commands:
        count += 1
        if pad and count < 10:
            digit = ' ' + str(count)
        else:
            digit = str(count)
        print ' ' + digit + '/', command, '.'*(longest-len(command)) + '...', comsum[command]
    sys.exit(0)

# cylc COMMAND ARGS
arglist = sys.argv[1:]
try:
    command = find_command( arglist[0], all_commands + utilities_commands, 'COMMAND' )
except CommandError, x:
    raise SystemExit(x)

options = []
if len(arglist) > 1:
    options = arglist[1:]

try:
    if options[0] == 'help' or options[0] == 'hlep':
        # catch 'cylc COMMAND help'
        options[0] = '--help'
except IndexError:
    pass

# construct command to execute
command = '_' + command 
commandlist = [ command ]
for f in options:
    commandlist.append( f )
execute( commandlist )
