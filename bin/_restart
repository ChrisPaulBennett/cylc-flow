#!/usr/bin/env python

#C: THIS FILE IS PART OF THE CYLC FORECAST SUITE METASCHEDULER.
#C: Copyright (C) 2008-2011 Hilary Oliver, NIWA
#C: 
#C: This program is free software: you can redistribute it and/or modify
#C: it under the terms of the GNU General Public License as published by
#C: the Free Software Foundation, either version 3 of the License, or
#C: (at your option) any later version.
#C:
#C: This program is distributed in the hope that it will be useful,
#C: but WITHOUT ANY WARRANTY; without even the implied warranty of
#C: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#C: GNU General Public License for more details.
#C:
#C: You should have received a copy of the GNU General Public License
#C: along with this program.  If not, see <http://www.gnu.org/licenses/>.


import os, sys, re
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

global debug
debug = True

class restart( scheduler ):
    def __init__( self ):
        usage = """cylc [control] restart [options] SUITE [FILE]

Restart a cylc suite from a previous state. Tasks in the 'submitted',
'running', or 'failed' states will immediately be resubmitted at
startup unless you specity the '--no-reset' option. Any stopped
tasks (this happens when the suite was in the process of, or had
finished, shutting down at a prescribed stop time) will be unstopped,
and the stop time unset, unless you specify the '--no-unstop' option.

By default the suite will restart from the suite state dump file, which is
updated whenever a task changes state and thus records the most recent
previous state of the suite. However, cylc also records a special named
state dump, and logs its filename, before actioning any intervention
command, and you can choose to restart from one of these (just
cut-and-paste the filename from the log to the commandline).

NOTE: if you set a stop time it will be recorded in the suite state dump
and you cannot then change or cancel that stop time at a restart. This
is because any tasks that reached the stop time prior to shutdown will be
stopped (recorded in the state dump file as 'succeeded' and 'spawned',
but with no existing successor) and canceling the stop time or setting a
later one will not bring these tasks back from the dead. If you need to
continue operation after a set stop time you can either: (a) let the
suite run to completion at the stop time and then warm start it, or (b)
edit the state dump file to delete the stop time and then manually
insert any 'stopped' tasks back into the suite, at run time or via the
state dump file.

NOTE: daemonize important suites with the POSIX nohup command:
    nohup cylc [con] restart SUITE YYYYMMDDHH > suite.out 2> suite.err &

See also:
    cylc [control] run
    cylc [control] stop|shutdown

Arguments:
   SUITE                Registered name of the suite to restart.
   [FILE]               Optional non-default state dump file (assumed to
                        be in the suite state dump directory unless you
                        supply the file path).""" 

        self.parser = OptionParser( usage )
        self.parser.add_option( "--no-reset", 
            help="Do not automatically reset failed tasks at startup "
            "(this option is the default in practice mode).",
            action="store_true", default=False, dest="no_reset" )
        self.parser.add_option( "--no-unstop", 
            help="Do not unset a suite stop time and unstop stopped tasks.",
            action="store_true", default=False, dest="no_unstop" )
        self.start_time = None  # used in scheduler.py:initialize_graph()
        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        self.no_reset = False
        if self.options.no_reset or self.options.practice_mode:
            self.no_reset = True
        self.restart_from = None
        if len( self.args ) == 2:
            self.restart_from = self.args[1]
            if cycle_time.is_valid( self.restart_from ):
                print "WARNING: THE SUPPLIED INITIAL RESTART DUMP FILENAME IS A"
                print "VALID CYCLE TIME - did you mean to (cold|warm|raw)start?"

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug

        if self.restart_from:
            self.banner['RESTART'] = 'From ' + self.restart_from
        else:
            self.banner['RESTART' ] = 'From previous state'

    def load_tasks( self ):
        # FIND THE INITIAL STATE DUMP FILE
        if self.practice:
            # in practice mode, we reset from the parent suite's state dump
            state_dump_dir = re.sub( '-practice', '', self.state_dump_dir )
            state_dump_file = re.sub( '-practice', '', self.state_dump_filename )
        else:
            state_dump_dir = self.state_dump_dir
            state_dump_file = self.state_dump_filename

        if self.restart_from:
            # user specified the initial state dump
            path = self.restart_from
            if os.path.exists( path ):
                # relative or full path was specified
                self.initial_state_dump = os.path.abspath( path )
            else:
                # check if the named file is in the suite state dump dir
                path = os.path.join( state_dump_dir, self.restart_from )
                if not os.path.exists( path ):
                    raise SystemExit( "state dump file not found: " + self.restart_from )
                self.initial_state_dump = os.path.abspath( path )
        else:
            # No state dump file specified, restart from the default file.
            if not os.path.exists( state_dump_file ):
                raise SystemExit( "state dump file not found: " + state_dump_file )
            self.initial_state_dump = state_dump_file

        self.log.info( 'Restart ' + self.initial_state_dump )

        # The state dump file format is:
        # suite time : <time>
        #   OR
        # dummy time : <time>,rate
        #   THEN
        # class <classname>: item1=value1, item2=value2, ... 
        # <task_id> : <state>
        # <task_id> : <state>
        #   ...
        # The time format is defined by the clock.reset()
        # task <state> format is defined by task_state.dump()

        FILE = open( self.initial_state_dump, 'r' )
        lines = FILE.readlines()
        FILE.close()

        # RESET THE TIME TO THE LATEST DUMPED TIME
        # The state dump file first line is:
        # suite time : <time>
        #   OR
        # dummy time : <time>,rate
        line1 = lines[0]
        line1 = line1.rstrip()
        [ time_type, time_string ] = line1.split(' : ')
        if time_type == 'dummy time':
            if not self.dummy_mode:
                raise SystemExit("You can't restart in real mode from a dummy mode state dump")
            
            [ time, rate ] = time_string.split( ',' )
            self.clock.reset( time, rate )

        line2 = lines[1]
        line2 = line2.rstrip()
        [ junk, oldstoptime ] = line2.split(' : ')

        if oldstoptime != '(none)':
            # the suite had a prescribed stop time when it shut down
            if self.stop_time:
                # a stop time was given on the restart commandline
                if self.stop_time != oldstoptime:
                    # OK, override the old stop time with the new
                    if self.options.no_unstop:
                        print >> sys.stderr, "ERROR: new stop time incompatible with --no-unstop."
                        sys.exit(1)
            elif self.options.no_unstop:
                    # reinstate the former stop time
                    self.stop_time = oldstoptime
        
        # parse each line and create the task it represents
        tasknames = {}
        taskstates = {}
        for line in lines[2:]:
            # strip trailing newlines
            line = line.rstrip( '\n' )

            if re.match( '^class', line ):
                # class variables
                [ left, right ] = line.split( ' : ' )
                [ junk, classname ] = left.split( ' ' ) 
                cls = self.config.get_task_class( classname )
                pairs = right.split( ', ' )
                for pair in pairs:
                    [ item, value ] = pair.split( '=' )
                    cls.set_class_var( item, value )
                continue

            # instance variables
            ( id, state ) = line.split(' : ')
            ( name, c_time ) = id.split('%')
            tasknames[name] = True
            taskstates[id] = (name, c_time, state )

        initial_task_list = tasknames.keys()
        task_list = self.filter_initial_task_list( initial_task_list )

        for id in taskstates:
            name, c_time, state = taskstates[id]
            if name not in task_list:
                continue

            # startup=True only for coldstart
            itask = self.config.get_task_proxy( name, c_time, state, stopctime=None, startup=False )

            if itask.state.is_succeeded():  
                # must have satisfied prerequisites and completed outputs
                itask.log( 'NORMAL', "starting in SUCCEEDED state" )
                itask.prerequisites.set_all_satisfied()
                itask.outputs.set_all_complete()

            elif itask.state.is_submitted() or itask.state.is_running():  
                # Must have satisfied prerequisites. These tasks may have
                # finished after the suite was shut down, but as we
                # can't know that for sure we have to re-submit them.
                itask.log( 'NORMAL', "starting in READY state" )
                itask.state.set_status( 'waiting' )
                itask.prerequisites.set_all_satisfied()

            elif itask.state.is_failed():
                # Re-submit these unless the suite operator says not to. 
                if self.no_reset:
                    itask.log( 'WARNING', "starting in FAILED state: manual reset required" )
                    itask.prerequisites.set_all_satisfied()
                else:
                    itask.log( 'NORMAL', "starting in READY state" )
                    itask.state.set_status( 'waiting' )
                    itask.prerequisites.set_all_satisfied()

            elif itask.state.is_stopped() and not self.options.no_unstop:
                # Release stopped tasks unless the suite operator says not to. 
                #if self.no_reset:
                #    itask.log( 'WARNING', "starting in FAILED state: manual reset required" )
                #    itask.prerequisites.set_all_satisfied()
                #else:
                itask.log( 'NORMAL', "releasing from STOPPED state" )
                itask.state.set_status( 'waiting' )
                itask.prerequisites.set_all_unsatisfied()

            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                #itask.prepare_for_death()
                #del itask
                itask.state.set_status('stopped')
            #else:
            self.insert( itask )

if __name__ == '__main__':
    try:
        server = restart()
    except Exception, x:
        if debug:
            raise
        else:
            print >> sys.stderr, x
            print >> sys.stderr, "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print "ERROR CAUGHT, will clean up before exit"
        server.shutdown()
        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print >> sys.stderr, x
            print >> sys.stderr, "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print >> sys.stderr, "ERROR CAUGHT; will clean up before exit"
        server.shutdown()
        raise
    else:
        # success!
        server.shutdown()
