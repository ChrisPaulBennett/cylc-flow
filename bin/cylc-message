#!/usr/bin/python

""" 
Standalone interface between external EcoConnect tasks/models and the
task objects that represent them in the controller.

Sends a message to a task proxy object in a cylc instance, by calling
[task object].incoming(<priority>, <message>). The task is identified by
its unique task ID, <NAME>%<REFTIME>.

Cylc provides $REFERENCE_TIME and $TASK_NAME to external tasks that all
this messaging interface.
"""

import os
import sys
import Pyro.core
from Pyro.errors import NamingError, ProtocolError
import config
from optparse import OptionParser
from time import sleep

# construct a command line parser
usage = "%prog [options] <message>" 
parser = OptionParser( usage )

parser.add_option( "-p", "--priority", 
        metavar="PRIORITY",
        help="message priority "
             "(NORMAL, WARNING, CRITICAL) "
             "defaults to NORMAL.",
        action="store", dest="priority" )

parser.add_option( "-n", "--name", 
        metavar='TASKNAME',
        help="task name, defaults to $TASK_NAME",
        action="store", dest="taskname" )

parser.add_option( "-r", "--reftime", 
        metavar="YYYYMMDDHH",
        help="task reference time, defaults to $REFERENCE_TIME",
        action="store", dest="reftime" )

parser.add_option( "--all-restart-outputs-completed", 
        help="report all forecast model restart outputs completed at once",
        action="store_true", default=False, dest="all_restarts_completed" )

parser.add_option( "--all-outputs-completed", 
        help="report all task outputs completed at once",
        action="store_true", default=False, dest="all_outputs_completed" )

# get command line options and positional args
( options, args ) = parser.parse_args()

#if not options.priority or not options.taskname or not options.reftime:
#    parser.error( "options -p, -t, -r are not optional!" )

if options.priority:
    priority = options.priority
else:
    # Default to NORMAL
    priority = 'NORMAL'

if options.taskname:
    taskname = options.taskname
else:
    # Default to $TASK_NAME
    if 'TASK_NAME' in os.environ.keys():
        taskname = os.environ[ 'TASK_NAME' ]
    else:
        print 'ERROR, cylc-message: no task name provided!'
        sys.exit(1)
    
if options.reftime:
    reftime = options.reftime
else:
    # Default to $REFERENCE_TIME
    if 'REFERENCE_TIME' in os.environ.keys():
        reftime = os.environ[ 'REFERENCE_TIME' ]
    else:
        print 'ERROR, cylc-message: no reference time provided!'
        sys.exit(1)
 
if len( args ) == 0:
    if not options.all_restarts_completed and not options.all_outputs_completed:
        parser.error( "no message supplied" )
elif len( args ) == 1:
    # user sent a quoted string
    message = args[0]
else:
    # user sent a bar string, so join all the words together
    message = ' '.join(args)

# load the configured system (the system's enviroment.sh script must
# have been sourced in the current shell)
config = config.config()
config.user_override()
config.check()

# connect to the task object inside the control program
count = 0
while True:
    count += 1
    try:
        task = Pyro.core.getProxyForURI('PYRONAME://' +  config.get('system_name') + '.' + taskname + '%' + reftime )
       
    except ProtocolError:
        # retry if temporary network problems prevented connection

        # TO DO: do we need to single out just the 'connection failed error?'

        # http://pyro.sourceforge.net/manual/10-errors.html
        # Exception: ProtocolError,
        #    Error string: connection failed
        #    Raised by: bindToURI method of PYROAdapter
        #    Description: Network problems caused the connection to fail.
        #                 Also the Pyro server may have crashed.
        #                 (presumably after connection established - hjo)

        print 'cylc-message [' + str( count ) + ']: Network Problems, RETRYING in 5 seconds'
        sleep(5)

    except NamingError:
        # can't find nameserver, or no such object registered ...
        print 'PYRO NAMESERVER ERROR'
        raise

    except Exception:
        # all other exceptions
        print 'ERROR'
        raise

    else:
        # successful connection; continue on.
        break

if options.all_restarts_completed:
    task.set_all_restarts_completed()
elif options.all_outputs_completed:
    task.set_all_outputs_completed()
else:
    task.incoming( priority, message )

#    # nameserver not found, or object not registered with it?
#    print "ERROR: failed to connect to " + task_name + "_" + ref_time
#    print "Trying dead letter box"
#    try:
#        dead_box = Pyro.core.getProxyForURI('PYRONAME://' + config.get('system_name') + '.' + 'dead_letter_box' )
#        dead_box.incoming( message )
#    except:
#        # nameserver not found, or object not registered with it?
#        print "ERROR: failed to connect to pyro nameserver"
#        sys.exit(1)
