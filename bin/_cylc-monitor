#!/usr/bin/python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


"""
Display the state of all existing task proxy objects.

For color terminal ASCII escape codes, see
http://ascii-table.com/ansi-escape-sequences.php
"""

import pyrex
from cycle_time import _rt_to_dt
import os, re, sys
import Pyro.core
from Pyro.errors import PyroError,NamingError,ProtocolError,TimeoutError,ConnectionClosedError
from time import sleep
from CylcOptionParsers import NoPromptOptionParser_u

compress = True

parser = NoPromptOptionParser_u( """cylc monitor [options] SYSTEM 

A terminal-based monitor that displays the state of all tasks in the
target system. 

THIS PROGRAM MONITORS TASK PROXY OBJECTS INSIDE THE SCHEDULER, NOT
EXTERNAL SYSTEM TASKS (how to do that obviously depends on the job
submission method used by each task).""")

parser.add_option( "-a", "--align", 
        help="Align columns by task name. This option "
        "is only useful for relatively small systems (i.e. a few tasks).",
        action="store_true", default=False, dest="align_columns" )

parser.add_option( "--shortnames", help="Display short task names, if defined.",
        action="store_true", default=False, dest="shortnames" )

( options, args ) = parser.parse_args()

system_name = parser.get_system_name()
pns_host = parser.get_pns_host()
groupname = parser.get_groupname()

# get systems currently registered in the Pyro nameserver
ns_groups = pyrex.discover( pns_host )

if ns_groups.registered( groupname ):
    print "System: " + system_name
else:
    print "No " + groupname + " group registered with Pyro yet, waiting ..." 

header = 'waiting submitted running done failed'
header = '                                     '
ctrl_end = "\033[0m"
key = "\033[1;35mwaiting\033[0m \033[1;37;40msubmitted\033[0m \033[1;37;42mrunning\033[0m done \033[1;37;41mfailed" + ctrl_end 

print
print "here we go ..."
sleep(2)

alerted = False
alerted2 = False
alerted3 = False

try:
    while True:
        # connect to remote state summary object
        try: 
            god = Pyro.core.getProxyForURI('PYRONAME://' + pns_host + '/' + groupname + '.state_summary')
            # timeout (sec) determines max wait for an answer from god.
            god._setTimeout(60)

        except ProtocolError, x:
            if not alerted:
                print "\n\033[1;37;41mfailed to connect" + ctrl_end 
                print x
                alerted = True
            #raise
            # if no connection, try again to connect
            sleep(1)
            continue

        except NamingError, x:
            if not alerted:
                print "\n\033[1;37;41mfailed to connect" + ctrl_end 
                print x
                alerted = True
            #raise
            # if no connection, try again to connect
            sleep(1)
            continue

        alerted = False

        while True:
            # continual redisplay loop

            # get state summary, task names, cycle times
            try:
                [glbl, states] = god.get_state_summary()

            except TimeoutError:
                if not alerted3:
                    print "\n\033[1;37;41mconnection timed out" + ctrl_end
                    alerted3 = True
                # if timed out, try again on same connection
                sleep(1)
                continue
                #break

            except ConnectionClosedError:
                if not alerted2:
                    print "\n\033[1;37;41mconnection closed" + ctrl_end 
                    alerted2 = True
                sleep(1)
                # if connection lost, try to reconnect
                break

            except ProtocolError:
                if not alerted:
                    print "\n\033[1;37;41mfailed to connect" + ctrl_end 
                    alerted = True
                #raise
                # wh'th'fu'?
                sleep(1)
                continue

            alerted2 = False
            alerted3 = False

            dt = glbl[ 'last_updated' ]
            rate = glbl[ 'dummy_clock_rate' ]
            dummy_mode = glbl[ 'dummy_mode' ]
            paused = glbl['paused']
            stopping = glbl['stopping']
            will_pause_at = glbl['will_pause_at']
            will_stop_at = glbl['will_stop_at']

            task_ids = states.keys()
            n_tasks_all = len( task_ids )
            task_ids.sort()

            seen_time = {}
            seen_name = {}
            c_time_list = []
            name_list = []

            for task_id in task_ids:
                [ name, c_time ] = task_id.split( '%' )

                if c_time not in seen_time.keys():
                    seen_time[ c_time ] = True
                    c_time_list.append( c_time )

                if name not in seen_name.keys():
                    seen_name[ name ] = True
                    if options.shortnames:
                        name_list.append( states[ task_id ][ 'short_name' ] )
                    else:
                        name_list.append( name )

            n_task_types = len( name_list )
            name_list.sort()
            c_time_list.sort()

            # initialize a dict-of-dicts to store display information
            # for all tasks at each current cycle time
            #   task_info[ c_time ][ task_name ] = info
            task_info = {}
            for rt in c_time_list:
                task_info[ rt ] = {}
                for name in name_list:
                    # initialise with blank string of the same size as
                    # the real info that we will use below
                    tmp = name + '*'  # name plus abdication indicator
                    tmp = re.sub( '.', ' ', tmp )
                    task_info[ rt ][name] = tmp

            # now loop through all tasks in the system and assign their
            # display info to the correct place in the task_info structure
            for task_id in task_ids:

                if options.shortnames:
                    name     =      states[ task_id ][ 'short_name' ]
                else:
                    name     =      states[ task_id ][ 'name' ]

                ctime  =      states[ task_id ][ 'cycle_time' ]
                state    =      states[ task_id ][ 'state' ]

                if not states[ task_id ][ 'spawned' ]:
                    # identify any tasks that have not spawned yet
                    abd = '*'
                else:
                    # space of same length
                    abd = ' '

                # color displayed info according to run status
                if state == "submitted":
                    ctrl_start = "\033[1;37;40m"
                elif state == "running":
                    ctrl_start = "\033[1;37;42m"
                elif state == "waiting":
                    ctrl_start = "\033[1;35m"
                elif state == "failed":
                    ctrl_start = "\033[1;37;41m"
                else:
                    # finished
                    ctrl_start = ""

                # construct the display string for this task
                task_info[ ctime ][ name ] = ctrl_start + name + ctrl_end + abd

            # construct an array of lines to blit to the screen

            # MONITOR HEADER and CURRENT TIME
            blit = []
            # SYSTEM NAME, NUMBER OF TASKS, DUMMY MODE
            foo = header
            bar = system_name + '", ' + str( n_task_types ) + ' types, ' + str( n_tasks_all ) + ' tasks)'
            foo = re.sub( '^.{' + str(len('cylc!')) + '}', 'cylc!', foo )
            foo = re.sub( '.{' + str(len(system_name)) + '}$', system_name, foo )

            blit.append( '\033[1;37;43m' + foo + ctrl_end )

            blit.append( key )

            # last time state summary was updated by cylc (only happens
            # when task processing is invoked).
            blit.append( 'summary updated - ' + '\033[1;38m' + dt.strftime( "%Y/%m/%d %H:%M:%S" ) + ctrl_end )

            if dummy_mode:
                foo = 'DUMMY MODE:'
                bar = str(rate) + ' real seconds = 1 hour' 
                baz = header
                baz = re.sub( '^.{' + str(len(foo)) + '}', foo, baz )
                baz = re.sub( '.{' + str(len(bar)) + '}$', bar, baz )
                blit.append( baz )

            if stopping:
                #            'waiting submitted running done failed'
                foo = '______________________S_T_O_P_P_I_N_G'
            elif paused:
                #            'waiting submitted running done failed'
                foo = '__________________________P_A_U_S_E_D'
            elif will_pause_at:
                #            'waiting submitted running done failed'
                #                                    YYYYMMDDHH                                
                foo = '___________P_A_U_S_E__A_T__' + will_pause_at
            elif will_stop_at:
                #            'waiting submitted running done failed'
                #                                    YYYYMMDDHH                                
                foo = '_____________S_T_O_P__A_T__' + will_stop_at
            else:
                #            'waiting submitted running done failed'
                foo = '________________________R_U_N_N_I_N_G'
         
            #blit.append( '\033[1;33;44m' + foo + ctrl_end )
            blit.append( '\033[1;31m' + foo + ctrl_end )
 
            # construct a line of text to display for each cycle time
            for rt in c_time_list:
                line = ''
                # colour cycle time according to whether it has
                # caught up to the current clock time or not.
                rtdt = _rt_to_dt( rt )
                if dt > rtdt:
                    # behind
                    line = '\033[1;34m' + rt + ctrl_end
                else:
                    # caught up
                    line = '\033[1;31m' + rt + ctrl_end

                # add info for each task to the line
                for name in name_list:
                    disp = task_info[rt][name]
                    if not options.align_columns and re.match( '^\s+$', disp ): 
                        # don't add white space unless align_columns has
                        # been requested by the user
                        pass
                    else:
                        line = line + ' ' + disp

                blit.append( line )
                        
            # clear screen and blit the new information up
            os.system( "clear" )
            print '\n'.join( blit )
            # sleep here determines minimum display time before trying to
            # update the information and redisplay it (?). 
            sleep(1)

        # sleep here determines how long to wait before trying to reconnect (?)
        sleep( 1 )

except KeyboardInterrupt:
    raise SystemExit( 'ok, whatever' )
