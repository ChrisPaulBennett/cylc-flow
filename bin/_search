#!/usr/bin/env python

import os, re, sys
from optparse import OptionParser
from collections import deque
from registration import registrations

def include_files( suitedir, inf ):
    outf = []
    for line in inf:
        m = re.match( '\s*%include\s+([\w/\.\-]+)\s*$', line )
        if m:
            match = m.groups()[0]
            inc = os.path.join( suitedir, match )
            if os.path.isfile(inc):
                #print "Inlining", inc
                outf.append('++++ START INLINED INCLUDE FILE ' + match + '\n')
                h = open(inc, 'rb')
                inc = h.readlines()
                h.close()
                # recursive inclusion
                outf.extend( include_files( suitedir, inc ))
                outf.append('++++ END INLINED INCLUDE FILE ' + match + '\n')
            else:
                raise SystemExit( "File not found: " + inc )
        else:
            # no match
            outf.append( line )
    return outf

def section_level( heading ):
    # e.g. foo => 0
    #     [foo] => 1
    #    [[foo]] => 2
    m = re.match( '^(\[+)', heading )
    if m:
        level = len( m.groups()[0] )
    else:
        level = 0
    return level

def print_heading( heading ):
    print '>>>' + '->'.join(heading)
    #space = ' '
    #indent = '>>>'
    #for i in range( 1, section_level(heading) ):
    #    indent += space * 2
    #print indent + heading

parser = OptionParser( """cylc search [options] PATTERN SUITE 
       cylc grep [options] PATTERN SUITE 

This is a cylc suite definition aware text search tool. It finds matches
to PATTERN in the suite.rc file, and any contained include-files, and in
any files in the suite bin directory.

Note that the order of commandline arguments conforms to normal grep usage
('grep PATTERN FILE') not normal cylc command usage ('command SUITE ARGS').
However, if the second argument is not found to be a registered suite, an
attempt will be made to action the command with the arguments reversed.

Suite config matches are printed with their source file path (include
files) and line number, and the correct section heading hierarchy even 
in the case of nested include-files.

See also 'cylc read' and 'cylc edit'.

Arguments:
  PATTERN - a string, or Python-style regular expression.
  SUITE   - name of the suite to search.""")

parser.add_option( "-x", help="Do not search in the suite bin directory",
        action="store_false", default=True, dest="search_bin" )

( options, args ) = parser.parse_args()

if len(args) != 2:
    parser.error( "wrong number of arguments" )

#pattern = args[0]
#suite = args[1]
arg0 = args[0]
arg1 = args[1]

# find location of the suite definition directory
reg = registrations()
if reg.is_registered( arg1 ):
    # cylc grep PATTERN SUITE
    suite = arg1
    pattern = arg0
elif reg.is_registered( arg0 ):
    # cylc grep SUITE PATTERN
    suite = arg0
    pattern = arg1
else:
    reg.print_all()
    raise SystemExit( "Suite not registered!" )

suitedir = reg.get( suite )
suiterc = os.path.join( suitedir, 'suite.rc' )

if os.path.isfile( suiterc ):
    h = open( suiterc, 'rb' )
    lines0 = h.readlines()
    h.close()
    lines = include_files( suitedir, lines0 )
else:
    parser.error("Suite " + suite + " config file not found: " + suiterc )

sections = deque( ['(top)'] )

line_count = 1
inc_file = None
in_include_file = False
prev_section_key = None
prev_file = None

for line in lines:

    m = re.match('^\+\+\+\+ START INLINED INCLUDE FILE ([\w/\.\-]+)', line )
    if m:
        inc_file = m.groups()[0]
        in_include_file = True
        inc_line_count = 0
        continue
 
    if not in_include_file:
        line_count += 1
    else:
        inc_line_count += 1
        m = re.match('^\+\+\+\+ END INLINED INCLUDE FILE ' + inc_file, line )
        if m:
            in_include_file = False
            inc_file = None
            continue

    m = re.match( '\s*(\[+\s*([\w ]+)\s*\]+)', line )
    if m:
        # new section heading detected
        heading = m.groups()[0] 
        level = section_level( heading )
        name = m.groups()[1]
        # unwind to the current section level
        while len(sections) > level - 1:
            sections.pop()
        sections.append( heading )
        continue

    if re.search( pattern, line ):
        # Found a pattern match.

        # Print the file name
        if in_include_file:
            curr_file = os.path.join( suitedir, inc_file ) 
            line_no = inc_line_count
        else:
            curr_file = suiterc
            line_no = line_count

        if curr_file != prev_file:
            prev_file = curr_file
            print "\nFILE:", curr_file

        # Print the nested section headings
        section_key = '->'.join( sections )
        if section_key != prev_section_key:
            prev_section_key = section_key
            #for heading in sections:
            #    print_heading( heading )
            print '   SECTION:', section_key

        # Print the pattern match, with line number
        print '      [' + str(line_no) + ']:', line.rstrip('\n')

if not options.search_bin:
    sys.exit(0)

# search files in suite bin directory
bin = os.path.join( suitedir, 'bin' )
if not os.path.isdir( bin ):
    print "\nSuite " + suite + " has no bin directory"
    sys.exit(0)

for file in os.listdir( bin ):
    if re.match( '^\.', file):
        # skip hidden dot-files
        # (e.g. vim editor temporary files)
        continue
    new_file = True
    h = open( os.path.join(bin,file), 'rb')
    contents = h.readlines()
    h.close()

    count = 0
    for line in contents:
        line = line.rstrip('\n')
        count += 1
        if re.search( pattern, line ):
            if new_file:
                print '\nFILE:', file
                new_file = False
            print '   ['+str(count)+']: ' + line
