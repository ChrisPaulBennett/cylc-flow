#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

import os, sys
from optparse import OptionParser

import cycle_time
from restart import restart
from scheduler import scheduler

debug = True

class restart_scheduler( scheduler ):
    def __init__( self ):
        usage = """cylc restart [options] SUITE [STATE DUMP]

Restart a cylc suite from a previous state. Tasks in the 'submitted',
'running', or 'failed' states will immediately be resubmitted at
startup unless you specity the '--no-reset' option.

By default the suite will restart from the suite state dump file, which is
updated whenever a task changes state and thus records the most recent
previous state of the suite. However, cylc also records a special named
state dump, and logs its filename, before actioning any intervention
command, and you can choose to restart from one of these (just
cut-and-paste the filename from the log to the commandline).

Arguments:
   SUITE                Registered name of the suite to restart.
   [STATE DUMP]         Optional non-default state dump file (assumed to
                        be in the suite state dump directory unless you
                        supply the file path).""" 

        self.parser = OptionParser( usage )

        self.parser.add_option( "--no-reset", 
            help="Do not automatically reset failed tasks at startup "
            "(this option is the default in practice mode).",
            action="store_true", dest="no_reset" )

        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()

        self.no_reset = False
        if self.options.no_reset or self.options.practice_mode:
            self.no_reset = True

        self.restart_from = None
        if len( self.args ) == 2:
            self.restart_from = self.args[1]

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug
 
    def find_initial_state_dump_file( self ):
        if self.restart_from:
            # user specified the initial state dump
            path = self.restart_from
            if os.path.exists( path ):
                # relative or full path was specified
                self.initial_state_dump = os.path.abspath( path )
            else:
                # check if the named file is in the suite state dump dir
                # (in practice mode we want the source suite state dump dir)
                state_dump_dir = self.rcfile.get_suite_statedump_dir( self.suite_name )
 
                path = os.path.join( state_dump_dir, self.restart_from )
                if not os.path.exists( path ):
                    raise SystemExit( "state dump file not found: " + self.restart_from )
                self.initial_state_dump = os.path.abspath( path )
        else:
            # No state dump specified, restart from the suite default file.
            # In practice mode we want the source suite state dump
            # file, not self.state_dump_file.
            if self.practice:
                state_dump_dir = self.rcfile.get_suite_statedump_dir( self.suite_name )
                state_dump_file = os.path.join( state_dump_dir, 'state' )
            else:
                state_dump_file = self.state_dump_file

            if not os.path.exists( state_dump_file ):
                # can't restart a suite that was never cold started!
                raise SystemExit( "restart state dump file not found: " + state_dump_file )
            self.initial_state_dump = state_dump_file

        print "Restarting from: " + self.initial_state_dump

    def create_task_pool( self ):
        self.find_initial_state_dump_file()
        # initialize the server (and create main logger)
        self.pool = restart( self.config, self.pyro,
                self.dummy_mode, self.use_quick_elim, self.logging_dir,
                self.logging_level, self.state_dump_file, self.exclude_tasks,
                self.include_tasks, self.initial_state_dump,
                self.no_reset, self.stop_time, self.pause_time )

if __name__ == '__main__':

    try:
        # parse the commandline and initialize the cylc server
        server = restart_scheduler()
    except Exception, x:
        if debug:
            raise
        else:
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)

    try:
        # configure pyro, logging, etc., and load the suite task pool 
        server.configure()

        # crank it up baby!
        server.run()

    except Exception, x:

        print "ERROR CAUGHT, will clean up before exit"
        server.cleanup()

        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)

    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print "ERROR CAUGHT; will clean up before exit"
        server.cleanup()
        raise
