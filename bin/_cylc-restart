#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

import os, sys
from optparse import OptionParser

import cycle_time
from restart import restart
from scheduler import scheduler

class restart_scheduler( scheduler ):
    def __init__( self ):
        usage = """cylc restart [options] SYSTEM

Restart a cylc system from the most recent previous state (i.e. just
prior to shutdown) or from any previously recorded state. Tasks recorded
as 'submitted', 'running', or 'failed', will be reset to a
ready-to-run state at startup, by default.

Arguments:
   SYSTEM               Registered name of the system to restart.""" 

        self.parser = OptionParser( usage )

        self.parser.add_option( "--from", 
            help="Restart from a named state dump file (in the "
            "default state dump directory, or supply the full path).",
            metavar="FILE", action="store", default=None,
            dest="restart_from" )

        self.parser.add_option( "--no-reset", 
            help="Do no automatically reset failed tasks at startup "
            "(this option is the default in practice mode).",
            action="store_true", dest="no_reset" )

        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()

        self.no_reset = False
        if self.options.no_reset or self.options.practice_mode:
            self.no_reset = True

        self.restart_from = None
        if self.options.restart_from:
            self.restart_from = self.options.restart_from

        scheduler.parse_commandline( self )
 
    def find_initial_state_dump_file( self ):
        if self.restart_from:
            # user specified the initial state dump
            path = self.restart_from
            if os.path.exists( path ):
                # relative or full path was specified
                self.initial_state_dump = os.path.abspath( path )
            else:
                # check if the named file is in the system state dump dir
                # (in practice mode we want the source system state dump dir)
                state_dump_dir = self.rcfile.get_system_statedump_dir( self.system_name )
 
                path = os.path.join( state_dump_dir, self.restart_from )
                if not os.path.exists( path ):
                    raise SystemExit( "File not found: " + self.restart_from )
                self.initial_state_dump = os.path.abspath( path )
        else:
            # No state dump specified, restart from the system default file.
            # In practice mode we want the source system state dump
            # file, not self.state_dump_file.
            if self.practice:
                state_dump_dir = self.rcfile.get_system_statedump_dir( self.system_name )
                state_dump_file = os.path.join( state_dump_dir, 'state' )
            else:
                state_dump_file = self.state_dump_file

            if not os.path.exists( state_dump_file ):
                # can't restart a system that was never cold started!
                raise SystemExit( "File not found: " + state_dump_file )
            self.initial_state_dump = state_dump_file

        print "Restarting from: " + self.initial_state_dump

    def create_task_pool( self ):
        self.find_initial_state_dump_file()
        # initialize the server (and create main logger)
        self.pool = restart( self.config, self.pyro,
                self.dummy_mode, self.logging_dir,
                self.state_dump_file, self.exclude_tasks,
                self.include_tasks, self.initial_state_dump,
                self.no_reset, self.stop_time, self.pause_time )

if __name__ == '__main__':
    server = restart_scheduler()
    server.configure()
    try:
        server.run()
    except Exception, x:
        # catch proper exceptions
        #print "ERROR 1"
        print x
        server.cleanup()
        #raise
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        #print "ERROR 2"
        server.cleanup()
        #raise
