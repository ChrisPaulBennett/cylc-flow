#!/usr/bin/env python

# check Pyro is installed
try:
    import Pyro.constants
except Exception, x:
    raise SystemExit('ERROR: Pyro is not installed (or not accessible)')

import os, sys
import port_scan
import gtk
from passphrase import passphrase
from optparse import OptionParser
from gcylc import MainApp
from config import config
from registration import localdb, RegistrationError
import socket

parser = OptionParser( """gcylc [SUITE]

This is the cylc graphical user interface. It is functionally equivalent
to the commandline interface ('cylc help') in most respects.

    1/ gcylc &
This invokes the gcylc main window, which displays suites in your
private registration database, and in the central database available to
all users. By right-clicking on suites or registration groups you can
gain access all cylc functionality, from editing and graphing through
to suite control and monitoring.

    2/ gcylc [-g,--graph] SUITE &
This directly invokes a suite control and monitoring application for a
particular suite. Alternatively you can get this by right-clicking on 
the suite in the main gcylc suite database viewer (1/ above).
Without the -g,--graph option you'll get the standard filtered cycle
time treeview suite control and monitoring interface; with it, the
newer, and still somewhat experimental, dependency graph based
interface.

NOTE: daemonize important suites with the POSIX nohup command:
    $ nohup gcylc [options] [SUITE] &

Arguments:
    [SUITE]                  registered GROUP:NAME of a suite.""")

#parser.add_option( "--host",
#        help="cylc suite host (defaults to localhost).",
#        metavar="HOST", action="store", default=socket.getfqdn(),
#        dest="host" )

parser.add_option( "-g", "--graph",
        help="With SUITE - invoked the new dependency graph based suite "
        "control and monitoring interface.",
        action="store_true", default=False, dest="depgraph" )

( options, args ) = parser.parse_args()

if len(args) != 0 and len(args) != 1:
    parser.error( "Wrong number of arguments" )

# this is required for extensive use of the capture command in gcylc:
if 'TMPDIR' in os.environ:
    tmpdir = os.environ['TMPDIR']
elif 'SCRATCH' in os.environ:
    tmpdir = os.environ['SCRATCH']
else:
    raise SystemExit( 'You must export $TMPDIR or $SCRATCH before running gcylc' )

imagedir = os.environ[ 'CYLC_DIR' ] + '/images'

#host = options.host
host = socket.getfqdn()
owner = os.environ["USER"]

if len( args ) == 1:
    if args[0] == 'help':
        parser.print_help()
        sys.exit(0)

if len( args ) == 0:
    app = MainApp( host, tmpdir, imagedir )
    gtk.main()
    sys.exit(0)

suite = args[0]

# get suite definition directory
reg = localdb()
reg.load_from_file()
try:
    suite_dir, descr = reg.get( suite )
except RegistrationError, x:
    raise SystemExit( x )

# get suite logging directory
logging_dir = os.path.join( config( suite )['top level logging directory'], suite )

# scan for suite port
try:
    port = port_scan.get_port( suite )
except:
    port = None
    print >> sys.stderr, "Suite " + suite + " is not running"
else:
    print "Suite " + suite + " is running on port " + str(port)

if options.depgraph:
    from SuiteControlGraph import StandaloneControlGraphApp
    app = StandaloneControlGraphApp( suite, owner, host, port, suite_dir, logging_dir, imagedir )
else:
    from SuiteControlTree import StandaloneControlTreeApp
    app = StandaloneControlTreeApp( suite, owner, host, port, suite_dir, logging_dir, imagedir )
gtk.main()
