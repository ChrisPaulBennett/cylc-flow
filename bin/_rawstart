#!/usr/bin/env python

import sys
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

global debug
debug = True

class rawstart( scheduler ):
    def __init__( self ):

        usage = """cylc rawstart [options] SUITE YYYYMMDDHH

RAW START a suite at a specified cycle time. This starts the suite as if
in mid run, so any tasks that depend on previous cycles will have to be
triggered manually. For a suite with no intercycle dependencies (=> no
warm cycled forecast models) there is no distinction between the cold,
warm, and raw start methods.

Startup is as for a cold start, except that designated cold start tasks
are excluded from the suite. The cold start task list must be defined in
the suite config file:
  SUITE.RC: [special tasks] -> coldstart = task1, task2, ...
 
NOTE: to prevent a suite being killed when you log out: 
    export PYTHONUNBUFFERED=true   #(*)
    nohup cylc warmstart SUITE YYYYMMDDHH
(*) Python stdout buffering can result in no output until shutdown.

See also:
    cylc coldstart
    cylc warmstart
    cylc restart

Arguments:
   SUITE                Registered name of the suite to start.
   YYYYMMDDHH           Initial cycle time.""" 

        self.parser = OptionParser( usage )
        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        if len( self.args ) != 2:
            self.parser.error( "Please supply a suite name and initial cycle time." )

        if cycle_time.is_valid( self.args[1] ):
            self.start_time = self.args[1]
        else:
            self.parser.error( "Invalid cycle time: " + self.args[1])

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug
 
        self.banner[ "RAW START" ] = self.start_time

    def load_tasks( self ):
        self.log.info( 'Raw Start ' + self.start_time )
        
        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'coldstart task list' CONFIG ITEM" )

        for name in task_list:
            # startup=True only for coldstart
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', startup=False )
            if name in coldstart_tasks:
                itask.log( 'WARNING', "This is a raw start: I will self-destruct." )
                itask.prepare_for_death()
                del itask
                continue
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
                continue
            self.insert( itask )
 
if __name__ == '__main__':
    try:
        server = rawstart()
    except Exception, x:
        if debug:
            raise
        else:
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print "ERROR CAUGHT, will clean up before exit"
        # this assumes no exceptions in shutdown()
        server.shutdown()
        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print "ERROR CAUGHT; will clean up before exit"
        server.shutdown()
        raise
