#!/usr/bin/env python

import sys
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

global debug
debug = True

class rawstart( scheduler ):
    def __init__( self ):

        usage = """cylc rawstart [options] SUITE CYCLE

RAW START a suite at a given initial cycle time. This starts a suite as
if in mid run (but without tasks of the previous cycle!). Each task
proxy is inserted in the 'waiting' state (i.e. prerequisites not
satisfied) at the initial cycle time, or at the next valid cycle time
for the task, except for designated cold start tasks (see suite.rc
documentation) which are NOT inserted. 

To get the suite running you will need to manually insert the coldstart
tasks, or manually trigger any forecast models (whose restart
prerequisites would normally be satisfied by tasks in a previous cycle,
or by coldstart tasks).

IMPORTANT: To do a rawstart the 'coldstart task list' suite config item
must be set - these tasks will be excluded at startup.

See also:
    cylc coldstart SUITE
    cylc warmstart SUITE

Arguments:
   SUITE                Registered name of the suite to start.
   CYCLE                Initial cycle time (YYYYMMDDHH).""" 

        self.parser = OptionParser( usage )
        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        if len( self.args ) != 2:
            self.parser.error( "Please supply a suite name and initial cycle time." )

        if cycle_time.is_valid( self.args[1] ):
            self.start_time = self.args[1]
        else:
            self.parser.error( "Invalid cycle time: " + self.args[1])

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug
 
        self.banner[ "RAW START" ] = self.start_time

    def load_tasks( self ):
        self.log.info( 'Raw Start ' + self.start_time )
        
        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
        coldstart_tasks = self.config.get_coldstart_task_list()
        if len( coldstart_tasks ) == 0:
            self.log.warning( "THIS SUITE HAS NOT DEFINED THE 'coldstart task list' CONFIG ITEM" )

        for name in task_list:
            # startup=True only for coldstart
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', startup=False )
            if name in coldstart_tasks:
                itask.log( 'WARNING', "This is a raw start: I will self-destruct." )
                itask.prepare_for_death()
                del itask
                continue
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
                continue
            self.insert( itask )
 
if __name__ == '__main__':
    try:
        server = rawstart()
    except Exception, x:
        if debug:
            raise
        else:
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print "ERROR CAUGHT, will clean up before exit"
        # this assumes no exceptions in shutdown()
        server.shutdown()
        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print "ERROR CAUGHT; will clean up before exit"
        server.shutdown()
        raise
