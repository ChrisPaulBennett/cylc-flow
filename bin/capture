#!/usr/bin/env python

import gtk
import gobject
from time import sleep
import os, re, sys
from warning_dialog import warning_dialog, info_dialog
import subprocess
import threading

"""Run a command as a subprocess and capture the resulting stdout and
stderr to display in a dialog. Examples:
    $ capture "echo foo"
    $ capture "echo foo; echo bar" &
"""

class procwatch( threading.Thread ): 
    def __init__(self, command_list, textbuffer ):
        super(procwatch, self).__init__()
        self.quit = False

        self.command_list = command_list
        self.tb = textbuffer

        self.blue = self.tb.create_tag( None, foreground = "darkblue" )
        self.red = self.tb.create_tag( None, foreground = "red" )
 
    def run(self):
        proc = subprocess.Popen( self.command_list,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True )
        while True:
            if proc.poll() != None:
                self.stdout, self.stderr = proc.communicate()
                gobject.idle_add( self.update_tb )
                break
            else:
                gobject.idle_add( self.update_prog )
                sleep(1)

    def update_tb( self ):
        if self.stdout != '':
            self.tb.insert_with_tags( self.tb.get_end_iter(), '\n\nstdout:\n\n', self.blue )
            self.tb.insert( self.tb.get_end_iter(), self.stdout )
        if self.stderr != '':
            self.tb.insert_with_tags( self.tb.get_end_iter(), '\n\nstderr:\n\n', self.red )
            self.tb.insert_with_tags( self.tb.get_end_iter(), self.stderr, self.red )
        return False

    def update_prog(self):
            self.tb.insert( self.tb.get_end_iter(), '.' )


class info(object):
    def __init__( self, command ):
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        #window.set_size_request(200, 200)
        window.set_border_width( 5 )
        window.set_title( 'command capture' )
        window.connect("delete_event", self.quit)
        window.set_size_request(600, 600)

        sw = gtk.ScrolledWindow()
        sw.set_policy( gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC )

        textview = gtk.TextView()
        textview.set_editable(False)
        textview.set_wrap_mode( gtk.WRAP_WORD )

        tb = textview.get_buffer()
        blue = tb.create_tag( None, foreground = "darkblue" )
        red = tb.create_tag( None, foreground = "red" )
       
        command = ' '.join( command_list )
        tb.insert_with_tags( tb.get_end_iter(), command + '\n\n', blue )

        vbox = gtk.VBox()
        sw.add(textview)
        vbox.add(sw)
        ok_button = gtk.Button( "Close" )
        ok_button.connect("clicked", self.quit, None, None )
        vbox.pack_start(ok_button, False)
        window.add(vbox)
        window.show_all()

        updater = procwatch( command_list, tb )
        updater.start()


    def quit( self, w, e, data=None ):
        gtk.main_quit()

if __name__ == '__main__':
    command_list = sys.argv[1:]
    gobject.threads_init()
    info( command_list )
    gtk.main()


