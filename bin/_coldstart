#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

import sys
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

class coldstart( scheduler ):
    def __init__( self ):
        usage = """cylc coldstart [options] SUITE CYCLE

COLD START a suite at a given cycle time. This starts a suite from
scratch, i.e. without assuming a previous cycle to satisfy the restart
dependencies of any forecast models in the suite. There should be one or
more oneoff cold start tasks in the suite to do this.

Each task proxy is inserted in the 'waiting' state (i.e. prerequisites
not satisfied) at the initial cycle time, or at the next valid cycle
time for the task, including designated cold start tasks (see suite.rc
documentation).

See also:
    cylc warmstart SUITE
    cylc rawstart SUITE

Arguments:
   SUITE                Registered name of the suite to start.
   CYCLE                Initial cycle time (YYYYMMDDHH).""" 

        self.parser = OptionParser( usage )
        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        if len( self.args ) != 2:
            self.parser.error( "Please supply a suite name and initial cycle time." )

        if cycle_time.is_valid( self.args[1] ):
            self.start_time = self.args[1]
        else:
            self.parser.error( "Invalid cycle time: " + self.args[1])

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug

        print "Starting from: " + self.start_time

    def load_tasks( self ):
        # load initial suite state from configured tasks and start time

        excluded_by_commandline = self.exclude
        included_by_commandline = self.include

        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        #print '\nSTARTING AT ' + self.start_time + ' FROM CONFIGURED TASK LIST\n'
        self.log.info( 'Loading state from configured task list' )
        # config.task_list = [ taskname1, taskname2, ...]

        task_list = self.config.get_task_name_list()

        # uniquify in case of accidental duplicates (Python 2.4+)
        task_list = list( set( task_list ) )

        included_by_rc  = self.config[ 'include task list'   ]
        excluded_by_rc  = self.config[ 'exclude task list'   ]

        include_list_supplied = False
        if len( included_by_commandline ) > 0 or len( included_by_rc ) > 0:
            include_list_supplied = True
            included_tasks = included_by_commandline + included_by_rc

        for name in task_list:
            if name in excluded_by_commandline or name in excluded_by_rc:
                continue

            if include_list_supplied:
                if name not in included_tasks:
                    continue
            
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', startup=True )

            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.insert( itask )

if __name__ == '__main__':

    try:
        # parse the commandline and initialize the cylc server
        server = coldstart()
    except Exception, x:
        if debug:
            raise
        else:
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)

    try:
        # configure pyro, logging, etc., and load the suite task pool 
        server.configure()

        # crank it up baby!
        server.run()
        #   OR for profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.

    except Exception, x:

        print "ERROR CAUGHT, will clean up before exit"

        # this assumes no exceptions in cleanup()
        server.cleanup()

        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)

    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print "ERROR CAUGHT; will clean up before exit"
        server.cleanup()
        raise
