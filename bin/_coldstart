#!/usr/bin/env python

import sys
from optparse import OptionParser

import cycle_time
from scheduler import scheduler

global debug
debug = True

class coldstart( scheduler ):
    def __init__( self ):
        usage = """cylc coldstart [options] SUITE YYYYMMDDHHH

COLD START a suite from scratch at a specified cycle time. There should
be one or more oneoff cold start tasks to satisfy any tasks that
normally depend on outputs from a previous cycle (principally the
restart dependencies of warm cycled forecast models). Cold start
tasks can run real processes (e.g. to generate the initial restart
dependencies of a forecast model) or, with no task command defined, just
act as a dummy proxy for some external process that must occur before
the suite is started (e.g. a spinup run). For a suite with no intercycle
dependencies there is no distinction between the cold, warm, and raw
start methods.

Each task proxy is inserted in the 'waiting' state (i.e. prerequisites
not satisfied) at the initial cycle time, or at the next valid cycle
time for the task, including designated cold start tasks:
  SUITE.RC: [special tasks] -> coldstart = task1, task2, ...

NOTE: to prevent a suite being killed when you log out: 
    export PYTHONUNBUFFERED=true   #(*)
    nohup cylc warmstart SUITE YYYYMMDDHH
(*) Python stdout buffering can result in no output until shutdown.

See also:
    cylc warmstart
    cylc rawstart

Arguments:
   SUITE                Registered name of the suite to start.
   YYYYMMDDHH           Initial cycle time.""" 

        self.parser = OptionParser( usage )
        scheduler.__init__( self )

    def parse_commandline( self ):
        ( self.options, self.args ) = self.parser.parse_args()
        if len( self.args ) != 2:
            self.parser.error( "Please supply a suite name and initial cycle time." )

        if cycle_time.is_valid( self.args[1] ):
            self.start_time = self.args[1]
        else:
            self.parser.error( "Invalid cycle time: " + self.args[1])

        scheduler.parse_commandline( self )

        global debug
        debug = self.options.debug

        self.banner[ "COLD START" ] = self.start_time

    def load_tasks( self ):
        self.log.info( 'Cold Start ' + self.start_time )

        # set clock before using log (affects dummy mode only)
        self.clock.set( self.start_time )

        task_list = self.filter_initial_task_list( self.config.get_task_name_list() )
    
        for name in task_list:
            itask = self.config.get_task_proxy( name, self.start_time, 'waiting', startup=True )
            # check stop time in case the user has set a very quick stop
            if self.stop_time and int( itask.c_time ) > int( self.stop_time ):
                # we've reached the stop time already: delete the new task 
                itask.log( 'WARNING', "STOPPING at configured stop time " + self.stop_time )
                itask.prepare_for_death()
                del itask
            else:
                self.insert( itask )

if __name__ == '__main__':
    try:
        server = coldstart()
    except Exception, x:
        if debug:
            raise
        else:
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    try:
        server.run()
        #   For profiling:
        #import cProfile
        #cProfile.run( 'server.run()', 'fooprof' )
        #   and see Python docs "The Python Profilers"
        #   for how to display the resulting stats.
    except Exception, x:
        print "ERROR CAUGHT, will clean up before exit"
        # this assumes no exceptions in shutdown()
        server.shutdown()

        if debug:
            raise
        else:
            print "THE ERROR WAS:"
            print x
            print "(use --debug to see exception traceback)"
            sys.exit(1)
    except:
        # catch 'sys.exit(1)' and 'raise SystemExit("foo")'
        # TO DO: check these can actually be caught
        print "ERROR CAUGHT; will clean up before exit"
        server.shutdown()
        raise
