#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

import os, sys, re
import socket
from optparse import OptionParser
from time import sleep

from preferences import prefs
import cycle_time
from registration import registrations
from lockserver import lockserver
from task_lock import task_lock
from suite_lock import suite_lock

import Pyro.core, Pyro.errors

def print_heading( heading ):
        line = re.sub( '.', '_', heading )
        print line
        print heading

def check_suite_spec( name ):
    reg = registrations()
    if reg.is_registered( name ):
        suite_dir = reg.get( name )
    else:
        reg.print_all()
        raise SystemExit( "suite " + name + " is not registered!" )
    return suite_dir

def check_task_spec( task_spec ):
    try:
        (suite, task_id) = task_spec.split( ':' )
    except:
        raise SystemExit( task_spec + " - Please specify SUITE:TASK_NAME%CYCLE_TIME" )
        
    check_suite_spec( suite )

    try:
        (name, cycle) = task_id.split( '%' )
    except ValueError:
        raise SystemExit( task_spec + " - Please specify SUITE:TASK_NAME%CYCLE_TIME" )
 
    if not cycle_time.is_valid( cycle ):
        raise SystemExit( "Invalid cycle time: " + cycle )

    return ( suite, task_id )


if __name__ == "__main__":

    usage = """cylc lockserver [options]

This is the user interface to the cylc lockserver daemon, cylclockd,
which brokers suite and task locks for cylc suites.  For information
on how to start, stop, restart, and check the status of cylclockd,
see $CYLC_DIR/admin/cylclockd.README.

Use of the lockserver is optional - see cylc preferences. 

TASK LOCKS prevent multiple instances of the same task (NAME%CYCLE) from
running simultaneously, whether they are spawned by a cylc scheduler or
by 'cylc submit'. Traditional lock files cannot easily be used by cylc
because it is possible for an external task that consists of multiple
components to start and finish executing on different host machines.

SUITE LOCKS prevent multiple instances of entire cylc suites from
running simultaneously, even under different registered names (unless
the suite config file states that suite is capable of doing this!).

Manual lock acquisition is mainly for testing purposes, but manual
release may be required to remove stale locks left after a suite or task
exits without releasing its locks).""" 

    parser = OptionParser( usage )

    parser.set_defaults( pns_host= socket.getfqdn(), 
            acquire=None, release=None, suite_acquire=None,
            suite_acquire_nonex=None, suite_release=None, list_all=False )

    parser.add_option( "--host",
            help="(for --start|restart|debug). Pyro nameserver host "
            "(defaults to local host name).",
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "--acquire-task", help="Acquire a task lock.",
            metavar="SUITE:NAME%CYCLE", action="store", dest="acquire" )

    parser.add_option( "--release-task", help="Release a task lock.",
            metavar="SUITE:NAME%CYCLE", action="store", dest="release" )

    parser.add_option( "--acquire-suite", help="Acquire an exclusive suite lock.",
            metavar="SUITE", action="store", dest="suite_acquire" )

    parser.add_option( "--acquire-suite-nonex", help="Acquire a non-exclusive suite lock.",
            metavar="SUITE", action="store", dest="suite_acquire_nonex" )

    parser.add_option( "--release-suite", help="Release a suite, and "
            "any tasks held by it.",
            metavar="SUITE", action="store", dest="suite_release" )

    parser.add_option( "-p", "--print", help="Print currently held locks.",
            action="store_true", dest="list_all" )

    parser.add_option( "-l", "--list", help="List currently held locks.",
            action="store_true", dest="list_all" )

    parser.add_option( "-c", "--clear", help="Release all task locks.",
            action="store_true", dest="clear_all" )

    ( options, args ) = parser.parse_args()

    count = 0
    for opt in [ options.acquire, options.release,
            options.suite_acquire, options.suite_acquire_nonex,
            options.suite_release, options.list_all, options.clear_all ]:
        if opt:
            count += 1

    if count != 1:
        parser.error( "choose one option only!" )
    
    pns_host = options.pns_host

    user = os.environ[ 'USER' ]
    os.environ[ 'CYLC_USE_LOCKSERVER' ] = 'True'

    if options.acquire:
        (suite, task_id) = check_task_spec( options.acquire )
        try:
            if not task_lock( task_id, user, suite, pns_host ).acquire():
                raise SystemExit( "ERROR: Failed to acquire a lock for " + options.acquire )
        except Pyro.errors.NamingError:
            raise SystemExit( "Failed to connect to a lockserver on " + pns_host )

    elif options.release:
        (suite, task_id) = check_task_spec( options.release )
        try:
            if not task_lock( task_id, user, suite, pns_host ).release():
                raise SystemExit( "ERROR: Failed to release a lock for " + options.release )
        except Pyro.errors.NamingError:
            raise SystemExit( "Failed to connect to a lockserver on " + pns_host )

    elif options.suite_acquire:
        suitename = options.suite_acquire
        suitedir = check_suite_spec( suitename )
        try:
            if not suite_lock( pns_host, user, suitename, suitedir, 'scheduler' ).request_suite_access( True ):
                raise SystemExit( "ERROR: Failed to acquire a lock for " + options.suite_acquire )
        except Pyro.errors.NamingError:
            raise SystemExit( "Failed to connect to a lockserver on " + pns_host )

    elif options.suite_acquire_nonex:
        suitename = options.suite_acquire_nonex
        suitedir = check_suite_spec( suitename )
        try:
            if not suite_lock( pns_host, user, suitename, suitedir, 'scheduler' ).request_suite_access( False ):
                raise SystemExit( "ERROR: Failed to acquire a lock for " + options.suite_acquire_nonex )
        except Pyro.errors.NamingError:
            raise SystemExit( "Failed to connect to a lockserver on " + pns_host )

    elif options.suite_release:
        suitename = options.suite_release
        suitedir = check_suite_spec( suitename )
        try:
            if not suite_lock( pns_host, user, suitename, suitedir, 'scheduler' ).release_suite_access():
                raise SystemExit( "ERROR: Failed to release a lock for " + options.suite_release )
        except Pyro.errors.NamingError:
            raise SystemExit( "Failed to connect to a lockserver on " + pns_host )

    elif options.list_all:
        try:
            (task_locks, suite_ex, suite_nonex ) = lockserver( pns_host ).dump()
        except Pyro.errors.NamingError:
            raise SystemExit( "Failed to connect to a lockserver on " + pns_host )
        #except Pyro.errors.ProtocolError, x:
        #  ?huh?
        #    print x
        #    print 'This may mean you have attempted to access a dead lockserver.'
        #    print 'Before starting a new lockserver, you may need to:'
        #    print ' 1/ delete the old lockserver pid file (see cylc preferences)'
        #    print ' 2/ delete the old lockserver group in the Pyro nameserver:'
        #    print '    $ pyro-nsc deletegroup :cylc-lockserver'
        #    sys.exit(1)
        #    #raise

        print_heading( str( len( suite_ex ) ) + " exclusive suite locks" )
        for suitedir in suite_ex:
            [ group ] = suite_ex[ suitedir ]
            print " - ", group, '-->', suitedir

        print_heading( str( len( suite_nonex ) ) + " non-exclusive suite locks" )
        for suitedir in suite_nonex:
            groups = suite_nonex[ suitedir ]
            for group in groups:
                print " - ", group, '-->', suitedir

        print_heading( str( len( task_locks ) ) + " task locks" )
        for lock in task_locks:
            print " - ", lock

    elif options.clear_all:
        try:
            lockserver( pns_host ).clear()
        except Pyro.errors.NamingError:
            raise SystemExit( "Failed to connect to a lockserver on " + pns_host )

    else:
        # should not be reached
        raise SystemExit( "unknown cylc lockserver option" )
