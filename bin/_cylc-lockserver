#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# standard Python modules
import os, sys, re
import socket
from optparse import OptionParser
from time import sleep

# cylc source modules
import pyrex
import cylcrc
import cycle_time
from registration import registrations
from lockserver import lockserver, lock, syslock, control

# pyro modules
import Pyro.core, Pyro.naming
from Pyro.errors import NamingError
from Pyro.ext.daemonizer import Daemonizer

def print_heading( heading ):
        line = re.sub( '.', '_', heading )
        print line
        print heading

def check_system_spec( name ):
    reg = registrations()
    if reg.is_registered( name ):
        system_dir = reg.get( name )
    else:
        reg.print_all()
        raise SystemExit( "System " + name + " is not registered!" )
    return system_dir

def check_task_spec( task_spec ):
    try:
        (system, task_id) = task_spec.split( ':' )
    except:
        raise SystemExit( task_spec + " - Please specify SYSTEM:TASK_NAME%CYCLE_TIME" )
        
    check_system_spec( system )

    try:
        (name, cycle) = task_id.split( '%' )
    except:
        raise SystemExit( task_spec + " - Please specify SYSTEM:TASK_NAME%CYCLE_TIME" )
 
    if not cycle_time.is_valid( cycle ):
        raise SystemExit( "Invalid cycle time: " + cycle )

    return ( system, task_id )


class ServerDaemon( Daemonizer ):
    def __init__( self, pidfile, pns_host, logfile, task_lock=None ):
        self.pns_host = pns_host
        self.logfile = logfile
        Daemonizer.__init__(self, pidfile)

    def main_loop( self ):
        # NOTE THE PYRO SERVER BEING DAEMONIZED MUST BE STARTED HERE
        # OTHERWISE ITS SOCKET FILE DESCRIPTORS WILL BE CLOSED DOWN IN
        # DAEMONIZER.__init__().

        # for debugging in daemon mode, uncomment the following so that
        # exceptions will be written to log files.

        #foo = open( "/home/oliverh/cylc/foo.txt", "a" )
        #server = None
        #try:
        server = LockServer(self.pns_host, self.logfile)
        #except Exception, x:
        #    foo.write( str(x) + "\n" )
        #else:
        #    pass

        #bar = open( "/home/oliverh/cylc/bar.txt", "a" )
        #try:
        server.start()
        #except Exception, x:
        #    bar.write( str(x) + "\n" )
        #else:
        #    pass

class LockServer:
    def __init__( self, pns_host, logfile ):
        # LOCATE THE PYRO NAMESERVER-------------------------------------------
        #self.nameserver = pyrex.discover( pns_host )
        try:
            self.nameserver = Pyro.naming.NameServerLocator().getNS( pns_host )
        except NamingError:
            raise SystemExit("Failed to find a Pyro nameserver on " + hostname )

        self.logfile = logfile

        # CREATE A UNIQUE NAMESERVER GROUPNAME FOR THE LOCK SERVER ------------
        self.groupname = 'cylc'
        #self.nameserver.create_groupname( self.groupname )
        try:
            self.nameserver.createGroup( self.groupname )
        except:
            self.nameserver.deleteGroup( self.groupname )
            self.nameserver.createGroup( self.groupname )

        Pyro.config.PYRO_MULTITHREADED = 0
        # USE DNS NAMES INSTEAD OF FIXED IP ADDRESSES FROM /etc/hosts
        # (see the Userguide "Networking Issues" section).
        Pyro.config.PYRO_DNS_URI = True
        Pyro.config.PYRO_STDLOGGING = True
        Pyro.config.PYRO_TRACELEVEL = 3
        Pyro.core.initServer()

    def start( self ):
        # CREATE A PYRO pyro_daemon FOR THIS SYSTEM
        # (single threaded prob not necessary for lockserver
        # but it doesn't matter as few connections needed)
        self.pyro_daemon = Pyro.core.Daemon()
        #pyro_daemon.useNameServer(self.nameserver.get_ns())
        self.pyro_daemon.useNameServer(self.nameserver)

        locker = lockserver( logfile )
        #pyro_daemon.connect( locker, self.nameserver.obj_name( 'lockserver', self.groupname ))
        #foo = open( "/home/oliverh/cylc/foo.txt", "a" )
        try:
            self.pyro_daemon.connect( locker, 'cylc.lockserver' )
        except Exception, x:
            #    foo.write( str(x) + "\n" )
            raise
 
        while True:
            self.pyro_daemon.handleRequests()


if __name__ == "__main__":

    usage = """cylc lockserver [options]

The cylc lockserver daemon provides task locking functionality: it
prevents multiple instances of the same task at the same cycle time from
running at the same time.  Unlike traditional "lock files" this works
even for tasks that start and finish executing as different processes on
different host machines.  Additionally, the lockserver prevents multiple
instances of an entire cylc system from running at the same time, even
if registered under different names (unless the system config file
allows this!).

Use of the lockserver is optional; see 'cylc preferences --help'.

Manual lock acquisition using this command is mainly for testing
purposes; manual release, however, may be required to remove zombie
locks (wherein a system or task has exited without releasing its lock).
You must be the system owner in order to do this.""" 

    parser = OptionParser( usage )

    parser.set_defaults( pns_host= socket.getfqdn(), rcfile=None,
            start=False, debug=False, restart=False, status=False,
            stop=False, acquire=None, release=None, system_acquire=None,
            system_acquire_nonex=None, system_release=None, list_all=False )

    parser.add_option( "--host",
            help="(for --start|restart|debug). Pyro nameserver host, "
            "defaults to the local hostname. Use if not auto-detected "
            "(which depends on network config).", 
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "--start", help="Start up the server.",
            action="store_true", dest="start" )

    parser.add_option( "--debug", help="(DEBUGGING) Do not daemonize the server, "
           "i.e. do not detach from the parent environment.",
            action="store_true", dest="debug" )

    parser.add_option( "--restart", help="Restart a running server.",
            action="store_true", dest="restart" )

    parser.add_option( "--status", help="Check that the server is running.",
            action="store_true", dest="status" )

    parser.add_option( "--stop", help="Shut down the server.",
            action="store_true", dest="stop" )

    parser.add_option( "--rcfile", help="Use an alternative cylc rc file "
            "(default $HOME/.cylcrc).", metavar="PATH", action="store",
            dest="rcfile" )

    parser.add_option( "--acquire-task", help="Acquire a task lock.",
            metavar="SYSTEM:NAME%CYCLE", action="store", dest="acquire" )

    parser.add_option( "--release-task", help="Release a task lock.",
            metavar="SYSTEM:NAME%CYCLE", action="store", dest="release" )

    parser.add_option( "--acquire-system", help="Acquire an exclusive system lock.",
            metavar="SYSTEM", action="store", dest="system_acquire" )

    parser.add_option( "--acquire-system-nonex", help="Acquire a non-exclusive system lock.",
            metavar="SYSTEM", action="store", dest="system_acquire_nonex" )

    parser.add_option( "--release-system", help="Release a system lock.",
            metavar="SYSTEM", action="store", dest="system_release" )

    parser.add_option( "--list-all", help="Get all task locks.",
            action="store_true", dest="list_all" )

    parser.add_option( "--clear-all", help="Release all task locks.",
            action="store_true", dest="clear_all" )

    ( options, args ) = parser.parse_args()

    count = 0
    for opt in [ options.start, options.restart, options.stop,
            options.status, options.debug, options.acquire,
            options.release, options.system_acquire,
            options.system_acquire_nonex, options.system_release,
            options.list_all, options.clear_all ]:
        if opt:
            count += 1

    if count != 1:
        parser.error( "choose one option only!" )
    
    pns_host = options.pns_host

    user = os.environ[ 'USER' ]
    os.environ[ 'CYLC_USE_LOCKSERVER' ] = 'True'

    if options.acquire:
        (system, task_id) = check_task_spec( options.acquire )
        group = user + '^' + system
        if not lock( task_id, group, pns_host ).acquire():
            print >> sys.stderr, "ERROR: Failed to acquire a lock for " + options.acquire
            sys.exit(1)
        sys.exit(0)

    if options.release:
        (system, task_id) = check_task_spec( options.release )
        group = user + '^' + system
        if not lock( task_id, group, pns_host ).release():
            print >> sys.stderr, "ERROR: Failed to release a lock for " + options.release
            sys.exit(1)
        sys.exit(0)

    if options.system_acquire:
        sysname = options.system_acquire
        sysdir = check_system_spec( sysname )
        group = user + '^' + sysname
        if not syslock( pns_host, group, sysdir, 'scheduler' ).request_system_access( True ):
            print >> sys.stderr, "ERROR: Failed to acquire a lock for " + options.system_acquire
            sys.exit(1)
        sys.exit(0)

    if options.system_acquire_nonex:
        sysname = options.system_acquire_nonex
        sysdir = check_system_spec( sysname )
        group = user + '^' + sysname
        if not syslock( pns_host, group, sysdir, 'scheduler' ).request_system_access( False ):
            print >> sys.stderr, "ERROR: Failed to acquire a lock for " + options.system_acquire_nonex
            sys.exit(1)
        sys.exit(0)

    if options.system_release:
        sysname = options.system_release
        sysdir = check_system_spec( sysname )
        group = user + '^' + sysname
        if not syslock( pns_host, group, sysdir, 'scheduler' ).release_system_access():
            print >> sys.stderr, "ERROR: Failed to release a lock for " + options.system_release
            sys.exit(1)
        sys.exit(0)

    if options.list_all:
        (task_locks, system_ex, system_nonex ) = control( pns_host ).dump()

        print_heading( str( len( system_ex ) ) + " exclusive system locks" )
        for sysdir in system_ex:
            [ group ] = system_ex[ sysdir ]
            print " - ", group, '-->', sysdir

        print_heading( str( len( system_nonex ) ) + " non-exclusive system locks" )
        for sysdir in system_nonex:
            groups = system_nonex[ sysdir ]
            for group in groups:
                print " - ", group, '-->', sysdir

        print_heading( str( len( task_locks ) ) + " task locks" )
        for lock in task_locks:
            print " - ", lock
        sys.exit(0)

    if options.clear_all:
        locks = control( pns_host ).clear()
        #for lock in locks:
        #    print lock
        sys.exit(0)

    config = cylcrc.rc( options.rcfile )
    logfile = config.get( 'lockserver', 'log file' )
    pidfile = config.get( 'lockserver', 'pid file' )

    server_daemon = ServerDaemon( pidfile, pns_host, logfile ) 

    argv = None
    if options.start:
        argv = 'start'
    elif options.stop:
        argv = 'stop'
    elif options.restart:
        argv = 'restart'
    elif options.status:
        argv = 'status'
    elif options.debug:
        argv = 'debug'

    server_daemon.process_command_line([ sys.argv[0], argv ])
