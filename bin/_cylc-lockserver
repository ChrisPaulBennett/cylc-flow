#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

import os, sys, re
import socket
from optparse import OptionParser
from time import sleep

from preferences import prefs
import cycle_time
from registration import registrations
from lockserver import lockserver, control
from task_lock import task_lock
from system_lock import system_lock

import Pyro.core, Pyro.errors
from Pyro.ext.daemonizer import Daemonizer

def print_heading( heading ):
        line = re.sub( '.', '_', heading )
        print line
        print heading

def check_system_spec( name ):
    reg = registrations()
    if reg.is_registered( name ):
        system_dir = reg.get( name )
    else:
        reg.print_all()
        raise SystemExit( "System " + name + " is not registered!" )
    return system_dir

def check_task_spec( task_spec ):
    try:
        (system, task_id) = task_spec.split( ':' )
    except:
        raise SystemExit( task_spec + " - Please specify SYSTEM:TASK_NAME%CYCLE_TIME" )
        
    check_system_spec( system )

    try:
        (name, cycle) = task_id.split( '%' )
    except ValueError:
        raise SystemExit( task_spec + " - Please specify SYSTEM:TASK_NAME%CYCLE_TIME" )
 
    if not cycle_time.is_valid( cycle ):
        raise SystemExit( "Invalid cycle time: " + cycle )

    return ( system, task_id )

class ServerDaemon( Daemonizer ):
    def __init__( self, pidfile, pns_host, logfile, task_lock=None ):
        self.pns_host = pns_host
        self.logfile = logfile
        Daemonizer.__init__(self, pidfile)

    def main_loop( self ):
        # NOTE THE PYRO SERVER BEING DAEMONIZED MUST BE STARTED HERE
        # OTHERWISE ITS SOCKET FILE DESCRIPTORS WILL BE CLOSED DOWN IN
        # DAEMONIZER.__init__().

        # for debugging in daemon mode, uncomment the following so that
        # exceptions will be written to log files.

        #foo = open( "/home/oliverh/cylc/foo.txt", "a" )
        #server = None
        #try:
        server = LockServer(self.pns_host, self.logfile)
        #except Exception, x:
        #    foo.write( str(x) + "\n" )
        #else:
        #    pass

        #bar = open( "/home/oliverh/cylc/bar.txt", "a" )
        #try:
        server.start()
        #except Exception, x:
        #    bar.write( str(x) + "\n" )
        #else:
        #    pass

class LockServer:
    def __init__( self, pns_host, logfile ):
        # LOCATE THE PYRO NAMESERVER-------------------------------------------
        self.logfile = logfile
        self.pns_host = pns_host

        Pyro.config.PYRO_MULTITHREADED = 0
        # USE DNS NAMES INSTEAD OF FIXED IP ADDRESSES FROM /etc/hosts
        # (see the Userguide "Networking Issues" section).
        Pyro.config.PYRO_DNS_URI = True
        # UNCOMMENT THE FOLLOWING FOR LOGGING (goes to $PWD/Pyro_log)
        #Pyro.config.PYRO_STDLOGGING = True
        #Pyro.config.PYRO_TRACELEVEL = 3
        Pyro.core.initServer()

    def start( self ):
        # CREATE A PYRO pyro_daemon FOR THIS SYSTEM
        # (single threaded prob not necessary for lockserver
        # but it doesn't matter as few connections needed)

        locker = lockserver( self.pns_host, logfile )

        self.pyro_daemon = Pyro.core.Daemon()
        self.pyro_daemon.useNameServer(locker.get_ns())

        #foo = open( "/home/oliverh/cylc/foo.txt", "a" )
        try:
            self.pyro_daemon.connect( locker, locker.get_pyro_name() )
        except Pyro.errors.NamingError,x:
            # foo.write( str(x) + "\n"
            print 'Pyro Naming ERROR: ', str(x) + "\n"
            print 'This probably means the lockserver previously suffered a hard shutdown'
            print 'To remove the lockserver registration from the Pyro Nameserver, do this:'
            print '% pyro-nsc deletegroup :cylc-lockserver'
            print
            sys.exit(1)
            #raise
        except Exception, x:
            # foo.write( str(x) + "\n"
            print 'ERROR: ', str(x) + "\n"
            sys.exit(1)
            #raise
 
        while True:
            self.pyro_daemon.handleRequests()


if __name__ == "__main__":

    usage = """cylc lockserver [options]

The cylc lockserver brokers system and task locks for cylc systems. 

TASK LOCKS prevent multiple instances of the same task (NAME%CYCLE) from
running simultaneously, whether they are spawned by a cylc scheduler or
by 'cylc run-task'. Traditional lock files cannot easily be used by cylc
because it is possible for an external task that consists of multiple
components to start and finish executing on different host machines.

SYSTEM LOCKS prevent multiple instances of entire cylc systems from
running simultaneously, even under different registered names (unless
the system config file states that system is capable of doing this!).

Use of the cylc lockserver is optional; see 'cylc preferences --help'.

The lockserver is a daemon process (it automatically detaches from
its parent environment and can be left running indefinitely). 

Manual lock acquisition using this command is mainly for testing
purposes; manual release, however, may be required to remove stale
locks left after a system or task exits without releasing its lock).""" 

    parser = OptionParser( usage )

    parser.set_defaults( pns_host= socket.getfqdn(), 
            start=False, debug=False, restart=False, status=False,
            stop=False, acquire=None, release=None, system_acquire=None,
            system_acquire_nonex=None, system_release=None, list_all=False )

    parser.add_option( "--host",
            help="(for --start|restart|debug). Pyro nameserver host "
            "(defaults to local host name).",
            metavar="HOSTNAME", action="store", dest="pns_host" )

    parser.add_option( "--start", help="Start up the server.",
            action="store_true", dest="start" )

    parser.add_option( "--debug", help="(DEBUGGING) Do not daemonize the server.",
            action="store_true", dest="debug" )

    parser.add_option( "--restart", help="Restart a running server.",
            action="store_true", dest="restart" )

    parser.add_option( "--status", help="Check that the server is running.",
            action="store_true", dest="status" )

    parser.add_option( "--stop", help="Shut down the server.",
            action="store_true", dest="stop" )

    parser.add_option( "--acquire-task", help="Acquire a task lock.",
            metavar="SYSTEM:NAME%CYCLE", action="store", dest="acquire" )

    parser.add_option( "--release-task", help="Release a task lock.",
            metavar="SYSTEM:NAME%CYCLE", action="store", dest="release" )

    parser.add_option( "--acquire-system", help="Acquire an exclusive system lock.",
            metavar="SYSTEM", action="store", dest="system_acquire" )

    parser.add_option( "--acquire-system-nonex", help="Acquire a non-exclusive system lock.",
            metavar="SYSTEM", action="store", dest="system_acquire_nonex" )

    parser.add_option( "--release-system", help="Release a system lock.",
            metavar="SYSTEM", action="store", dest="system_release" )

    parser.add_option( "--list", help="Get all task locks.",
            action="store_true", dest="list_all" )

    parser.add_option( "--clear", help="Release all task locks.",
            action="store_true", dest="clear_all" )

    ( options, args ) = parser.parse_args()

    count = 0
    for opt in [ options.start, options.restart, options.stop,
            options.status, options.debug, options.acquire,
            options.release, options.system_acquire,
            options.system_acquire_nonex, options.system_release,
            options.list_all, options.clear_all ]:
        if opt:
            count += 1

    if count != 1:
        parser.error( "choose one option only!" )
    
    pns_host = options.pns_host

    user = os.environ[ 'USER' ]
    os.environ[ 'CYLC_USE_LOCKSERVER' ] = 'True'

    if options.acquire:
        (system, task_id) = check_task_spec( options.acquire )
        if not task_lock( task_id, user, system, pns_host ).acquire():
            print >> sys.stderr, "ERROR: Failed to acquire a lock for " + options.acquire
            sys.exit(1)
        sys.exit(0)

    if options.release:
        (system, task_id) = check_task_spec( options.release )
        if not task_lock( task_id, user, system, pns_host ).release():
            print >> sys.stderr, "ERROR: Failed to release a lock for " + options.release
            sys.exit(1)
        sys.exit(0)

    if options.system_acquire:
        sysname = options.system_acquire
        sysdir = check_system_spec( sysname )
        if not system_lock( pns_host, user, sysname, sysdir, 'scheduler' ).request_system_access( True ):
            print >> sys.stderr, "ERROR: Failed to acquire a lock for " + options.system_acquire
            sys.exit(1)
        sys.exit(0)

    if options.system_acquire_nonex:
        sysname = options.system_acquire_nonex
        sysdir = check_system_spec( sysname )
        if not system_lock( pns_host, user, sysname, sysdir, 'scheduler' ).request_system_access( False ):
            print >> sys.stderr, "ERROR: Failed to acquire a lock for " + options.system_acquire_nonex
            sys.exit(1)
        sys.exit(0)

    if options.system_release:
        sysname = options.system_release
        sysdir = check_system_spec( sysname )
        if not system_lock( pns_host, user, sysname, sysdir, 'scheduler' ).release_system_access():
            print >> sys.stderr, "ERROR: Failed to release a lock for " + options.system_release
            sys.exit(1)
        sys.exit(0)

    if options.list_all:
        try:
            (task_locks, system_ex, system_nonex ) = control( pns_host ).dump()
        except Pyro.errors.ProtocolError, x:
            print x
            print 'This may mean you have attempted to access a dead lockserver.'
            print 'Before starting a new lockserver, you may need to:'
            print ' 1/ delete the old lockserver pid file (see cylc preferences)'
            print ' 2/ delete the old lockserver group in the Pyro nameserver:'
            print '    $ pyro-nsc deletegroup :cylc-lockserver'
            sys.exit(1)
            #raise

        print_heading( str( len( system_ex ) ) + " exclusive system locks" )
        for sysdir in system_ex:
            [ group ] = system_ex[ sysdir ]
            print " - ", group, '-->', sysdir

        print_heading( str( len( system_nonex ) ) + " non-exclusive system locks" )
        for sysdir in system_nonex:
            groups = system_nonex[ sysdir ]
            for group in groups:
                print " - ", group, '-->', sysdir

        print_heading( str( len( task_locks ) ) + " task locks" )
        for lock in task_locks:
            print " - ", lock
        sys.exit(0)

    if options.clear_all:
        locks = control( pns_host ).clear()
        #for lock in locks:
        #    print lock
        sys.exit(0)

    config = prefs()
    logfile = config.get( 'lockserver', 'log file' )
    pidfile = config.get( 'lockserver', 'pid file' )

    server_daemon = ServerDaemon( pidfile, pns_host, logfile ) 

    argv = None
    if options.start:
        argv = 'start'
    elif options.stop:
        argv = 'stop'
    elif options.restart:
        argv = 'restart'
    elif options.status:
        argv = 'status'
    elif options.debug:
        argv = 'debug'

    server_daemon.process_command_line([ sys.argv[0], argv ])
