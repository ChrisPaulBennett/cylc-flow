#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|


# TO DO: THIS SCRIPT NEEDS TO BE CLEANED UP AND RESTRUCTURED.

import string, glob
import sys, os, re

def usage():
    print 'USAGE: ' + sys.argv[0] + ' <output dir> <list of task definition files>'
    sys.exit(1)

def indent_more():
    global indent
    global indent_unit
    indent += indent_unit

def escape_quotes( strng ):
    return re.sub( '([\\\'"])', r'\\\1', strng )

def indent_less():
    global indent
    global indent_unit
    indent = re.sub( indent_unit, '', indent, 1 )
    
def print_parsed_info():

    global parsed_def

    for item in parsed_def:
        print
        print item + ':' 
        for condition in parsed_def[ item ]:
            print '  ' + condition + ':'
            for line in parsed_def[ item ][ condition ]:
                print '   - ', line

def interpolate_cycle_times( strng ):
    # interpolate $(CYCLE_TIME [+/-N]) in a string
    # strng = 'a string'  (SINGLE QUOTES REQUIRED)

    # strip leading spaces
    strng = re.sub( "^'\s+", "'", strng )

    # replace "$(CYCLE_TIME)"
    strng = re.sub( "^'\$\(CYCLE_TIME\)'$",   "self.c_time",     strng ) # alone
    strng = re.sub( "^'\$\(CYCLE_TIME\)",     "self.c_time + '", strng ) # start line
    strng = re.sub( "\$\(CYCLE_TIME\)'$", "' + self.c_time"   ,  strng ) # end line
    strng = re.sub( "\$\(CYCLE_TIME\)" , "'  + self.c_time + '", strng ) # mid line

    # replace "$(CYCLE_TIME - XX )"
    m = re.search( '\$\(\s*CYCLE_TIME\s*-\s*(\d+)\s*\)', strng )
    if m:
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)'$",   "cycle_time.decrement( self.c_time, " + m.group(1) + ")",     strng ) # alone
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)",     "cycle_time.decrement( self.c_time, " + m.group(1) + ") + '", strng ) # start line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)'$", "' + cycle_time.decrement( self.c_time, " + m.group(1) + ")",     strng ) # mid line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)",   "' + cycle_time.decrement( self.c_time, " + m.group(1) + ") + '", strng ) # end line

    # replace "$(CYCLE_TIME + XX )"
    m = re.search( '\$\(\s*CYCLE_TIME\s*\+\s*(\d+)\s*\)', strng )
    if m:
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)'$",   "cycle_time.increment( self.c_time, " + m.group(1) + ")",     strng ) # alone
        strng = re.sub( "^'\$\(\s*CYCLE_TIME.*\)",     "cycle_time.increment( self.c_time, " + m.group(1) + ") + '", strng ) # start line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)'$", "' + cycle_time.increment( self.c_time, " + m.group(1) + ")",     strng ) # mid line
        strng = re.sub( "\$\(\s*CYCLE_TIME.*\)",   "' + cycle_time.increment( self.c_time, " + m.group(1) + ") + '", strng ) # end line

    # now check for any environment variable $CYCLE_TIME or ${CYCLE_TIME}
    m = re.search( '\$CYCLE_TIME', strng )
    n = re.search( '\$\{CYCLE_TIME\}', strng )
    if m:
        strng = re.sub( "^'\$CYCLE_TIME",     "self.c_time + '", strng ) # start line
        strng = re.sub( "\$CYCLE_TIME'$", "' + self.c_time"   ,  strng ) # end line
        strng = re.sub( "\$CYCLE_TIME" , "'  + self.c_time + '", strng ) # mid line
    if n:
        strng = re.sub( "^'\$\{CYCLE_TIME\}",     "self.c_time + '", strng ) # start line
        strng = re.sub( "\$\{CYCLE_TIME\}'$", "' + self.c_time"   ,  strng ) # end line
        strng = re.sub( "\$\{CYCLE_TIME\}" , "'  + self.c_time + '", strng ) # mid line
    
    return strng

def require_quotes( strng, item ):
    # require enclosing quotes, then strip them off
    
    # first strip any whitespace
    str = string.strip( strng )

    m = re.match( '^".*"$', str )
    if m:
        stripped = string.strip( str, '"' )
    else:
        print 'ERROR: ' + item + ' must be enclosed in double quotes:'
        print strng
        sys.exit(1)

    return stripped

def time_trans( strng, hours=False ):
    # translate a time of the form:
    #  x sec, y min, z hr
    # into NUMERICAL MINUTES or HOURS,
    # and return a string thereof.

    if not re.search( '^\s*(.*)\s*min\s*$', strng ) and \
        not re.search( '^\s*(.*)\s*sec\s*$', strng ) and \
        not re.search( '^\s*(.*)\s*hr\s*$', strng ):
            print "ERROR: missing time unit on " + strng
            sys.exit(1)

    m = re.search( '^\s*(.*)\s*min\s*$', strng )
    if m:
        [ mins ] = m.groups()
        if hours:
            return str( float( mins / 60.0 ) )
        else:
            return str( float(mins) )

    m = re.search( '^\s*(.*)\s*sec\s*$', strng )
    if m:
        [ secs ] = m.groups()
        if hours:
            return str( float(secs)/3600.0 )
        else:
            return str( float(secs)/60.0 )

    m = re.search( '^\s*(.*)\s*hr\s*$', strng )
    if m:
        [ hrs ] = m.groups()
        if hours:
            return str( float(hrs) )
        else:
            return str( float(hrs)*60.0 )

def get_parsed( item ):
    if parsed_def[ item ].keys() != [ 'any' ]:
        print 'ERROR: ' + item + ' is conditional'
        sys.exit(1)
    return parsed_def[ item ][ 'any' ]

def get_conditions( item ):
    # return specific (not 'any') conditions for parsed item
    cond = parsed_def[ item ].keys()
    cond.remove( 'any' )
    return cond

def write_reqs( key, name, type ):
    global inherit

    if not inherit or key in parsed_def:
        OUT.write( indent + 'self.' + name + ' = ' + type + '( self.id )\n' )

    if key in parsed_def:
        for line in parsed_def[ key ]['any']:
            if type == 'outputs':
                parse_output( line, name )
            else:
                parse_prereq( line, name )
        for condition in get_conditions( key ):
            hours = condition.split(',')
            for line in parsed_def[ key ][ condition ]:
                for hour in hours:
                    OUT.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                    indent_more()
                    if type == 'outputs':
                        parse_output( line, name )
                    else:
                        parse_prereq( line, name )
                    indent_less()

def parse_output( output, name ):
    req = require_quotes( output, name )
    req = "'" + req + "'"
    req = interpolate_cycle_times( req )
    OUT.write( indent + 'self.' + name + '.add( ' + req + ' )\n' )
 
def parse_prereq( prereq, name ):
    # case 0: conditional: [A] or [B]
    # case 1:     "the quick brown fox"
    # case 2:   A "the quick brown fox"

    # conditional expression
    m = re.search( 'conditional:\s+(.*)$', prereq )
    if m:
        expr = m.groups()[0]
        OUT.write( indent + 'self.' + name + '.set_conditional_expression( "' + expr + '" )\n' )
        return

    # label
    m = re.match( '^\s*(\w+)\s+(.*)$', prereq )
    if m:
        [ label, prereq ] = m.groups()
        label = '"' + label + '"'
    else:
        label = "None"

    req = require_quotes( prereq, name )
    req = "'" + req + "'"
    req = interpolate_cycle_times( req )

    OUT.write( indent + 'self.' + name + '.add( ' + req + ', ' + label + ' )\n' )
 

#================= MAIN PROGRAM ========================================
def main( argv ):

    global parsed_def
    global FILE
    global inherit
    global OUT

    global indent, indent_unit
    indent = ''
    indent_unit = '    '

    if len( argv ) < 2:
        usage()

    taskdir = argv[1]
    if not os.path.isdir( taskdir ):
        raise SystemExit( "Directory not found: " + taskdir )

    task_def_files = argv[2:]

    allowed_keys = [ 'LOGFILES', 'INHERIT', 'TASK', 'OWNER', 'HOURS',
            'COMMAND', 'REMOTE_HOST', 'DIRECTIVES', 'SCRIPTING',
            'ENVIRONMENT', 'INTERCYCLE', 'PREREQUISITES',
            'COLDSTART_PREREQUISITES', 'SUICIDE_PREREQUISITES',
            'OUTPUTS', 'N_RESTART_OUTPUTS', 'TYPE', 'CONTACT_DELAY',
            'DESCRIPTION', 'OUTPUT_PATTERNS', 'FOLLOW_ON', 'FAMILY',
            'MEMBERS', 'MEMBER_OF' ]

    allowed_types = ['tied', 'free', 'cycling_daemon' ]
    allowed_modifiers = ['dummy', 'sequential', 'oneoff', 'contact', 'catchup_contact' ]

    # preamble for task class files
    preamble = '''
#!/usr/bin/env python

#         __________________________
#         |____C_O_P_Y_R_I_G_H_T___|
#         |                        |
#         |  (c) NIWA, 2008-2010   |
#         | Contact: Hilary Oliver |
#         |  h.oliver@niwa.co.nz   |
#         |    +64-4-386 0461      |
#         |________________________|

# WARNING: THIS FILE WAS AUTO-GENERATED BY cylc configure

from daemon import daemon
from asynchronous import asynchronous
from tied import tied
from free import free
from family import family
from mod_oneoff import oneoff
from mod_sequential import sequential
from mod_contact import contact
from mod_catchup_contact import catchup_contact
from prerequisites_fuzzy import fuzzy_prerequisites
from prerequisites import prerequisites
from outputs import outputs
from cycling_daemon import cycling_daemon
from time import sleep
from task_output_logs import logfiles
import cycle_time
import task_state
from OrderedDict import OrderedDict
from collections import deque

'''


    n_files = len(task_def_files)
    i = 0

    seen = {}

    for task_def_file in task_def_files:

        taskdef_name = os.path.basename( task_def_file )
        task_name = 'class_' + re.sub( '.def$', '.py', taskdef_name )

        print '  + ' + taskdef_name + ' --> configured/' + task_name
        i += 1

        DEF = open( task_def_file, 'r' )
        lines = DEF.readlines()
        DEF.close()

        # PARSE THE TASKDEF FILE----------------------------
        current_key = None
        parsed_def = {}
        for lline in lines:
            line = string.strip( lline )
            # skip blank lines
            if re.match( '^\s*$', line ):
                continue
            # skip comment lines
            if re.match( '^\s*#.*', line ):
                continue

            # warn of possible illegal trailing comments
            if re.search( '#', line ):
                print 'WARNING: possible illegal trailing comment detected:'
                print '   --> ', line
                print "(OK if the '#' is part of a string or shell variable expansion)"

            # detect conditionals:
            m = re.match( '^\s*if HOUR in \s*([\d,]+)\s*:', lline )
            if m:
                #print '!   ', condition
                condition = m.groups()[0]
                parsed_def[ current_key ][ condition ] = []
                continue
        
            if re.match( '^%.*', line ):
                # new key identified
                condition = 'any'
                current_key = string.lstrip( line, '%' )
                parsed_def[ current_key ] = {}
                # always define an 'any' key
                parsed_def[ current_key ][ condition ] = []
                if current_key not in allowed_keys:
                    print 'ILLEGAL KEY ERROR: ' + current_key
                    sys.exit(1)
            else:
                if current_key == None:
                    # can this ever happen?
                    print "ERROR: no key identified"
                    sys.exit(1)
                # data associated with current key
                parsed_def[ current_key ][ condition ].append( line ) 
        # -----------------------------------------------DONE
        # print_parsed_info()

        family = False
        member_of = None
        if 'FAMILY' in parsed_def:
            family = True
            if 'TASK' in parsed_def:
                print "ERROR: choose %FAMILY or %TASK"
                sys.exit(1)

            family_members = []
            if 'MEMBERS' not in parsed_def:
                print "ERROR: task families need %MEMBERS"
                sys.exit(1)
            else:
                for member in get_parsed('MEMBERS'):
                    family_members.append( member )
        else:
            # not a task family, but is it a member of one?
            if 'MEMBER_OF' in parsed_def:
                member_of = get_parsed('MEMBER_OF')[0]

        inherit = False
        if 'INHERIT' in parsed_def:
            inherit = True
            inherit_from = get_parsed( 'INHERIT' )[0]

        outfile = os.path.join( taskdir, task_name )
        modname = re.sub( '.py', '', os.path.basename( outfile ))
        OUT = open( outfile, 'w' )

        OUT.write( preamble )
        if inherit:
            OUT.write( 'from class_' + inherit_from + ' import ' + inherit_from + '\n\n')

        if re.match( '^.*\.py$', task_def_file ):
            # this file is a python class definition
            for line in lines:
                OUT.write( line )

            OUT.write( '\n' )
            continue

        # intercycle (DEFAULT False)
        intercycle = False
        if 'INTERCYCLE' in parsed_def:
            intercycle = get_parsed( 'INTERCYCLE' )[0]
            if intercycle == 'True' or intercycle == 'true':
                intercycle = True

        delay = 0
        catchup_contact = False
        sequential = False
        contact = False
        oneoff = False
        dummy = False
        task_type = None

        if 'TYPE' not in parsed_def:
            if not inherit and not family:
                print "ERROR: no %TYPE specified"
                sys.exit(1)
        else:
            if family:
                print "ERROR: task families have no %TYPE spec"
                sys.exit(1)

            tmp = get_parsed( 'TYPE' )[0]
            typelist = tmp.split(',')

            task_type = typelist[0]
            if task_type not in allowed_types:
                print 'ERROR, unknown task class:', task_type
                sys.exit(1)

            if task_type == 'cycling_daemon':
                if 'OUTPUT_PATTERNS' not in parsed_def:
                    print 'ERROR, cycling daemon tasks must define OUTPUT_PATTERNS'
                    sys.exit(1)

            derived_from = task_type

            modifiers = typelist[1:]
            if len(modifiers) > 0:
                got_modifiers = True

                # strip white space
                modifiers = [ x.strip() for x in modifiers ]

                for modifier in modifiers:
                    if modifier not in allowed_modifiers:
                        print 'ERROR, unknown task modifier:', modifier
                        print allowed_modifiers
                        sys.exit(1)

                    if modifier == 'dummy':
                        dummy = True
                    elif modifier == 'sequential':
                        sequential = True
                    elif modifier == 'oneoff':
                        oneoff = True
                    elif modifier == 'contact':
                        contact = True
                    elif modifier == 'catchup_contact':
                        contact = True
                        catchup_contact = True

                # removed 'dummy' from modifiers; it is handled below by
                # simply replacing the external task, not class derivation.

                if 'dummy' in modifiers:
                    modifiers.remove( 'dummy' )

                # this assumes the order of modifiers does not matter.
                if len( modifiers ) >= 1:
                    derived_from = ','.join( modifiers ) + ', ' + derived_from

        external_tasks = []
        got_command = False
        if 'COMMAND' in parsed_def:
            got_command = True
            external_tasks = get_parsed( 'COMMAND' )
            if dummy:
                print "WARNING: COMMAND will be ignored due to the 'dummy' type modifier."

        got_scripting = False
        scripting = []
        if 'SCRIPTING' in parsed_def:
            if dummy:
                print "WARNING: SCRIPTING will be ignored due to the 'dummy' type modifier."
            else:
                got_scripting = True
                scripting = get_parsed( 'SCRIPTING' )
                if not got_command:
                    # if no command is supplied this is a scripting-only
                    # tasks, which should be auto-wrapped
                    print "SCRIPTING will be wrapped (no COMMAND defined)."
                    scripting.insert( 0, "cylc task-started || exit 1" )
                    scripting.insert( 0, 'set -e; trap \\\'cylc task-failed "error trapped"\\\' ERR' )
                    scripting.append( "cylc task-message --all-outputs-completed" )
                    scripting.append( "cylc task-finished" )
                    # currently a task command is still required
                    # (must not be empty string because of t[-1] below) 
                    external_tasks = [ ' ' ]

        if not got_command and not got_scripting:
            if family:
                pass
            elif inherit:
                print "WARNING: assuming COMMAND and/or SCRIPTING defined in the INHERITed task"
            elif dummy:
                pass
            else:
                print 'ERROR: you must supply COMMAND and/or SCRIPTING'
                sys.exit(1)

        if dummy:
            external_tasks = ['cylc-wrapper /bin/true']

        if family:
            # families do not use a task command
            external_tasks = [' ']

        follow_on = False
        if oneoff and intercycle:
            if 'FOLLOW_ON' not in parsed_def:
                print "ERROR: oneoff with intercycle dependants must define %FOLLOW_ON"
                sys.exit(1)
            else:
                follow_on = get_parsed('FOLLOW_ON')[0]

        task_init_def_args = 'c_time, initial_state, startup = False'
        task_inherit_super_args = 'c_time, initial_state, startup'
        task_init_args = 'initial_state'

        if contact:
            if 'CONTACT_DELAY' not in parsed_def:
                print "ERROR: contact classes must define %CONTACT_DELAY"
                sys.exit(1)

        if task_type == 'tied':
            if 'N_RESTART_OUTPUTS' not in parsed_def:
                print 'ERROR: tied tasks must define %N_RESTART_OUTPUTS'
                sys.exit(1)

        # task or family name
        if family:
            task_name = get_parsed( 'FAMILY' )[0]
            task_type = "family"
        else:
            task_name = get_parsed( 'TASK' )[0]

        # short name
        short_name = task_name

        m = re.search( '^\s*(.*),\s*(.*)\s*$', task_name )
        if m:
            # short name given as well
            [ task_name, short_name ] = m.groups()

        if re.search( ' ', task_name ):
            print 'ERROR: name contains spaces', task_name 
            print '(did you miss the comma between the full and short task names?)'
            sys.exit(1)

        if task_name in seen:
            print "ERROR: task name '" + task_name + "' has been defined already!"
            sys.exit(1)
        else:
            seen[ task_name ] = True

        # class definition
        if inherit:
            OUT.write( 'class ' + task_name + '(' + inherit_from + '):\n' )
        elif family:
            OUT.write( 'class ' + task_name + '( family ):\n' )
        else:
            OUT.write( 'class ' + task_name + '(' + derived_from + '):\n' )

        indent_more()
 
        OUT.write( indent + '# AUTO-GENERATED FROM ' + task_def_file + '\n\n' )  
   
        # task name
        OUT.write( indent + 'name = \'' + task_name + '\'\n' )
        OUT.write( indent + 'short_name = \'' + short_name + '\'\n' )

        OUT.write( indent + 'instance_count = 0\n\n' )

        # task description
        if 'DESCRIPTION' in parsed_def:
            OUT.write( indent + 'description = []\n' )
            for line in  get_parsed( 'DESCRIPTION' ):
                OUT.write( indent + 'description.append("' + escape_quotes(line) + '")\n' )
            OUT.write( '\n' )
        else:
            print "ERROR: no %DESCRIPTION provided for task " + task_name
            sys.exit(1)

        # owner
        owner = None
        if 'OWNER' in parsed_def:
            owner = get_parsed( 'OWNER' )[0]
            OUT.write( indent + 'owner = \'' + owner + '\'\n' )
        elif not inherit:
            OUT.write( indent + 'owner = None\n' )

        # remote host
        remote_host = None
        if 'REMOTE_HOST' in parsed_def:
            remote_host = get_parsed( 'REMOTE_HOST' )[0]
            OUT.write( indent + 'remote_host = \'' + remote_host + '\'\n\n' )
        else:
            OUT.write( indent + 'remote_host = None\n' )

        OUT.write( indent + 'job_submit_method = None\n' )

        if 'HOURS' not in parsed_def:
            # NOTE: THIS WILL NEED TO BE MODIFIED FOR ASYNC TASKS
            if not inherit:
                print "ERROR: no %HOURS provided for task " + task_name
                sys.exit(1)
            pass

        else:
            valid = get_parsed( 'HOURS' )[0]
            OUT.write( indent + 'valid_hours = [' + valid + ']\n\n' )

        if intercycle:
            OUT.write( indent + 'intercycle = ' + str(intercycle) + '\n\n' )

        if follow_on:
            OUT.write( indent + 'follow_on = "' + follow_on + '"\n\n' )

        # family members
        if family:
            OUT.write( indent + 'members = []\n' )
            for member in family_members:
                OUT.write( indent + 'members.append("' + member + '" )\n' )

        # member of a family?
        if member_of:
            OUT.write( indent + 'member_of = "' + member_of  + '" \n' )

        # class init function
        OUT.write( indent + 'def __init__( self, ' + task_init_def_args + ' ):\n\n' )

        indent_more()

        # cycle time
        if not inherit:
            OUT.write( indent + '# adjust cycle time to next valid for this task\n' )
            OUT.write( indent + 'self.c_time = self.nearest_c_time( c_time )\n' )
            OUT.write( indent + 'self.tag = self.c_time\n' )
            OUT.write( indent + 'self.id = self.name + \'%\' + self.c_time\n' )
            # FIXME ASYNC
            OUT.write( indent + 'hour = self.c_time[8:10]\n\n' )

        # external task
        OUT.write( indent + 'self.external_tasks = deque()\n' )

        # concatenate any commandlines ending in '\'
        newt = []
        cat = ''
        for t in external_tasks:
            if t[-1] == '\\':
                cat += t[0:-1]
                continue
            if cat != '':
                newt.append( cat + t )
                cat = ''
            else:
                newt.append( t )

        for task in newt:
            # interpolate $(CYCLE_TIME [+/-n]) 
            task = interpolate_cycle_times( task )
            OUT.write( indent + 'self.external_tasks.append( \'' + task + '\')\n' )

        if inherit:
            OUT.write( indent + 'super(' + task_name + ', self ).__init__(' + task_inherit_super_args + ' )\n\n' )

        #if contact:
        if 'CONTACT_DELAY' in parsed_def: 
            for line in parsed_def[ 'CONTACT_DELAY' ]['any']:
                delay = re.sub( '\s+$', '', line )
                OUT.write( indent + 'self.real_time_delay = ' + time_trans( delay, hours=True ) + '\n' )
            for condition in get_conditions( 'CONTACT_DELAY' ):
                hours = condition.split(',')
                for line in parsed_def[ 'CONTACT_DELAY' ][ condition ]:
                    delay = re.sub( '\s+$', '', line )
                    for hour in hours:
                        OUT.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        OUT.write( indent + 'self.real_time_delay = ' + time_trans( delay, hours=True ) + '\n' )
                        indent_less()
                    
            OUT.write( '\n' )

        # ... prerequisites
        write_reqs( 'PREREQUISITES', 'prerequisites', 'prerequisites' )

        if member_of:
            OUT.write( indent + "self.prerequisites.add( '" + member_of + "%' + self.c_time + ' started' )\n")

        # ... suicide prerequisites
        write_reqs( 'SUICIDE_PREREQUISITES', 'suicide_prerequisites', 'prerequisites' )

        # ... familyfinished prerequisites
        if family:
            OUT.write( indent + 'self.familyfinished_prerequisites = prerequisites( self.id )\n' )
            for member in family_members:
                OUT.write( indent + 'self.familyfinished_prerequisites.add( "' + member + '%" + self.c_time + " finished" )\n')
 
        OUT.write( indent + 'self.logfiles = logfiles()\n' )
        if 'LOGFILES' in parsed_def:
            for lfile in parsed_def[ 'LOGFILES' ]:
                OUT.write( indent + 'self.logfiles.add_path("' + lfile + '")\n' )

        # ... outputs
        write_reqs( 'OUTPUTS', 'outputs', 'outputs' )
     
        # forecast model restarts
        if task_type == 'tied' or ( inherit and 'N_RESTART_OUTPUTS' in parsed_def ):
            for line in parsed_def['N_RESTART_OUTPUTS']['any']:
                line = re.sub( '\s+$', '', line )
                n_restart_outputs = line
                OUT.write( indent + 'self.register_restart_requisites(' + n_restart_outputs +')\n' )

            for condition in get_conditions( 'N_RESTART_OUTPUTS' ):
                hours = condition.split(',')
                for line in parsed_def[ 'N_RESTART_OUTPUTS' ][ condition ]:
                    n_restart_outputs = re.sub( '\s+$', '', line )
                    for hour in hours:
                        OUT.write( indent + 'if int( hour ) == ' + hour + ':\n' )
                        indent_more()
                        OUT.write( indent + 'self.register_restart_requisites(' + n_restart_outputs + ')\n' )
                        indent_less()
 
        OUT.write( indent + 'self.outputs.register()\n\n' )

        # are the prerequisites different for the first instance?
        if 'COLDSTART_PREREQUISITES' in parsed_def:
            OUT.write( indent + "if startup:\n" )
            indent_more()
            OUT.write( indent + '# overwrite prerequisites for startup only\n' )
            write_reqs( 'COLDSTART_PREREQUISITES', 'prerequisites', 'prerequisites' )
            indent_less()
 
        # ... output patterns
        if not inherit:
            OUT.write( indent + 'self.output_patterns = []\n' )

        if 'OUTPUT_PATTERNS' in parsed_def:
            for line in get_parsed( 'OUTPUT_PATTERNS' ):
                 OUT.write( indent + 'self.output_patterns.append( ' + line + ')\n' )

        # environment variables
        if not inherit:
            OUT.write( '\n' + indent + 'self.env_vars = OrderedDict()\n' )

        OUT.write( indent + "self.env_vars['TASK_NAME'] = self.name\n" )
        OUT.write( indent + "self.env_vars['TASK_ID'] = self.id\n" )
        OUT.write( indent + "self.env_vars['CYCLE_TIME'] = self.c_time\n" )
       
        if 'ENVIRONMENT' in parsed_def:
            for pair in get_parsed( 'ENVIRONMENT' ):
                ( var, val ) = pair.split( ' ', 1 )
                var = "'" + var + "'"
                # interpolate $(CYCLE_TIME [+/-n]) 
                val = interpolate_cycle_times( "'" + val + "'" )
                OUT.write( indent + 'self.env_vars[' + var + '] = ' + val + '\n' )

        # batch queue scheduler directives (qsub or loadleveler)
        if not inherit:
            OUT.write( '\n' + indent + 'self.directives = {}\n' )

        if 'DIRECTIVES' in parsed_def:
            for pair in get_parsed( 'DIRECTIVES' ):
                ( var, val ) = pair.split( ' ', 1 )
                var = "'" + var + "'"
                # interpolate $(CYCLE_TIME [+/-n]) 
                val = interpolate_cycle_times( "'" + val + "'" )
                OUT.write( indent + 'self.directives[' + var + '] = ' + val + '\n' )


        if not inherit:
            OUT.write( '\n' + indent + 'self.extra_scripting = []\n' )

        if 'SCRIPTING' in parsed_def:
            for line in scripting:
                # cannot interpolate $(CYCLE_TIME+/-N) here because this
                # section is for shell scripting, not generated python.

                # interpolate $(CYCLE_TIME [+/-n]) 
                line = interpolate_cycle_times( "'" + line + "'" )
                #line = escape_quotes( line )
                OUT.write( indent + 'self.extra_scripting.append(' + line + ')\n' )
            OUT.write( '\n' )

        if not inherit:
            # call parent init methods
            # FOR PARENT CLASS TYPES THAT HAVE INIT METHODS!
            if catchup_contact:
                OUT.write( indent + 'catchup_contact.__init__( self )\n\n' )
 
            OUT.write( indent + task_type + '.__init__( self, ' + task_init_args + ' )\n\n' )

        indent_less()
        indent_less()

        OUT.close()
 
if __name__ == '__main__':
    main( sys.argv )

