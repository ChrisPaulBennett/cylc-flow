#!/bin/bashX        # THIS SCRIPT MUST BE SOURCED IN THE CALLING SHELL

# Implement a "locking directory" mechanism to prevent THIS TASK (or
# rather the task that SOURCES this script) from running if another
# instance of it is running already (and has already acquired the lock).
# Locking must be done by the external task script, not by cylc, so that 
# the lock will be released by external tasks when they finish even if
# cylc has been shut down. 

# This version acquires a lock to prevent multiple copies of the task
# from running REGARDLESS of their registered cylc system names. 

# See also 'cylc-task-lock-sys' for a system-specific lock, for tasks that
# can tolerate parallel instances running under different cylc systems.

# $TASK_ID is in the cylc execution environment.

# Original version by Chris Edsall @ NIWA.
# - Uses directory creation as mkdir is an atomic operation.
# - Sourcing (dot-run) allows us to auto-release the lock on exit.

# ATTEMPT TO ACQUIRE YOUR LOCK AFTER SENDING THE CYLC START MESSAGE
# so that failure to lock will be reported to the cylc task logs, as
# well as to stdout, without causing cylc to complain that it has
# received a message from a task that has not started running yet. 
# Similarly, the lock release message is only echoed to stdout
# because it is necessarily emitted after the task finished message.
# (a cylc message after that time will cause cylc to complain that it
# has received a message from a task that has finished running). 

if ! mkdir -p $HOME/running/locks; then
    cylc message -p CRITICAL "cannot create directory $HOME/running/locks"
    cylc message --failed
    exit 1
fi

LOCKDIR=$HOME/running/locks/$TASK_ID
if ! mkdir "$LOCKDIR"; then
    # this task is already locked
	cylc message -p CRITICAL "cannot acquire lock $LOCKDIR"
    cylc message --failed
    exit 1
else
	# we got it.
	cylc message "acquired lock $LOCKDIR"
	# remove lockdir when the script finishes, or when it receives a signal
	trap 'echo "releasing lock"; rm -rf "$LOCKDIR"' 0 
	trap "exit 2" 1 2 3 15         # terminate script when receiving signal
fi
