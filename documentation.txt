
=============== ECOCONNECT CONTROLLER WITH IMPLICIT SEQUENCING =============

"TASK": any set of processes that, as a group, we want separate scheduling
control over.  This includes, but is not restricted to, "a science model 
plus its post-processing".


---------- EcoConnect Model Sequencing ----------

The EcoConnect forecasting engine consists of a set of tasks that must be
executed in correct order as determined, mainly, by availability of input
files that are generated by other tasks.  In general a task may take input
from more than one upstream task, and may generate output for more than one
downstream task, which results in a somewhat complicated non-linear task
"sequence": branching (multiple outputs) parallel streams of execution that
sometimes merge (multiple inputs) back together.


---------- Explicit Sequencing ----------

This treats the actual sequence of tasks as fundamental: work out the correct
sequence in advance, taking into account all intertask dependencies, and write
a program to explicitly enforce it.  This is relatively easy to understand,
and is probably the most obvious method to try, but the resulting program will
inevitably(?) be fragile and inflexible with respect to insertion and deletion
of models, mid-cycle startup, maintenance, and extensibility, etc. 


---------- Implicit Sequencing ----------

This treats the prerequisites (e.g. input files) and postrequisites (e.g.
output files) of individual tasks as fundamental, and allows tasks to interact
in such a way that correct sequencing just emerges naturally at run time.  

Let each external task be represented by a TASK OBJECT inside the controller.
A task object has a list of task-specific prerequisites (e.g. "input file X
is ready") that have to be satisfied before the corresponding external task
can run, and a set of task-specific "postrequisites" (e.g. "output file Y is
complete") that will be completed by the task as it runs.  A task object can
launch its external task when all its prerequisites are satisfied, and
after that updates its internal state according to messages received from the
external task (e.g. notification of completed postrequisites). The Python
Remote Objects module (Pyro) allows
direct communication between an external task and the object that represents
it in the controller.
 Now we enable
the task objects to interact: each task can ask all the other tasks, "can you
satisfy any of my prequisites with your completed postrequisites?".
completed postrequisites can satisfy task A's  anyone's completed postrequisites can
satisfy its own prerequisites (tasks do not need to know in advance *who* will
satisfy their prerequisites).  
Here's another way of putting it, from an email: 

The important thing about the "object oriented controller" is that it only
knows about individual tasks and their prerequisites and outputs, without
reference to who supplies the inputs or who uses the outputs, i.e. there is no
sequencing logic at all.  Task objects "talk amongst themselves" to match
prerequisites and outputs so that correct sequencing just emerges naturally at
run time.  

Note that the pre- and post-requisites are just *messages* indicating that
some condition has been satisfied.  In the case of messages like "file foo is
complete", the controller does not need to check for the file's existence or
even know its location (so long as all the filenames are unique) because the
real tasks necessarily have to do that anyway, and can rely on our strict
EcoConnect input/output directory rules for file locations. 


---------- Task Management ----------

When to create and destroy tasks is to some degree arbitrary because correct
task sequencing (in the sense that no task will run before its prerequisites
are satisfied) will result no matter how many tasks are "in play" at once, so
long as all co-dependent tasks coexist, at any one time, so that they can
interact to match pre/post-requisites. However, I have decided on the
following scheme, which achieves our needs without undue complexity: 

TASK ZERO: 
This task (the "downloader"!) is special in that it provides the initial input
to get the whole system started. It must be able to start running immediately,
i.e. have no prerequisites (except that previous instances of itself must be
finished) or else nothing will run at all. The downloader's external task
should watch for incoming files for cycle T and report back ready when the
download has completed OR if the files already exist because they were
downloaded previously.

INTER-CYCLE DEPENDENCIES:
Having each task foo(T) depend explicitly on its previous instance foo(T-1)
finishing prevents successive instances of the same task from running
simultaneously, or out of order, but it complicates system startup (there
are no previous tasks at this time) and means finished tasks have to stay
around longer (so that foo(T-1) can tell foo(T) it is finished). 

Instead we can do this: a task can start "running" only if (a) no previous
instance of itself exists, OR (b) any previous instance of itself that still
exists is in a "finished" state.  This prevents running out of order but
system startup is no longer a special case, and tasks can die as soon as all
of their same-cycle peers are finished.

CYCLE OVERLAP:
The usefulness of cycle overlap depends on the assumption that the first M
tasks in a cycle run on a different machine (kupe) and take longer to execute
than the remaining N tasks. Therefore M(T+1;kupe) can run at the same time
as N(T;pa) without delaying completion of N(T;pa) by resource contention. 

Let each task know if it runs on kupe, then the new T+1 cycle can start IF:
  (a) all tasks(T) have finished,
    OR
  (b) (i) all kupe tasks have finished for T
        AND 
      (ii) at least one kupe task is configured for T+1.

Note that without b_ii a task foo(T+1) would compete with remaining tasks(T)
as soon as foo(T) is finished.

TASK CREATION:
The task manager creates a complete new BATCH of tasks(T) as soon as allowed
by the above cycle overlap conditions.  Batch(T) creation, as opposed to e.g.
creating each new foo(T) as soon as foo(T-1) is finished, is convenient from a
config file and system restart perspective, and it prevents tasks with no
prerequisites (nztide) from running off ahead without having to impose any
"artificial prerequisites" such as "nztide(T) depends on nzlam(T)". 

TASK DELETION:
Thanks to the way we're handling intercycle dependencies, above, the task
manager can delete foo(T) when all tasks(T) are finished.
