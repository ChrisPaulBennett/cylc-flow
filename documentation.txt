
=============== ECOCONNECT CONTROLLER WITH IMPLICIT SEQUENCING =============

"TASK": any set of processes that, as a group, we want separate scheduling
control over.  This includes, but is not restricted to, "a science model 
plus its post-processing".


---------- EcoConnect Model Sequencing ----------

The EcoConnect forecasting engine consists of a set of tasks that must be
executed in correct order as determined, mainly, by availability of input
files that are generated by other tasks.  In general a task may take input
from more than one upstream task, and may generate output for more than one
downstream task, which results in a somewhat complicated non-linear task
"sequence": branching (multiple outputs) parallel streams of execution that
sometimes merge (multiple inputs) back together.


---------- Explicit Sequencing ----------

This treats the actual sequence of tasks as fundamental: work out the correct
sequence in advance, taking into account all intertask dependencies, and write
a program to explicitly enforce it.  This is relatively easy to understand,
and is probably the most obvious method to try, but the resulting program will
inevitably(?) be fragile and inflexible with respect to insertion and deletion
of models, mid-cycle startup, maintenance, and extensibility, etc. 


---------- Implicit Sequencing ----------

This treats the prerequisites (e.g. input files) and postrequisites (e.g.
output files) of individual tasks as fundamental, and allows tasks to interact
in such a way that correct sequencing just emerges naturally at run time.  

Each external task is represented by a TASK OBJECT inside the controller.
A task object has a list of task-specific prerequisites (e.g. "input file X is
ready") that have to be satisfied before the corresponding external task can
run, and a set of task-specific "postrequisites" (e.g. "output file Y is
complete") that will be completed by the task as it runs.  The external task
can be launched when all its prerequisites are satisfied, after which the 
task object updates its internal state according to messages received from the
external task (e.g. notification of completed postrequisites). The Python
Remote Objects module (Pyro) allows direct communication between an external
task and the object that represents it in the controller.  We now let the
task objects interact: each task can ask all the other tasks, "can you
satisfy any of my prequisites with your completed postrequisites?".  Note
that tasks do not need to know in advance *who* will satisfy their
prerequisites.  The control system only knows about individual tasks and their
prerequisites and outputs, without reference to who supplies the inputs or who
uses the outputs, i.e. there is no sequencing logic at all.  Task objects
"talk amongst themselves" to match prerequisites and outputs so that correct
sequencing emerges naturally at run time.  

Note that the pre- and post-requisites are just *messages* indicating that
some condition has been satisfied.  In the case of messages like "file foo is
complete", the controller does not need to check for the file's existence or
even know its location (so long as all the filenames are unique) because the
real tasks necessarily have to do that anyway, and can rely on our strict
EcoConnect input/output directory rules for file locations. 


---------- Task Management ----------

Correct TASK SEQUENCING, in the sense that no task will run before its
prerequisites are satisfied, will occur regardless how many tasks are in play
at once.  However, tasks creation and deletion must be managed to ensure that
task objects exist by the time they are needed, but don't clutter the system
with too many tasks that aren't needed yet or are already spent (this makes
system monitoring difficult and, in extreme cases, may slow down task
interaction).  

Note that delayed task creation, in addition to prerequisites, can be used as
a means of delaying task execution.

Note that during CATCHUP "correct model sequencing" is not equivalent to
"orderly generation of products by reference time".  E.g. nzlam can run
continuously, regardless of the downstream processing that depends on it.


TASK ZERO: 

This task (the "downloader") is special in that it provides the initial input
to get the whole system started. It must be able to start running immediately,
i.e. have no prerequisites (except that previous instances of itself must be
finished) or else nothing will run at all. The downloader's external task
should watch for the right incoming files and report back ready when the
download has completed OR if the files already exist because they were
downloaded previously.

INTER-CYCLE DEPENDENCIES:

Having each task foo(T) depend explicitly on its previous instance foo(T-1)
finishing prevents successive instances of the same task from running
simultaneously, or out of order, but it complicates system startup (there
are no previous tasks at this time) and means finished tasks have to stay
around longer (so that foo(T-1) can tell foo(T) it is finished). 

Instead we can let a task start "running" only if no previous instance of it
exist, OR any previous instance that still exists is in a "finished" state.
This prevents running out of order but system startup is no longer a special
case, and tasks can die as soon as all of their same-cycle peers are finished
(this task death criterion has since been modified to allow for topnet
runahead, below).

TASK CREATION:

The task manager creates a complete new BATCH of tasks(T) as soon as allowed
by the above cycle overlap conditions.  Batch(T) creation, as opposed to e.g.
creating each new foo(T) as soon as foo(T-1) is finished, is convenient from a
config file and system restart perspective, and it prevents tasks with no
prerequisites (nztide) from running off ahead without having to impose any
"artificial prerequisites" such as "nztide(T) depends on nzlam(T)". 

TASK DELETION:

Thanks to the way we're handling intercycle dependencies, above, the task
manager can delete foo(T) when all tasks(T) are finished.


POINTS TO PONDER...

Note that managing task creation is equivalent to imposing an artificial
prerequisite: "the task can not start running prior to [task creation
time]".  Batch managing task creation as above, however, has the
additional advantage that a minimum of tasks at a time are "waiting",
which makes sytem monitoring simpler.  Aside from simple monitoring
though, the only reason to do this is to ensure orderly(T) product
generation during catchup.

 * note there is no distinction between "catchup" and "real time" modes,
   it's just that in catchup there is no delay between cycles because
   the downloader returns immediately.

 * can we rely on nqs to ensure orderly product generation in "true
   multiflight" mode?  NO: I think nqs orders according to job
   submission order(?): foo(T+1) can be qsubbed as soon as foo(T) is
   finished, in general, and this can be before bar(T) is finished.  
   

=========== runahead ===== 

For this we must either:
 (i) radically (?) change the task management scheme 
 (ii) process topnet separately from the other tasks. 
 (iii) as for (ii) but outside of the controller entirely

(ii) or (iii) are reasonable because runahead topnet is only loosely
dependent on nzlam, and has no downstream dependents (except its own
postprocessing). 

In case (ii) I envisage a new topnet hourly task created outside the
main task pool each time the previous one finishes, and interacting with
nzlam only via a task manager "most recent completed nzlam run"
attribute.

 * system drivability: config files and restart, etc.?

 * runahead topnet necessarily creates non-topnet product delays in real
   time, not just catchup, due to resource contention (a problem when we
   do many basins?). Can we just 'nice' topnet down in priority?

 * runahead will screw up multiple-datatype products, depending on 
   mintaka display capabilities.  E.g. image runahead nztide on seagrams
   (but doesn't affect river products?)?

 * during catchup, topnet will always run off as far ahead as allowed, 
   which implies a long sequence of very short forecasts driven by worst
   possible nwp fields. => must turn off run-ahead in catchup mode? 
   But, how to identify if we've caught up or not -- delayed return by
   downloader? 
  
