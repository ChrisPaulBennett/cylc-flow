
=============== ECOCONNECT CONTROLLER WITH IMPLICIT SEQUENCING =============

DEFINITION of "TASK": any set of processes that, as a group, we want separate
scheduling control over.  This includes, but is not restricted to, "single
science model plus its post-processing jobs".


---------- EcoConnect Model Sequencing ----------

The EcoConnect forecasting engine consists of a set of tasks that must be
executed in correct order as determined, mainly, by availability of input
files that are generated by other tasks.  In general a task may take input
from more than one upstream task, and may generate output for more than one
downstream task, which results in a somewhat complicated non-linear task
"sequence": branching (multiple outputs) parallel streams of execution that
sometimes merge (multiple inputs) back together.


---------- Explicit Sequencing ----------

This is the usual approach: write a program to explicitly enforce the correct
non-linear "sequence", which has been figured out in in advance by taking into
account all intertask dependencies in the system.  It is relatively easy to
understand, but the resulting program will inevitably(?) be fragile and
inflexible with respect to insertion and deletion of models, mid-cycle
startup, maintenance and extensibility, etc. 


---------- Implicit Sequencing ----------

The non-linear task sequence can be seen as a property of the system that
emerges naturally through the interaction of simple "task objects" which only
know their own attributes, rather than a fundamental property of the whole
system that has to be figured out in advance and then rigorously enforced. 

Let each EcoConnect task be represented by a TASK OBJECT, which has a set of
task-specific prerequisites (e.g. "input file X is ready") that have to be
satisfied before the external task can run, and a set of task-specific
"postrequisites" (e.g. "output file Y is complete") that will be completed by
the task as it runs. Also, a task knows how to communicate with other tasks
to find out anyone else's completed postrequisites can satisfy its own
prerequisites (note that a task doesn't need to know in advance *who* will
satisfy its prerequisites).  Finally, a task can launch its external task
when all its prerequisites are satisfied, and thereafter updates its internal
state according to messages received from the external task (e.g.
notification of completed postrequisites). task object <-> real task network
communication is achieved with Python Remote Objects (Pyro). 

Another description, taken from an explanatory email:

...the important thing about the "object oriented controller" is that it only
knows about individual tasks and their prerequisites and outputs, without
reference to who supplies the inputs or who uses the outputs, i.e. there is no
sequencing logic at all.  Task objects "talk amongst themselves" to match
prerequisites and outputs so that correct sequencing just emerges naturally at
run time.  What could be simpler than that?  This is an absolutely minimal
treatment of the problem, it is maximally flexible with respect to addition
and subtraction of models, mid-cycle startup, etc., and it is easy to
implement

Note that the pre- and post-requisites are just *messages* indicating that
some condition has been satisfied.  In the case of messages like "file foo is
complete", the controller does not need to check for the file's existence or
even know its location (so long as all the filenames are unique) because the
real tasks necessarily have to do that anyway, and can rely on our strict
EcoConnect input/output directory rules for file locations. 


---------- Task Management ----------

When to create and destroy tasks is to some degree arbitrary because correct
task sequencing (in the sense that no task will run before its prerequisites
are satisfied) will result no matter how many tasks are "in play" at once, so
long as all co-dependent tasks coexist, at any one time, so that they can
interact to match pre/post-requisites. 

A single reference time batching scheme is probably the easiest method to
understand and implement: 

 * Create a single batch of tasks(T) for the initial reference time T
 * Let the tasks(T) interact until all reach the finished state
 * Increment the reference time, create tasks(T+1), and destroy tasks(T)

Advantages:
 * simplicity
 * concept of "current reference time" is retained
 * no explicit intercycle dependencies or artificial prerequisites required
   because multiple cycles never overlap

=====================================

Cycle Overlap

The basic management scheme above doesn't allow successive cycles to overlap,
which would provide faster throughput in catchup mode (where the initial input
files already exist for multiple cycles).  The wave and nwp models run on kupe
and take longer than all the downstream runs and postprocessing on pa, so we
could in principle start the T+1 cycle on kupe before processing on pa
(for T) has completed.  

There are various ways in which we could change task management to allow
cycle overlap.  For example, we could create all tasks(T+1) as soon as
nzwave(T) has finished on kupe, or create each foo(T+1) individually as
soon as its predecessor foo(T) is finished, or even create multiple cycle's
worth of tasks all at once.  However, doing any of this would require careful
consideration of any complications, for example:
  * do we need to ensure that no T+1 processing occurs on pa before
    all T processing has finished there, so that no T products are delayed?
  * how to easily restart the controller if several different cyles were
    partially complete when the system went down?
  
Note that explicit intercycle dependencies might be needed (i.e. foo(T+1) waits
on foo(T)), and "artificial prequisites" can be used to prevent
prerequisiteless tasks like nztide running ahead of everything else (e.g. make
nztide(T) depend on nzlam(T) or similar).


Poor Man's Overlap?

We could create new tasks(T+1) as soon as all tasks(T) prerequisites are
satisfied, rather than waiting until all tasks(T) are finished.  This would
allow some cycle overlap (but as above, we may want to avoid having any new
tasks delay completion of the old cycle).
 
=====================================
Downloader External Task 

Must be reference time specific: downloader(T) only watches for incoming T files,
and reports ready if the download has *completed* OR if the file already
exists (i.e. was downloaded some time ago).

