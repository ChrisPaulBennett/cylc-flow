
=============== MULTIFLIGHT CONTROLLER WITH IMPLICIT SEQUENCING =============

DEFINITION of "TASK": any set of processes that, as a group, we want separate
scheduling control over.  This includes, but is not restricted to, "single
science model plus its post-processing jobs".


---------- EcoConnect Model Sequencing ----------

The EcoConnect forecasting engine consists of a set of tasks that must be
executed in correct order as determined, mainly, by availability of input
files that are generated by other tasks.  In general a task may take input
from more than one upstream task, and may generate output for more than one
downstream task, which results in a somewhat complicated non-linear task
"sequence": branching (multiple outputs) parallel streams of execution that
sometimes merge (multiple inputs) back together.


---------- Explicit Sequencing ----------

Writing code to explicitly enforce the correct non-linear "sequence" is the
the obvious way to do this, but the resulting program will inevitably(?) be
fragile and inflexible with respect to insertion and deletion of models,
mid-cycle startup, maintenance and extensibility, etc. 


---------- Implicit Sequencing ----------

Snooker Analogy (this is how the idea originally occurred to me)

The traditional explicit sequencing approach, above, is somewhat analagous to
programming a snooker game by calculating in advance the individual
trajectories of all balls as they respond to particular initial conditions,
and then writing code to explicitly enforce the known trajectories. This is
difficult to program, and very inflexible (imagine adding or removing balls,
or adjusting initial conditions).  Object oriented design, on the other hand,
is very well suited to this kind of problem: write a "ball" class to define
the attributes and behavior of generic "ball" objects: a ball knows its own
position and velocity, how interrogate other balls as to their position and
velocity, how to adjust its velocity according to collision physics if any
overlap is found, and how to update its position given its current velocity.
Now simply instantiate as many balls as you like and let them interact: the
correct trajectories emerge naturally at run time.  This approach is simple to
program, and ridiculously flexible.


Task Sequencing

Like the ball trajectories, our task sequence can be seen as a property of the
system that emerges naturally through the interaction of simple "task objects"
that only know their own attributes, rather than a fundamental property of the
system that has to been known in advance and thence enforced. 

Let each EcoConnect task be represented by a VTASK (Virtual Task) object,
which has a set of task-specific prerequisites (e.g. "input file X is ready")
that have to be satisfied before the external task can run, and a set of
task-specific "postrequisites" (e.g. "output file Y is complete") that will be
completed by the task as it runs. Also, a vtask knows how to communicate with
other vtasks to find out anyone else's completed postrequisites can satisfy
its own prerequisites (note that a vtask doesn't need to know in advance *who*
will satisfy its prerequisites).  Finally, a vtask can launch its external
task when all its prerequisites are satisfied, and thereafter updates its
internal state according to messages received from the external task (e.g.
notification of completed postrequisites). Vtask <-> task network
communication is achieved with Python Remote Objects (Pyro). 

Another description, taken from an explanatory email:

...the important thing about the "object oriented controller" is that it only
knows about individual tasks and their prerequisites and outputs, without
reference to who supplies the inputs or who uses the outputs, i.e. there is no
sequencing logic at all.  Task objects "talk amongst themselves" to match
prerequisites and outputs so that correct sequencing just emerges naturally at
run time.  What could be simpler than that?  This is an absolutely minimal
treatment of the problem, it is maximally flexible with respect to addition
and subtraction of models, mid-cycle startup, etc., and it is easy to
implement

Note that the pre- and post-requisites are just *messages* indicating that
some condition has been satisfied.  In the case of messages like "file foo is
complete", the controller does not need to check for the file's existence or
even know its location (so long as all the filenames are unique) because the
real tasks necessarily have to do that anyway, and can rely on our strict
EcoConnect input/output directory rules for file locations. 


---------- Vtask Management ----------

When to create and destroy vtasks is to some degree arbitrary because correct
task sequencing (in the sense that no task will run before its prerequisites
are satisfied) will result no matter how many vtasks are "in play" at once, so
long as all co-dependent vtasks coexist, at any one time, so that they can
interact to match pre/post-requisites. 

A single reference time batching scheme is probably the easiest method to
understand and implement: 

 * Create a single batch of vtasks(T) for the initial reference time T
 * Let the vtasks(T) interact until all reach the finished state
 * Increment the reference time, create vtasks(T+1), and destroy vtasks(T)

Advantages:
 * simplicity
 * concept of "current reference time" is retained
 * no explicit intercycle dependencies or artificial prerequisites required
   because multiple cycles never overlap

=====================================

Cycle Overlap

The basic management scheme above doesn't allow successive cycles to overlap,
which would provide faster throughput in catchup mode (where the initial input
files already exist for multiple cycles).  The wave and nwp models run on kupe
and take longer than all the downstream runs and postprocessing on pa, so we
could in principle start the T+1 cycle on kupe before processing on pa
(for T) has completed.  

There are various ways in which we could change vtask management to allow
cycle overlap.  For example, we could create all vtasks(T+1) as soon as
nzwave(T) has finished on kupe, or create each foo(T+1) individually as
soon as its predecessor foo(T) is finished, or even create multiple cycle's
worth of vtasks all at once.  However, doing any of this would require careful
consideration of any complications, for example:
  * do we need to ensure that no T+1 processing occurs on pa before
    all T processing has finished there, so that no T products are delayed?
  * how to easily restart the controller if several different cyles were
    partially complete when the system went down?
  
Note that explicit intercycle dependencies might be needed (i.e. foo(T+1) waits
on foo(T)), and "artificial prequisites" can be used to prevent
prerequisiteless tasks like nztide running ahead of everything else (e.g. make
nztide(T) depend on nzlam(T) or similar).


Poor Man's Overlap?

We could create new vtasks(T+1) as soon as all vtasks(T) prerequisites are
satisfied, rather than waiting until all vtasks(T) are finished.  This would
allow some cycle overlap (but as above, we may want to avoid having any new
tasks delay completion of the old cycle).
 
=====================================
Downloader External Task 

Must be reference time specific: downloader(T) only watches for incoming T files,
and reports ready if the download has *completed* OR if the file already
exists (i.e. was downloaded some time ago).


=====================================

Startup config file example?:

2008060818: nzlam12, ricom        # start here, nzlam12 and ricom only 

2008061000:                # transition to all tasks (default) here

2008071000: STOP           # end here
