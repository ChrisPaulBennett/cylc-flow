
=============== ECOCONNECT CONTROLLER WITH IMPLICIT SEQUENCING =============

"TASK": any set of processes that, as a group, we want separate scheduling
control over.  This includes, but is not restricted to, "a science model 
plus its post-processing".


---------- EcoConnect Model Sequencing ----------

The EcoConnect forecasting engine consists of a set of tasks that must be
executed in correct order as determined, mainly, by availability of input
files that are generated by other tasks.  In general a task may take input
from more than one upstream task, and may generate output for more than one
downstream task, which results in a somewhat complicated non-linear task
"sequence": branching (multiple outputs) parallel streams of execution that
sometimes merge (multiple inputs) back together.


---------- Explicit Sequencing ----------

This treats the actual sequence of tasks as fundamental: work out the correct
sequence in advance, taking into account all intertask dependencies, and write
a program to explicitly enforce it.  This is relatively easy to understand,
and is probably the most obvious method to try, but the resulting program will
inevitably(?) be fragile and inflexible with respect to insertion and deletion
of models, mid-cycle startup, maintenance, and extensibility, etc. 


---------- Implicit Sequencing ----------

This treats the prerequisites (e.g. input files) and postrequisites (e.g.
output files) of individual tasks as fundamental, and allows tasks to interact
in such a way that correct sequencing just emerges naturally at run time.  

Let each external task be represented by a TASK OBJECT inside the controller.
A task object has a list of task-specific prerequisites (e.g. "input file X
is ready") that have to be satisfied before the corresponding external task
can run, and a set of task-specific "postrequisites" (e.g. "output file Y is
complete") that will be completed by the task as it runs.  A task object can
launch its external task when all its prerequisites are satisfied, and
after that updates its internal state according to messages received from the
external task (e.g. notification of completed postrequisites). The Python
Remote Objects module (Pyro) allows
direct communication between an external task and the object that represents
it in the controller.
 Now we enable
the task objects to interact: each task can ask all the other tasks, "can you
satisfy any of my prequisites with your completed postrequisites?".
completed postrequisites can satisfy task A's  anyone's completed postrequisites can
satisfy its own prerequisites (tasks do not need to know in advance *who* will
satisfy their prerequisites).  
Here's another way of putting it, from an email: 

The important thing about the "object oriented controller" is that it only
knows about individual tasks and their prerequisites and outputs, without
reference to who supplies the inputs or who uses the outputs, i.e. there is no
sequencing logic at all.  Task objects "talk amongst themselves" to match
prerequisites and outputs so that correct sequencing just emerges naturally at
run time.  

Note that the pre- and post-requisites are just *messages* indicating that
some condition has been satisfied.  In the case of messages like "file foo is
complete", the controller does not need to check for the file's existence or
even know its location (so long as all the filenames are unique) because the
real tasks necessarily have to do that anyway, and can rely on our strict
EcoConnect input/output directory rules for file locations. 


---------- Task Management ----------

When to create and destroy tasks is to some degree arbitrary because correct
task sequencing (in the sense that no task will run before its prerequisites
are satisfied) will result no matter how many tasks are "in play" at once, so
long as all co-dependent tasks coexist, at any one time, so that they can
interact to match pre/post-requisites. However, we have decided on the
following scheme, which achieves our needs without undue complexity: 

TASK ZERO:
This task (the "downloader"!) is special in that it provides the initial
input to get the whole system started: it must be able to start running
immediately (i.e. have no prerequisites, except that previous instances
of itself must be finished), or else nothing will start.  
(the downloader's external task should watche for incoming for cycle T and
reports back ready if the download has completed OR if the files already exist
because they were downloaded some time ago).

INTER-CYCLE DEPENDENCIES:
Having each task foo(T) depend explicitly on its previous instance
foo(T-1) finishing prevents successive instances of the same task from
running simultaneously, or out of order, but it complicates system
startup (when there are no previous tasks) and means finished tasks have
to stay around longer (so that foo(T-1) can tell foo(T) it is finished). 

Instead we can do this: No task can start "running" IF any previous
instance of itself still exists that isn't in a "finished" state (i.e. a
task can start if a previous "finished" instance exists, or if no
previous instance exists).  This prevents running out of order, but
system startup is no longer a special case, and tasks can die as soon as
all of their same-cycle peers are finished.

CYCLE OVERLAP:
Define a specific prerequisite P_o which, when satisfied, determines
when the next cycle can start up if it is able: e.g. "nzwave finished
on kupe" (i.e. this determines the amount of overlap between cycles).

TASK CREATION:
The task manager creates a complete new BATCH of tasks(T) as soon as overlap
time is reached (i.e. P_o is satisfied).  T-based batch creation, as opposed
to e.g. creating a new foo(T) as soon as foo(T-1) is finished, is convenient
from a config file and system restart perspective, and it prevents tasks with
no prerequisites (nztide) from running off ahead without having to impose any
"artificial prerequisites" (e.g. making nztide(T) depend on nzlam(T)). 

TASK DELETION:
Thanks to the way we're handling intercycle dependencies, above, the
task manager can delete foo(T) when all tasks(T) are finished.



