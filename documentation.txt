
=============== ECOCONNECT CONTROLLER WITH IMPLICIT SEQUENCING =============

"TASK": any set of processes that, as a group, we want separate scheduling
control over.  This includes, but is not restricted to, "a science model 
plus its post-processing".


---------- EcoConnect Model Sequencing ----------

The EcoConnect forecasting engine consists of a set of tasks that must be
executed in correct order as determined, mainly, by availability of input
files that are generated by other tasks.  In general a task may take input
from more than one upstream task, and may generate output for more than one
downstream task, which results in a somewhat complicated non-linear task
"sequence": branching (multiple outputs) parallel streams of execution that
sometimes merge (multiple inputs) back together.


---------- Explicit Sequencing ----------

This treats the actual sequence of tasks as fundamental: work out the correct
sequence in advance, taking into account all intertask dependencies, and write
a program to explicitly enforce it.  This is relatively easy to understand,
and is probably the most obvious method to try, but the resulting program will
inevitably(?) be fragile and inflexible with respect to insertion and deletion
of models, mid-cycle startup, maintenance, and extensibility, etc. 


---------- Implicit Sequencing ----------

This treats the prerequisites (e.g. input files) and postrequisites (e.g.
output files) of individual tasks as fundamental, and allows tasks to interact
in such a way that correct sequencing just emerges naturally at run time.  

Each external task is represented by a TASK OBJECT inside the controller.
A task object has a list of task-specific prerequisites (e.g. "input file X is
ready") that have to be satisfied before the corresponding external task can
run, and a set of task-specific "postrequisites" (e.g. "output file Y is
complete") that will be completed by the task as it runs.  The external task
can be launched when all its prerequisites are satisfied, after which the 
task object updates its internal state according to messages received from the
external task (e.g. notification of completed postrequisites). The Python
Remote Objects module (Pyro) allows direct communication between an external
task and the object that represents it in the controller.  We now let the
task objects interact: each task can ask all the other tasks, "can you
satisfy any of my prequisites with your completed postrequisites?".  Note
that tasks do not need to know in advance *who* will satisfy their
prerequisites.  The control system only knows about individual tasks and their
prerequisites and outputs, without reference to who supplies the inputs or who
uses the outputs, i.e. there is no sequencing logic at all.  Task objects
"talk amongst themselves" to match prerequisites and outputs so that correct
sequencing emerges naturally at run time.  

Note that the pre- and post-requisites are just *messages* indicating that
some condition has been satisfied.  In the case of messages like "file foo is
complete", the controller does not need to check for the file's existence or
even know its location (so long as all the filenames are unique) because the
real tasks necessarily have to do that anyway, and can rely on our strict
EcoConnect input/output directory rules for file locations. 


---------- Task Management ----------

Correct TASK SEQUENCING, in the sense that no task will run before its
prerequisites are satisfied, will occur regardless of how many tasks are in
play at once.  However, task creation and deletion must be managed to ensure
that tasks exist by the time they are needed but don't exist for too long
before they are needed or after they are finished, which would make system
monitoring difficult and, in extreme cases, could slow down task interaction.  

We can control when a task executes by:
 (i) real prerequisites
 (ii) artificial prerequisites (e.g. make nztide depend on nzlam)
 (iii) delayed task creation.

Note that during CATCHUP "correct model sequencing" is not equivalent to
"orderly generation of products by reference time".  E.g. nzlam can run
continuously, regardless of the downstream processing that depends on it.


TASK ZERO: 

This task (the "downloader") is special in that it provides the initial input
to get the whole system started. It has no prerequisites and therefore starts
running as soon as it is created (so long as all previous instances have
finished; see below). Without this task nothing will run at all. The external
downloader (interface to watch_ftp.sh) should watch for the right incoming
files and report back ready when the download has completed OR if the files
already exist because they were downloaded previously.

INTER-CYCLE DEPENDENCIES:

Having each task foo(T) depend explicitly on its previous instance foo(T-1)
finishing prevents successive instances of the same task from running
simultaneously or out of order (where their other prerequisites would allow
this; e.g. downloader or nztide) but it complicates system startup (when there
are no previous tasks) and means finished tasks have to stay around
longer (so that foo(T-1) can tell foo(T) it is finished). 

Instead, we let a task run if no previous instance exists OR any previous
instance that still exists is finished.  This prevents running out of order
but system startup is no longer a special case, and tasks can die as soon as
all of their same-cycle peers are finished (this task death criterion has
since been modified to allow for topnet runahead, below).

TASK CREATION:

Task creation is determined by task-specific abdication: when foo(T) is
finished, we create foo(T+1).  Note that this means we can't start up on a
single reference time: not all tasks are valid at all times, and any task not
present at the start will never be created. So, at start time each configured
task is created at the initial start time OR at the first subsequent reference
time for which it is valid.  

TASK DELETION:

Normal tasks can only run once all previous instances are finished, so there
is no explicit dependence on previous cycles and we can delete any completely
finished batch(T) that is older than the oldest running task.

HOWEVER, topnet can run ahead of nzlampost so long as the "most recently
generated topnet input file" is < 24 hours old (real time) or < 12 hours old
(catchup).  Nzlampost only generates topnet files at 06 and 18, so: if there
is no running nzlampost, topnet will depend on the most recent FINISHED 06 or
18 nzlampost, and we can delete any finished batches older than that. 

=> cutoff at the older of:
   (i) most-recent-finished-nzlampost
   (ii) oldest running.

TO DO: we could improve this by removing non-nzlampost tasks older than
oldest_running (BUT: make sure this doesn't break the dead soldier test).

DEAD SOLDIERS:

A "dead soldier" is a task that will never run because it's prerequisites can
never be satisfied.  These need to be removed or they will prevent removal of
spent tasks.  We can detect dead soldiers by requisite checking amongst all
tasks in the oldest batch(T) that contains any running tasks.  Newer batches
may not be complete yet (they may acquire new tasks as those in the oldest
batch abdicate).  Dead soldiers are abdicated rather than just deleted, so
that their descendents can run if they are not dead soldiers. As an example of
this, if we start the system at 12Z all topnet tasks prior to 18Z will be dead
soldiers because the 12Z nzlam does not generate topnet input files. 


CLEAN SHUTDOWN

Run the script 'shutdown.py' to tell the controller to shutdown cleanly
at the next opportunity.


STATE DUMP

The controller records its current state, i.e. the state of all
tasks that currently exist, to a file. 

Currently we can't restart from the state file.


DUMMY MODE

In dummy mode an external dummy program (see task_dummy.py) is launched by
each task instead of the real external model/task.  The external dummy program
then tells its in-controller task object that it has satisfied each of its
postrequisites in turn.

An accelerated clock (which runs at 60 seconds per dummy hour, by default) is
used for dummy task timing and replaces the real time in all log messages.
The user can specify a time offset, relative to the start reference time, at
which to start the dummy time clock. Dummy programs complete in the same time
(relative to the dummy clock rate) as the real models, so long as accurate
time estimates have been defined. 

If the task definitions (i.e. requisites and their respective time estimates)
are accurate, this enables complete testing of the control system, including
catchup and uptodate running and the transition between, except to the extent
that real external task timing is modified by resource contention.
