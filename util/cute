#!/usr/bin/env python


import os
import sys

try:
    import subprocess
    use_subprocess = True
except:
    use_subprocess = False
    print "+++++++++++++++++++++++++++++++++++++++++++++++"
    print "WARNING: UNABLE TO IMPORT THE SUBPROCESS MODULE"
    pyver = sys.version_info
    if pyver < (2, 4):
        print "  (subprocess was introduced in Python 2.4)"
    print "Cylc will use os.system to invoke subprocesses,"
    print "but it cannot check for successful invocation."
    print "+++++++++++++++++++++++++++++++++++++++++++++++"
    print

# auto-replace with version tag at build/install:
cylc_version = "THIS IS NOT A VERSIONED RELEASE"

allowed_commands = \
    [ 
    'help',
    'cycletime',
    'checkvars',
    'template',
    'housekeeping',
    'file-transfer',
    'rolling-archive',
    ]

usage = \
    [ 
    'USAGE: cute [options] COMMAND [command-options] ',
    '',
    'The cylc utility commands, for use in cylc suites.',
    '',
    'options:',
    ' -v, --version  Print the cylc release version tag and exit.',
    ' -h, --help     Print this usage message and exit.',
    '',
    'command-options:',
    '  cute COMMAND --help',
    '',
    'COMMANDS:',
    '  cycletime .......... Cycle time arithmetic',
    '  checkvars .......... Check required environment variables',
    '  template ........... Cycle time based filename templating',
    '  housekeeping ....... General archiving and cleanup tool',
    '  file-transfer ...... General scp-based file transfer tool',
    '  help ............... Print this message and exit; also [-h], [--help]',
    '  rolling-archive .... (deprecated: use housekeeping)',
    ]

def print_usage():
    for line in usage:
        print line

# check that the cylc core modules are accessible
try:
    import requisites
except:
    print >> sys.stderr, "ERROR: the cylc core modules are not accessible to Python"
    print >> sys.stderr, "Please add [cylc-top-dir]/src to your $PYTHONPATH." 
    sys.exit(1)

if len( sys.argv ) < 2:
    # COMMAND must be supplied
    print_usage()
    sys.exit(1)

if sys.argv[1] == '-h' or sys.argv[1] == '--help':
    print_usage()
    sys.exit(0)

if sys.argv[1] == '-v' or sys.argv[1] == '--version':
    print cylc_version
    sys.exit(0)

# SECRET COMMAND USED IN AUTO DOCUMENT PROCESSING
if sys.argv[1] == 'commands':
    for command in allowed_commands:
        print command
    sys.exit(0)

# first argument must be COMMAND
command = sys.argv[1]
if command not in allowed_commands:
    print "ERROR, illegal cute command: " + command
    print "Use 'cute --help' to see legal commands"
    sys.exit(1)

if command == 'help': 
    print_usage()
    sys.exit(0)

# remaining arguments must be command options
if len( sys.argv ) == 1:
    command_options = []
else:
    command_options = sys.argv[2:]

# construct command to execute
execute = ''

# construct the actual command name
command = '_' + command 

# subprocess.call() takes a list: [ command, arg1, arg2, ...]
execute = [ command ]
for f in command_options:
    execute.append( f )

if use_subprocess:
    try:
        retcode = subprocess.call( execute )
        if retcode != 0:
            # the command returned non-zero exist status
            print >> sys.stderr, command + ' failed: ', retcode
            sys.exit(1)

    except OSError:
        # the command was not invoked
        print >> sys.stderr, 'ERROR: unable to execute ' + command
        print >> sys.stderr, ' * Have you sourced $CYLC_DIR/cylc-env.sh?'
        print >> sys.stderr, " * Are all cylc scripts executable?"
        print >> sys.stderr, " * Have you run 'cylc configure' yet?"
        sys.exit(1)
else:
    command = ' '.join(execute)
    os.system( command )
