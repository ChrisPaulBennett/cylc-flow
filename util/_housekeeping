#!/usr/bin/env python

import os, re, sys
import shutil
import cycle_time
from optparse import OptionParser
from execute import execute
from mkdir_p import mkdir_p
from task_message import message

try:
    import subprocess
    use_subprocess = True
except:
    use_subprocess = False
    print "+++++++++++++++++++++++++++++++++++++++++++++++"
    print "WARNING: UNABLE TO IMPORT THE SUBPROCESS MODULE"
    pyver = sys.version_info
    if pyver < (2, 4):
        print "  (subprocess was introduced in Python 2.4)"
    print "=> the file differencing check functionality is"
    print "not available for housekeeping delete operation"
    print "+++++++++++++++++++++++++++++++++++++++++++++++"
    print


def right_justify( short, long ):
    template = re.sub( '.', ' ', long )
    short_re = re.sub( '.', '.', short ) + '$'
    return re.sub( short_re, short, template )
 
usage = """1/ cylcutil housekeeping [options] SOURCE MATCH OFFSET [DESTINATION]
Usage: 2/ cylcutil housekeeping [options] CONFIG

Cycle time based file management: delete, move, or copy, items (files or
directories) with cycle times (extracted from the item name) OFFSET
hours or more earlier than the current or given cycle time. 

The CONFIG file format is one or more of lines of:

VARNAME=VALUE
# comment
SOURCE    MATCH    OPERATION   OFFSET   [DESTINATION]

Where OPERATION is one of 'copy', 'move', or 'delete', and SOURCE,
MATCH, OFFSET, and DESTINATION are as described below for commandline
invocation. See also the example $CYLC_DIR/util/housekeeping.conf.eg.
Environment variables can be defined in the config file, or in cylc
suite.rc or taskdef files when this utility is wrapped by a cylc task.

The SOURCE and DESTINATION directories must be on the local filesystem,
and may contain environment varables such as $HOME or ${HOME}.

DESTINATION may contain the strings YYYYMMDDHH, YYYY, MM, DD, HH; e.g.
$ARCHIVE/oper/YYYYMM/DD. These will be replaced, for each matched item,
using the extracted cycle time.

If DESTINATION is specified for the [delete] operation, matched items in
SOURCE will not be deleted unless an identical file is found in
DESTINATION. This can be used to check that important files have been
successfully archived before deleting the originals. !!!WARNING!!! this
functionality uses Python 'subprocess' module to spawn a shell 'diff
-s' command. Subprocess is not available for Python < 2.4, in which case
the file will be deleted if a file with the *same name* (but not
necessarily identical contents) is found in DESTINATION.

The [move] and [copy] operations are skipped if the item already exists 
in DESTINATION. Use '--force' to change this default behavior.

The [delete] operation can be used to implement a simple rolling archive
of cycle-time labelled files or directories: just set OFFSET to the
appropriate archive length.

Item names must contain a cycle time YYYYMMDDHH, or YYYYMMDD and HH
separately, for comparison with the offset from current cycle time.

MATCH is a Python-style regular expression (NOT A SHELL GLOB!) that must
match the names of items to be managed AND extract their cycle times via
ONE (for YYYYMMDDHH) or TWO (for YYYYMMDD and HH) parenthesized
sub-expressions. A partial match is often sufficient to uniquely
identify the target items.
Examples:
 1/ 'foo-(\d{10})' -> 'foo-2010122318.nc', 'foo-2010090806-bar.txt'
 2/ 'foo-(\d{10}).*\.nc' -> 'foo-2010122318.nc', 'foo-2010090806-bar.nc'
 3/ '(\d{2})_(\d{8}).*\.nc' -> 'foo18_20101223-nz.nc'

SAFE ARCHIVING: The [move] operation is implemented by Python's
shutils.move() which uses 'rename' on the local disk partition and
otherwise copies before deleting the original. So direct use of [move]
should be safe. However, for an extra layer of safety, consider two
distinct operations for each set of files: 1/ copy to archive, then 2/
delete ONLY IF found in the archive (see above).

A summary of what is done is printed to stdout.

A cylc WARNING message is sent only in case of an aborted check-deletion 
due to failure to find the check file, which presumably indicates some 
failure in the archiving process.

Arguments:
  SOURCE - Path to a directory containing items to be managed.
  MATCH  - Python regular expression for matching items to manage.
  OFFSET - Offset from current cycle time at which to begin operating.
  CONFIG - A file specifying how to manage multiple source directories."""

parser = OptionParser( usage )

parser.add_option( "--cycle-time",
        metavar='YYYYMMDDHH',
        help="Cycle time, defaults to $CYCLE_TIME",
        action="store", dest="ctime" )

parser.add_option( "--dry-run",
        help="print what would be done, but don't do it.",
        action="store_true", dest="dry_run", default=False )

parser.add_option( "--force", "-f",
        help="copy or move even if the target already exists",
        action="store_true", dest="force", default=False )

parser.add_option( "--delete", "-d",
        help="delete matched items",
        action="store_true", dest="delete", default=False )

parser.add_option( "--copy", "-c",
        help="copy matched items",
        action="store_true", dest="copy", default=False )

parser.add_option( "--move", "-m",
        help="move matched items",
        action="store_true", dest="move", default=False )

parser.add_option( "--debug", 
        help="write out details of what was done",
        action="store_true", dest="debug", default=False )

( options, args ) = parser.parse_args()

if len( args ) == 0  or len( args ) > 4:
    parser.error( "Wrong number of arguments" ) 

if options.ctime:
    ctime = options.ctime
elif 'CYCLE_TIME' in os.environ:
    ctime = os.environ[ 'CYCLE_TIME' ]
else:
    parser.error( "Use --cycle-time or define $CYCLE_TIME" )

if len( args ) == 1:
    config = args[0]

    print "Parsing config file", os.path.abspath( config )

    if not os.path.isfile( config ):
        parser.error( "file not found: " + config )

    FILE = open( config, 'r' )
    lines = FILE.readlines()
    FILE.close()

    for line in lines:
        # strip trailing newlines
        line = line.rstrip( '\n' )

        # omit blank lines
        if re.match( '^\s*$', line ):
            continue

        # omit full line comments
        if re.match( '^\s*#', line ):
            continue

        # strip trailing comments
        line = re.sub( '#.*$', '', line )

        # defined environment variables
        m = re.match( '(\w+)=(.*)', line )
        if m:
            varname=m.group(1)
            varvalue=m.group(2)
            os.environ[varname] = os.path.expandvars( varvalue )
            if options.debug:
                print 'Defining variable: ', varname, '=', varvalue
            continue

        # parse line
        tokens = line.split()
        destination = ''
        if len( tokens ) == 5:
            source, match, operation, offset, destination = tokens
        elif len( tokens ) == 4:
            source, match, operation, offset = tokens
        else:
            raise SystemExit( "illegal config line:\n  " + line )

        # construct command to execute
        command = '_housekeeping'
        # subprocess.call() takes a list: [ command, arg1, arg2, ...]
        commandlist = [ command ]
        if options.debug:
            commandlist.append( '--debug' )
        if options.dry_run:
            commandlist.append( '--dry-run' )
        if options.force:
            commandlist.append( '--force' )
        commandlist.append( '--cycle-time=' + ctime )
        commandlist.append( '--' + operation )
        commandlist.append( source )
        commandlist.append( match )
        commandlist.append( offset )
        commandlist.append( destination )

        execute( commandlist )

else:

    destination = None

    if not options.delete and not options.move and not options.copy:
        parser.error( "Choose 'delete', 'move', or 'copy'" )

    if len( args ) == 4:
        # DESTINATION
        destination = args[3]

    elif options.move or options.copy:
        parser.error( "Operations 'copy' and 'move' require a destination" )

    if options.copy:
        action = "COPYING"
    elif options.delete:
        action = "DELETING"
    elif options.move:
        action = "MOVING"

    # SOURCE
    source = args[0]

    # MATCH
    match = args[1]

    # OFFSET
    try:
        offset = int( args[2] )
    except ValueError:
        parser.error( "OFFSET must be an integer: " + offset )
    else:
        if offset < 0:
            parser.error( "OFFSET must be a positive integer" )

    print '\n***', action, match, "from", source,
    if destination:
        if options.delete:
            print "if in", destination
        else:
            print "to", destination
    else:
        print

    # interpolate SIMPLE environment variables ($foo, ${foo}) into paths
    source = os.path.expandvars( source )
    if destination:
        destination = os.path.expandvars( destination )

    if options.debug:
        print "\nEnvironment variable interpolation:"
        print " + source dir: ", source
        if destination:
            print " + destination:", destination

    # check source exists
    if not os.path.isdir( source ):
        raise SystemExit( "Source directory not found: " + source )

    ignored = 0
    aborted = 0
    total = 0
    actioned = 0

    for entry in os.listdir( source ):
        total += 1
        entrypath = os.path.join( source, entry )

        if options.debug:
            print "\nSource item:", entrypath

        m = re.search( match, entry )
        if not m:
            ignored += 1
            if options.debug:
                print " + does not match"
            continue

        mgrps = m.groups()
        if len(mgrps) == 1:
            matched_ctime = mgrps[0]

        elif len(mgrps) == 2:
            foo, bar = mgrps
            if len(foo) == 8 and len(bar) == 2:
                matched_ctime = foo + bar
            elif len(foo) == 2 and len(bar) == 8:
                matched_ctime = bar + foo
 
        else:
            raise SystemExit( "Illegal regex?: " + match )

        if not cycle_time.is_valid( matched_ctime ):
            # match is not a valid cycle time: ignore
            if options.debug:
                print " + extracted cycle time is NOT VALID: " + matched_ctime
            ignored += 1
            continue
        else:
            if options.debug:
                print " + extracted cycle time: " + matched_ctime

        # can assume ctime is >= matched_ctime
        gap = cycle_time.diff_hours( ctime, matched_ctime )
        if options.debug:
            print " + computed offset hours", gap, 
        if gap < offset:
            ignored += 1
            if options.debug:
                print "- ignoring (< cutoff)"
            continue
        else:
            if options.debug:
                print "- ACTIONING (>= cutoff)"

        if destination:
            # destination directory may be cycle time dependent
            dest = destination
            dest = re.sub( 'YYYYMMDDHH', matched_ctime, dest )
            dest = re.sub( 'YYYYMMDD', matched_ctime[0:8], dest )
            dest = re.sub( 'YYYYMM', matched_ctime[0:6], dest )
            dest = re.sub( 'MMDD', matched_ctime[4:8], dest )
            dest = re.sub( 'YYYY', matched_ctime[0:4], dest )
            dest = re.sub( 'MM', matched_ctime[8:10], dest )
            dest = re.sub( 'DD', matched_ctime[6:8], dest )
            dest = re.sub( 'HH', matched_ctime[8:10], dest )
    
            if options.debug:
                print " + expanded destination directory:", dest,
    
            if os.path.isfile( dest ):
                print
                raise SystemExit( "Destination directory exists as a file: " + dest )
        
            elif os.path.isdir( dest ):
                if options.debug:
                    print " (exists)"
            else:
                if options.debug:
                    print "(creating)"
                mkdir_p( dest )

            target = os.path.join( dest, entry )
            if options.debug:
                print " + target:", target, 

            if not os.path.exists( target ):
                target_exists = False
                if options.debug:
                    print "... does not exist"
            else:
                target_exists = True
                if options.debug:
                    print "... exists"

                if use_subprocess:
                    # Are the files identical?
                    # There seems to be no obvious Pythonic 'diff -s'...
                    command = 'diff'
                    # subprocess.call() takes a list: [ command, arg1, arg2, ...]
                    commandlist = [ command ]
                    commandlist.append( '-s')
                    commandlist.append( target )
                    commandlist.append( entrypath )
                    try:
                        execute( commandlist, ignore_output=True )
                    except:
                        target_identical = False
                    else:
                        target_identical = True

            if options.delete:
                if use_subprocess:
                    if target_exists and target_identical:
                        # delete the file (handled below)
                        pass

                    elif target_exists and not target_identical:
                        msg = "NOT DELETING " + entrypath + " (" + target + " DIFFERS)"
                        message( msg, priority='WARNING' ).send()
                        aborted += 1
                        continue

                    else:
                        # target does not exist
                        msg = "NOT DELETING " + entrypath + " (" + target + " not found)"
                        message( msg, priority='WARNING' ).send()
                        aborted += 1
                        continue
                else:
                    if target_exists:
                        # delete the file (handled below)
                        pass
                    else:
                        # target does not exist
                        msg = "NOT DELETING " + entrypath + " (" + target + " not found)"
                        message( msg, priority='WARNING' ).send()
                        aborted += 1
                        continue

            elif not options.force:
                # unforced copy or move
                if target_exists and target_identical:
                    print "NOT", action, entrypath, "-->", target, "(target exists)"
                    aborted += 1
                    continue
                elif target_exists and not target_identical:
                    msg = "NOT " + action + entrypath + " (" + target + " (target exists BUT DIFFERS)"
                    message( msg, priority='WARNING' ).send()
                    aborted += 1
                    continue
 
        actioned += 1

        if options.delete:
            if options.dry_run:
                print "(dry run) WOULD DELETE ", entrypath
                continue

            print "DELETING ", entrypath
            if os.path.isdir( entrypath ):
                shutil.rmtree( entrypath )
            elif os.path.isfile( entrypath ):
                os.unlink( entrypath )

        elif options.copy:
            if options.dry_run:
                print "(dry run) WOULD COPY " + entrypath + " --> " + target
                continue
                
            print "COPYING " + entrypath + " --> " + target
            # NOTE: shutils.copytree() does not allow the destination
            # directory to exist beforehand; i.e. it won't add files to an
            # existing directory. So for now we'll do it by executing a
            # shell command.
    
            # construct command to execute
            command = 'cp'
            # subprocess.call() takes a list: [ command, arg1, arg2, ...]
            commandlist = [ command ]
            commandlist.append( '-r')
            commandlist.append( entrypath )
            commandlist.append( dest )
            # script will abort with warning if the copy fails here
            execute( commandlist )
    
        elif options.move:
            if options.dry_run:
                print "(dry run) WOULD MOVE " + entrypath + " --> " + target
                continue

            print "MOVING " + entrypath + " --> " + target
            # shutil.move() is SAFE, docs say:
            #   Recursively move a file or directory to another location.
            #   If the destination is on the current filesystem, then simply
            #   use rename. Otherwise, copy src (with copy2()) to the dst
            #   and then remove src.
    
            shutil.move( entrypath, dest )
    
        else:
            # will not be reached due to the check above
            raise SystemExit( "No operation chosen (delete,move,copy)")
    
    did = re.sub( 'YING', 'IED', action )
    did = re.sub( 'ING', 'ED', did )

    print
    print right_justify( str(actioned), str(total) ) + "/" + str( total ), "\t" + did
    print right_justify( str(aborted),  str(total) ) + "/" + str( total ), "\tNOT", did 
    print right_justify( str(ignored),  str(total) )+ "/" + str( total ), "\tnot matched"
