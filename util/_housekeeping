#!/usr/bin/env python

import os, sys
import datetime
from optparse import OptionParser
from housekeeping import config_file, config_line

usage = """1/ cylc housekeeping [options] SOURCE MATCH OPER OFFSET [DEST]
Usage: 2/ cylc housekeeping [options] CONFIG

Cycle-time based file management: delete, move, or copy files or
directories whose names contain a cycle time that is MORE THAN
OFFSET hours earlier than the current (or given) cycle time. 

The CONFIG file format is one or more of lines of:
#------------
VARNAME=VALUE
# comment
SOURCE    MATCH    OPERATION   OFFSET   [DESTINATION]
#------------

Where OPERATION is one of 'copy', 'move', or 'delete', and SOURCE,
MATCH, OFFSET, and DESTINATION are as described below for commandline
invocation. See also the example $CYLC_DIR/util/housekeeping.conf.eg.
Environment variables can be defined in the config file for convenience,
but note that you can just do the same on the commandline, or in the
suite.rc or taskdef files for cylc tasks.

The SOURCE and DESTINATION directories must be on the local filesystem,
and may contain environment varables such as $HOME or ${HOME}.

DESTINATION may contain the strings YYYYMMDDHH, YYYY, MM, DD, HH; e.g.
$ARCHIVE/oper/YYYYMM/DD. These will be replaced, for each matched item,
using the extracted cycle time.

If DESTINATION is specified for the [delete] operation, matched items in
SOURCE will not be deleted unless an identical file is found in
DESTINATION. This can be used to check that important files have been
successfully archived before deleting the originals.

[move] and [copy] operations are aborted if the target item already
exists in DESTINATION, and a warning is emitted if the existing target
item is not identical to the source. Use '--force' to force a copy or
move regardless of this.

The [delete] operation can be used to implement a simple rolling archive
of cycle-time labelled files or directories: just set OFFSET to the
appropriate archive length.

Item names must contain a cycle time YYYYMMDDHH, or YYYYMMDD and HH
separately, for comparison with the offset from current cycle time.

MATCH is a Python-style regular expression (NOT A SHELL GLOB!) that must
match the names of items to be managed AND extract their cycle times via
ONE (for YYYYMMDDHH) or TWO (for YYYYMMDD and HH) parenthesized
sub-expressions. A partial match is often sufficient to uniquely
identify the target items.
Examples:
 1/ 'foo-(\d{10})' -> 'foo-2010122318.nc', 'foo-2010090806-bar.txt'
 2/ 'foo-(\d{10}).*\.nc' -> 'foo-2010122318.nc', 'foo-2010090806-bar.nc'
 3/ '(\d{2})_(\d{8}).*\.nc' -> 'foo18_20101223-nz.nc'
 If you need to use additional parentheses for either-or matches,
 they MUST be of the (?:...) type to avoid creating a new match group.
 E.g.:
 4/ 'foo-(\d{10})\.(?:nc|txt)' -> 'foo-2010122318.nc', 'foo-2010090806-bar.txt'
Use start and end of string markers to force exact (non-partial) matches:
 E.g. '^foo-(\d{10})-bar.nc$' instead of 'foo-(\d{10})-bar.nc'. 

SAFE ARCHIVING: The [move] operation is implemented by Python's
shutils.move() which uses 'rename' on the local disk partition and
otherwise copies before deleting the original. So direct use of [move]
should be safe. However, for an extra layer of safety, consider two
distinct operations for each set of files: 1/ copy to archive, then 2/
delete ONLY IF found in the archive (see above).

A summary of what is done is printed to stdout.

A cylc WARNING message is sent only in case of an aborted check-deletion 
due to failure to find the check file, which presumably indicates some 
failure in the archiving process.

Output options: In all cases a summary of what was done, and any warning
messages, is printed after actioning each config line.
  --quiet   - no additional information is printed (just the summaries)
  (default) - also print each individual action, but NOT copies or
              moves that were aborted because the target already existed
              (normal when copying and deleting with different offsets).
  --verbose - also print each individual action, AND copies or moves that
              were aborted because the target already exists.
Aborted deletion is always a warning because this indicates that the 
check file is either missing or differs from the source file.

With --quiet, no other information is printed. By default, 
Arguments:
  SOURCE - Path to a directory containing items to be managed.
  MATCH  - Python regular expression for matching items to manage.
  OPER   - operation: 'copy', 'move', or 'delete'.
  OFFSET - Offset from current cycle time at which to begin operating.
  CONFIG - A file specifying how to manage multiple source directories.
  DEST   - Target directory path for move or copy operations."""

parser = OptionParser( usage )

# WARNING: IF ADDING NEW COMMANDLINE OPTIONS TO THIS SCRIPT, BE AWARE
# THAT THEY NEED TO BE PARSED THROUGH TO THE INNER SELF-CALL (FOR EACH
# LINE OF A CONFIG FILE; SEE BELOW)

parser.add_option( "--cycle-time",
        metavar='YYYYMMDDHH',
        help="Cycle time, defaults to $CYCLE_TIME",
        action="store", dest="ctime" )

parser.add_option( "--dry-run",
        help="print what would be done, but don't do it.",
        action="store_true", dest="dry_run", default=False )

parser.add_option( "-i", "--interactive",
        help="ask whether to action or skip each config file line",
        action="store_true", dest="interactive", default=False )

parser.add_option( "-f", "--force",
        help="copy or move even if the target already exists",
        action="store_true", dest="force", default=False )

parser.add_option( "--mode", 
        help="Octal umask for creating new destination directories"
        "E.g. 0775 for drwxrwxr-x",
        metavar='MODE',
        action="store", dest="mode", default=None )

parser.add_option( "--only", "-o",
        help="Only action config file lines matching any member of a "
        "comma-separated list of regular expressions. Each regex can "
        "match a whole line or just part of it, so you can easily "
        "single out any line from any housekeeping config file.",
        metavar='LIST', action="store", dest="only", default=None )

parser.add_option( "--except", "-e",
        help="Only action config file lines NOT matching any member of a "
        "comma-separated list of regular expressions. See also "
        "documentation for --only.",
        metavar='LIST', action="store", dest="excpt", default=None )

parser.add_option( "--quiet", "-q",
        help="print only a summary of what was done.",
        action="store_true", dest="quiet", default=False )

parser.add_option( "--verbose", "-v",
        help="print every actioned operation",
        action="store_true", dest="verbose", default=False )

parser.add_option( "--cheapdiff", "-c",
        help="Assume source and target files of the same size are identical",
        action="store_true", dest="cheap", default=False )

parser.add_option( "--batch-size", "-b",
        help="Do parallel processing of matched files in batches "
        "of this size. Parallel processes are spawned for each "
        "batch member, then we wait on all members finishing before "
        "processing the next batch.",
        metavar='INT', action="store", dest="batchsize", default=1 )

( options, args ) = parser.parse_args()

if len(args) != 1  and len( args ) != 4 and len(args) != 5:
    parser.error( "Wrong number of arguments" ) 

default = True
quiet = False
verbose = False
if options.verbose:
    quiet = True
    verbose = True
elif options.quiet:
    quiet = True
    default = False

if options.ctime:
    ctime = options.ctime
elif 'CYCLE_TIME' in os.environ:
    ctime = os.environ[ 'CYCLE_TIME' ]
else:
    parser.error( "Use --cycle-time or define $CYCLE_TIME" )

batchsize = options.batchsize
try:
    batchsize = int( batchsize )
except ValueError:
    parser.error( "Batch size must be integer: " + batchsize )

print "START: ", datetime.datetime.now()

if len(args) == 0 or len(args) > 5:
    parser.usage()
    sys.exit(1)

if len(args) == 1:
    file = args[0]
    config_file( file, ctime, verbose=verbose, cheap=options.cheap ).action( batchsize )

else:
    source = args[0]
    match  = args[1]
    opern  = args[2]
    offset = args[3]
    destn  = None
    if len(args) == 5:
        destn = args[4]

    config_line( source, match, opern, ctime, offset, destn, verbose=verbose, cheap=options.cheap ).action( batchsize )
    
print '\nFINISH: ', datetime.datetime.now()
