#!/usr/bin/env python

import os, re, sys
import shutil
import cycle_time
from optparse import OptionParser
from execute import execute
from mkdir_p import mkdir_p
from task_message import message

try:
    import subprocess
    use_subprocess = True
except:
    use_subprocess = False
    print "+++++++++++++++++++++++++++++++++++++++++++++++"
    print "WARNING: UNABLE TO IMPORT THE SUBPROCESS MODULE"
    pyver = sys.version_info
    if pyver < (2, 4):
        print "  (subprocess was introduced in Python 2.4)"
    print "=> the file differencing check functionality is"
    print "not available for housekeeping delete operation"
    print "+++++++++++++++++++++++++++++++++++++++++++++++"
    print


def right_justify( short, long ):
    template = re.sub( '.', ' ', long )
    short_re = re.sub( '.', '.', short ) + '$'
    return re.sub( short_re, short, template )
 
usage = """1/ cylcutil housekeeping [options] SOURCE MATCH OPER OFFSET [DEST]
Usage: 2/ cylcutil housekeeping [options] CONFIG

Cycle time based file management: delete, move, or copy, items (files or
directories) with cycle times (extracted from the item name) OFFSET
hours or more earlier than the current or given cycle time. 

The CONFIG file format is one or more of lines of:

VARNAME=VALUE
# comment
SOURCE    MATCH    OPERATION   OFFSET   [DESTINATION]

Where OPERATION is one of 'copy', 'move', or 'delete', and SOURCE,
MATCH, OFFSET, and DESTINATION are as described below for commandline
invocation. See also the example $CYLC_DIR/util/housekeeping.conf.eg.
Environment variables can be defined in the config file for convenience,
but note that you can just do the same on the commandline, or in the
suite.rc or taskdef files for cylc tasks.

The SOURCE and DESTINATION directories must be on the local filesystem,
and may contain environment varables such as $HOME or ${HOME}.

DESTINATION may contain the strings YYYYMMDDHH, YYYY, MM, DD, HH; e.g.
$ARCHIVE/oper/YYYYMM/DD. These will be replaced, for each matched item,
using the extracted cycle time.

If DESTINATION is specified for the [delete] operation, matched items in
SOURCE will not be deleted unless an identical file is found in
DESTINATION. This can be used to check that important files have been
successfully archived before deleting the originals. !!!WARNING!!! this
functionality uses Python 'subprocess' module to spawn a shell 'diff
-s' command. Subprocess is not available for Python < 2.4, in which case
the file will be deleted if a file with the *same name* (but not
necessarily identical contents) is found in DESTINATION.

The [move] and [copy] operations are skipped if the item already exists 
in DESTINATION. Use '--force' to change this default behavior.

The [delete] operation can be used to implement a simple rolling archive
of cycle-time labelled files or directories: just set OFFSET to the
appropriate archive length.

Item names must contain a cycle time YYYYMMDDHH, or YYYYMMDD and HH
separately, for comparison with the offset from current cycle time.

MATCH is a Python-style regular expression (NOT A SHELL GLOB!) that must
match the names of items to be managed AND extract their cycle times via
ONE (for YYYYMMDDHH) or TWO (for YYYYMMDD and HH) parenthesized
sub-expressions. A partial match is often sufficient to uniquely
identify the target items.
Examples:
 1/ 'foo-(\d{10})' -> 'foo-2010122318.nc', 'foo-2010090806-bar.txt'
 2/ 'foo-(\d{10}).*\.nc' -> 'foo-2010122318.nc', 'foo-2010090806-bar.nc'
 3/ '(\d{2})_(\d{8}).*\.nc' -> 'foo18_20101223-nz.nc'
 If you need to use additional parentheses for either-or matches,
 the MUST be of the (?:...) type to avoid creating a new match group.
 E.g.:
 4/ 'foo-(\d{10})\.(?:nc|txt)' -> 'foo-2010122318.nc', 'foo-2010090806-bar.txt'

SAFE ARCHIVING: The [move] operation is implemented by Python's
shutils.move() which uses 'rename' on the local disk partition and
otherwise copies before deleting the original. So direct use of [move]
should be safe. However, for an extra layer of safety, consider two
distinct operations for each set of files: 1/ copy to archive, then 2/
delete ONLY IF found in the archive (see above).

A summary of what is done is printed to stdout.

A cylc WARNING message is sent only in case of an aborted check-deletion 
due to failure to find the check file, which presumably indicates some 
failure in the archiving process.

Arguments:
  SOURCE - Path to a directory containing items to be managed.
  MATCH  - Python regular expression for matching items to manage.
  OPER   - operation: 'copy', 'move', or 'delete'.
  OFFSET - Offset from current cycle time at which to begin operating.
  CONFIG - A file specifying how to manage multiple source directories.
  DEST   - Target directory path for move or copy operations."""

parser = OptionParser( usage )

# WARNING: IF ADDING NEW COMMANDLINE OPTIONS TO THIS SCRIPT, BE AWARE
# THAT THEY NEED TO BE PARSED THROUGH TO THE INNER SELF-CALL (FOR EACH
# LINE OF A CONFIG FILE; SEE BELOW)

parser.add_option( "--cycle-time",
        metavar='YYYYMMDDHH',
        help="Cycle time, defaults to $CYCLE_TIME",
        action="store", dest="ctime" )

parser.add_option( "--dry-run",
        help="print what would be done, but don't do it.",
        action="store_true", dest="dry_run", default=False )

parser.add_option( "--force", "-f",
        help="copy or move even if the target already exists",
        action="store_true", dest="force", default=False )

parser.add_option( "--mode", 
        help="Octal umask for creating new destination directories"
        "E.g. 0775 for drwxrwxr-x",
        metavar='MODE',
        action="store", dest="mode", default=None )

parser.add_option( "--verbose", 
        help="print more information on what was done",
        action="store_true", dest="verbose", default=False )

parser.add_option( "--debug", 
        help="print full trace of what was done",
        action="store_true", dest="debug", default=False )

( options, args ) = parser.parse_args()

if len(args) != 1  and len( args ) != 4 and len(args) != 5:
    parser.error( "Wrong number of arguments" ) 

if options.debug and options.verbose:
    parser.error( "Choose debug or verbose, not both" )

verbose = False
debug = False
if options.debug:
    debug = True
    verbose = True
elif options.verbose:
    verbose = True

if options.ctime:
    ctime = options.ctime
elif 'CYCLE_TIME' in os.environ:
    ctime = os.environ[ 'CYCLE_TIME' ]
else:
    parser.error( "Use --cycle-time or define $CYCLE_TIME" )

if len( args ) == 1:
    config = args[0]

    print "Parsing config file", os.path.abspath( config )

    if not os.path.isfile( config ):
        parser.error( "file not found: " + config )

    FILE = open( config, 'r' )
    lines = FILE.readlines()
    FILE.close()

    for line in lines:
        # strip trailing newlines
        line = line.rstrip( '\n' )

        # omit blank lines
        if re.match( '^\s*$', line ):
            continue

        # omit full line comments
        if re.match( '^\s*#', line ):
            continue

        # strip trailing comments
        line = re.sub( '#.*$', '', line )

        # defined environment variables
        m = re.match( '(\w+)=(.*)', line )
        if m:
            varname=m.group(1)
            varvalue=m.group(2)
            os.environ[varname] = os.path.expandvars( varvalue )
            if debug:
                print 'Defining variable: ', varname, '=', varvalue
            continue

        # parse line
        tokens = line.split()
        destination = ''
        if len( tokens ) == 5:
            source, match, operation, offset, destination = tokens
        elif len( tokens ) == 4:
            source, match, operation, offset = tokens
        else:
            raise SystemExit( "illegal config line:\n  " + line )

        # now make a recursive call to this script. Copy sys.argv
        # to get the command name and arguments, but remove the config
        # file name from the list and  use slice notation get a proper
        # copy instead of a reference (so we don't try to re-remove
        # the config file name on the next call).
        command = sys.argv[:]
        command.remove( config )
        execute( command + [ source, match, operation, offset, destination ] )

else:

    source = args[0]
    match = args[1]
    operation = args[2]
    offset_str = args[3]

    legal_ops = [ 'copy', 'move', 'delete' ]
    if operation not in legal_ops:
        parser.error( "Illegal operation: " + operation )
    if operation == 'copy':
        action = "COPYING"
    elif operation == 'delete':
        action = "DELETING"
    elif operation == 'move':
        action = "MOVING"

    destination = None
    if len( args ) == 5:
        destination = args[4]
    elif operation == 'copy' or operation == 'move':
        parser.error( operation + " requires a destination" )

    try:
        offset = int( offset_str )
    except ValueError:
        parser.error( "OFFSET must be an integer: " + offset_str )
    else:
        if offset < 0:
            parser.error( "OFFSET must be a positive integer" )

    print '\n***', action, match, "from", source + ", offset", offset_str + ",",
    if destination:
        if operation == 'delete':
            print "if in", destination
        else:
            print "to", destination
    else:
        print

    # interpolate SIMPLE environment variables ($foo, ${foo}) into paths
    source = os.path.expandvars( source )
    if destination:
        destination = os.path.expandvars( destination )

    if debug:
        print "\nEnvironment variable interpolation:"
        print " + source dir: ", source
        if destination:
            print " + destination:", destination

    # check source exists
    if not os.path.isdir( source ):
        raise SystemExit( "Source directory not found: " + source )

    ignored = 0
    aborted = 0
    total = 0
    actioned = 0

    for entry in os.listdir( source ):
        total += 1
        entrypath = os.path.join( source, entry )

        if debug:
            print "\nSource item:", entrypath

        m = re.search( match, entry )
        if not m:
            ignored += 1
            if debug:
                print " + does not match"
            continue

        mgrps = m.groups()
        if len(mgrps) == 1:
            matched_ctime = mgrps[0]

        elif len(mgrps) == 2:
            foo, bar = mgrps
            if len(foo) == 8 and len(bar) == 2:
                matched_ctime = foo + bar
            elif len(foo) == 2 and len(bar) == 8:
                matched_ctime = bar + foo
            else:
                raise SystemExit( "Illegal match: " + foo + ", " + bar )
                print foo, bar
                sys.exit(1)
 
        else:
            raise SystemExit( "Illegal regex?: " + match )

        if not cycle_time.is_valid( matched_ctime ):
            # match is not a valid cycle time: ignore
            if debug:
                print " + extracted cycle time is NOT VALID: " + matched_ctime
            ignored += 1
            continue
        else:
            if debug:
                print " + extracted cycle time: " + matched_ctime

        # can assume ctime is >= matched_ctime
        gap = cycle_time.diff_hours( ctime, matched_ctime )
        if debug:
            print " + computed offset hours", gap, 
        if gap < offset:
            ignored += 1
            if debug:
                print "- ignoring (< cutoff)"
            continue
        else:
            if debug:
                print "- ACTIONING (>= cutoff)"

        if destination:
            # destination directory may be cycle time dependent
            dest = destination
            dest = re.sub( 'YYYYMMDDHH', matched_ctime, dest )
            dest = re.sub( 'YYYYMMDD', matched_ctime[0:8], dest )
            dest = re.sub( 'YYYYMM', matched_ctime[0:6], dest )
            dest = re.sub( 'MMDD', matched_ctime[4:8], dest )
            dest = re.sub( 'YYYY', matched_ctime[0:4], dest )
            dest = re.sub( 'MM', matched_ctime[8:10], dest )
            dest = re.sub( 'DD', matched_ctime[6:8], dest )
            dest = re.sub( 'HH', matched_ctime[8:10], dest )
    
            if debug:
                print " + expanded destination directory:", dest,
    
            if os.path.isfile( dest ):
                print
                raise SystemExit( "Destination directory exists as a file: " + dest )
        
            elif os.path.isdir( dest ):
                if debug:
                    print " (exists)"
            else:
                if debug:
                    print "(creating)"
                mkdir_p( dest, options.mode )

            target = os.path.join( dest, entry )
            if debug:
                print " + target:", target, 

            if not os.path.exists( target ):
                target_exists = False
                if debug:
                    print "... does not exist"
            else:
                target_exists = True
                if debug:
                    print "... exists"

                if operation == 'delete' and use_subprocess:
                    # copy: abort if target exists
                    # delete: abort if target exists AND differs

                    # Are the files identical?
                    # There seems to be no obvious Pythonic 'diff -s'...
                    command = 'diff'
                    # subprocess.call() takes a list: [ command, arg1, arg2, ...]
                    commandlist = [ command ]
                    commandlist.append( '-s')
                    commandlist.append( target )
                    commandlist.append( entrypath )
                    try:
                        execute( commandlist, ignore_output=True )
                    except:
                        target_identical = False
                    else:
                        target_identical = True

            if operation == 'delete':
                if use_subprocess:
                    if target_exists and target_identical:
                        # delete the file (handled below)
                        pass

                    elif target_exists and not target_identical:
                        # SEND WARNING MESSAGE
                        msg = "NOT DELETING " + entrypath + " (" + target + " DIFFERS)"
                        message( msg, priority='WARNING' ).send()
                        aborted += 1
                        continue

                    else:
                        # target does not exist
                        # SEND WARNING MESSAGE
                        msg = "NOT DELETING " + entrypath + " (" + target + " not found)"
                        message( msg, priority='WARNING' ).send()
                        aborted += 1
                        continue
                else:
                    if target_exists:
                        # delete the file (handled below)
                        pass
                    else:
                        # target does not exist
                        # SEND WARNING MESSAGE
                        msg = "NOT DELETING " + entrypath + " (" + target + " not found)"
                        message( msg, priority='WARNING' ).send()
                        aborted += 1
                        continue

            elif not options.force:
                # unforced copy or move
                if target_exists: # and target_identical:
                    if verbose:
                        print "NOT", action, entrypath, "-->", target, "(target exists)"
                    aborted += 1
                    continue
                #elif target_exists and not target_identical:
                #    msg = "NOT " + action + entrypath + " (" + target + " (target exists BUT DIFFERS)"
                #    message( msg, priority='WARNING' ).send()
                #    aborted += 1
                #    continue
 
        actioned += 1

        if operation == 'delete':
            if options.dry_run:
                print "(dry run) WOULD DELETE ", entrypath
                continue

            if verbose:
                print "DELETING ", entrypath
            if os.path.isdir( entrypath ):
                shutil.rmtree( entrypath )
            elif os.path.isfile( entrypath ):
                os.unlink( entrypath )

        elif operation == 'copy':
            if options.dry_run:
                print "(dry run) WOULD COPY " + entrypath + " --> " + target
                continue
                
            if verbose:
                print "COPYING " + entrypath + " --> " + target
            # NOTE: shutils.copytree() does not allow the destination
            # directory to exist beforehand; i.e. it won't add files to an
            # existing directory. So for now we'll do it by executing a
            # shell command.
    
            # construct command to execute
            command = 'cp'
            # subprocess.call() takes a list: [ command, arg1, arg2, ...]
            commandlist = [ command ]
            commandlist.append( '-r')
            commandlist.append( entrypath )
            commandlist.append( dest )
            # script will abort with warning if the copy fails here

            execute( commandlist )
    
        elif operation == 'move':
            if options.dry_run:
                print "(dry run) WOULD MOVE " + entrypath + " --> " + target
                continue

            if verbose:
                print "MOVING " + entrypath + " --> " + target
            # shutil.move() is SAFE, docs say:
            #   Recursively move a file or directory to another location.
            #   If the destination is on the current filesystem, then simply
            #   use rename. Otherwise, copy src (with copy2()) to the dst
            #   and then remove src.
    
            shutil.move( entrypath, dest )
    
        else:
            # will not be reached due to the check above
            raise SystemExit( "No operation chosen (delete,move,copy)")
    
    did = re.sub( 'YING', 'IED', action )
    did = re.sub( 'ING', 'ED', did )

    extra = ''
    if options.dry_run:
        extra = 'dry run: would have'
 
    print
    print right_justify( str(actioned), str(total) ) + "/" + str( total ), "\t" + extra + " " + did
    print right_justify( str(aborted),  str(total) ) + "/" + str( total ), "\t" + extra + " NOT", did 
    print right_justify( str(ignored),  str(total) )+ "/" + str( total ), "\tnot matched"
