#!/usr/bin/env python

import os, re, sys
import shutil
import cycle_time
from optparse import OptionParser
from execute import execute
from mkdir_p import mkdir_p
from task_message import message

def right_justify( short, long ):
    template = re.sub( '.', ' ', long )
    short_re = re.sub( '.', '.', short ) + '$'
    return re.sub( short_re, short, template )
 
usage = """1/ cylcutil manage-files [options] SOURCE MATCH OFFSET [DESTINATION]
Usage: 2/ cylcutil manage-files [options] CONFIG

Cycle time based file management: delete, move, or copy, items (files or
directories) whose cycle times (extracted from the item name) are more
than OFFSET hours earlier than the current or given cycle time. 

The CONFIG file format is one or more of lines of:

# comment
SOURCE    MATCH    OPERATION   OFFSET   [DESTINATION]

Where OPERATION is one of 'copy', 'move', or 'delete', and SOURCE,
MATCH, OFFSET, and DESTINATION are as described below for commandline
invocation. See also the example $CYLC_DIR/util/manage-files.conf.eg.

The SOURCE and DESTINATION directories must be on the local filesystem,
and may contain environment varables such as $HOME or ${HOME}.

DESTINATION may contain the strings YYYYMMDDHH, YYYY, MM, DD, HH; e.g.
$ARCHIVE/oper/YYYYMM/DD. These will be replaced, for each matched item,
using the extracted cycle time.

If DESTINATION is specified for the delete operation, matched items in
SOURCE will not be deleted unless they are found in DESTINATION. This
can be used to check that important files have been successfully
archived before deleting the originals. 

The [move] and [copy] operations are skipped if the item already exists 
in DESTINATION. Use '--force' to change this default behavior.

Item names must contain a cycle time YYYYMMDDHH, or YYYYMMDD and HH
separately, for comparison with the offset from current cycle time.

MATCH is a Python-style regular expression (NOT A SHELL GLOB!) that must
match the names of items to be managed AND extract their cycle times via
ONE (for YYYYMMDDHH) or TWO (for YYYYMMDD and HH) parenthesized
sub-expressions. A partial match is often sufficient to uniquely
identify the target items.
Examples:
 1/ 'foo-(\d{10})' -> 'foo-2010122318.nc', 'foo-2010090806-bar.txt'
 2/ 'foo-(\d{10}).*\.nc' -> 'foo-2010122318.nc', 'foo-2010090806-bar.nc'
 3/ '(\d{2})_(\d{8}).*\.nc' -> 'foo18_20101223-nz.nc'

SAFE ARCHIVING: The [move] operation is implemented by Python's
shutils.move() which uses 'rename' on the local disk partition and
otherwise copies before deleting the original. So direct use of [move]
should be safe. However, for an extra layer of safety, consider two
distinct operations for each set of files: 1/ copy to archive, then 2/
delete ONLY IF found in the archive (see above).

A summary of what is done is printed to stdout.

A cylc WARNING message is sent only in case of an aborted check-deletion 
due to failure to find the check file, which presumably indicates some 
failure in the archiving process.

Arguments:
  SOURCE - Path to a directory containing items to be managed.
  MATCH  - Python regular expression for matching items to manage.
  OFFSET - Offset from current cycle time, beyond which to operate.
  CONFIG - A file specifying how to manage multiple source directories."""

parser = OptionParser( usage )

parser.add_option( "--cycle-time",
        metavar='YYYYMMDDHH',
        help="Cycle time, defaults to $CYCLE_TIME",
        action="store", dest="ctime" )

parser.add_option( "--force", "-f",
        help="copy or move even if the target already exists",
        action="store_true", dest="force", default=False )

parser.add_option( "--delete", "-d",
        help="delete matched items",
        action="store_true", dest="delete", default=False )

parser.add_option( "--copy", "-c",
        help="copy matched items",
        action="store_true", dest="copy", default=False )

parser.add_option( "--move", "-m",
        help="move matched items",
        action="store_true", dest="move", default=False )

parser.add_option( "--debug", 
        help="write out details of what was done",
        action="store_true", dest="debug", default=False )

( options, args ) = parser.parse_args()

if len( args ) == 0  or len( args ) > 4:
    parser.error( "Wrong number of arguments" ) 

if options.ctime:
    ctime = options.ctime
elif 'CYCLE_TIME' in os.environ:
    ctime = os.environ[ 'CYCLE_TIME' ]
else:
    parser.error( "Use --cycle-time or define $CYCLE_TIME" )

if len( args ) == 1:
    config = args[0]

    print "Parsing config file", os.path.abspath( config )

    if not os.path.isfile( config ):
        parser.error( "file not found: " + config )

    FILE = open( config, 'r' )
    lines = FILE.readlines()
    FILE.close()

    for line in lines:
        # strip trailing newlines
        line = line.rstrip( '\n' )

        # omit blank lines
        if re.match( '^\s*$', line ):
            continue

        # omit full line comments
        if re.match( '^\s*#', line ):
            continue

        # strip trailing comments
        line = re.sub( '#.*$', '', line )

        # parse line
        tokens = line.split()
        destination = ''
        if len( tokens ) == 5:
            source, match, operation, offset, destination = tokens
        elif len( tokens ) == 4:
            source, match, operation, offset = tokens
        else:
            raise SystemExit( "illegal config line:\n  " + line )

        # construct command to execute
        command = '_manage-files'
        # subprocess.call() takes a list: [ command, arg1, arg2, ...]
        commandlist = [ command ]
        if options.debug:
            commandlist.append( '--debug' )
        if options.force:
            commandlist.append( '--force' )
        commandlist.append( '--cycle-time=' + ctime )
        commandlist.append( '--' + operation )
        commandlist.append( source )
        commandlist.append( match )
        commandlist.append( offset )
        commandlist.append( destination )

        execute( commandlist )

else:

    destination = None

    if not options.delete and not options.move and not options.copy:
        parser.error( "Choose 'delete', 'move', or 'copy'" )

    if len( args ) == 4:
        # DESTINATION
        destination = args[3]

    elif options.move or options.copy:
        parser.error( "Operations 'copy' and 'move' require a destination" )

    if options.copy:
        action = "COPYING"
    elif options.delete:
        action = "DELETING"
    elif options.move:
        action = "MOVING"

    # SOURCE
    source = args[0]

    # MATCH
    match = args[1]

    # OFFSET
    try:
        offset = int( args[2] )
    except ValueError:
        parser.error( "OFFSET must be an integer: " + offset )
    else:
        if offset < 0:
            parser.error( "OFFSET must be a positive integer" )

    print '\n***', action, match, "from", source,
    if destination:
        if options.delete:
            print "if in", destination
        else:
            print "to", destination
    else:
        print

    # interpolate SIMPLE environment variables ($foo, ${foo}) into paths
    source = os.path.expandvars( source )
    if destination:
        destination = os.path.expandvars( destination )

    if options.debug:
        print "\nEnvironment variable interpolation:"
        print " + source dir: ", source
        if destination:
            print " + destination:", destination

    # check source exists
    if not os.path.isdir( source ):
        raise SystemExit( "Source directory not found: " + source )

    ignored = 0
    aborted = 0
    total = 0
    actioned = 0

    for entry in os.listdir( source ):
        total += 1
        entrypath = os.path.join( source, entry )

        if options.debug:
            print "\nSource item:", entrypath

        m = re.search( match, entry )
        if not m:
            ignored += 1
            if options.debug:
                print " + does not match"
            continue

        mgrps = m.groups()
        if len(mgrps) == 1:
            matched_ctime = mgrps[0]

        elif len(mgrps) == 2:
            foo, bar = mgrps
            if len(foo) == 8 and len(bar) == 2:
                matched_ctime = foo + bar
            elif len(foo) == 2 and len(bar) == 8:
                matched_ctime = bar + foo
 
        else:
            raise SystemExit( "Illegal regex?: " + match )

        if not cycle_time.is_valid( matched_ctime ):
            # match is not a valid cycle time: ignore
            if options.debug:
                print " + extracted cycle time is NOT VALID: " + matched_ctime
            ignored += 1
            continue
        else:
            if options.debug:
                print " + extracted cycle time: " + matched_ctime

        # can assume ctime is >= matched_ctime
        gap = cycle_time.diff_hours( ctime, matched_ctime )
        if options.debug:
            print " + computed offset hours", gap, 
        if gap <= offset:
            # younger than cutoff: ignore
            ignored += 1
            if options.debug:
                print " not actionable (younger than cutoff)"
            continue
        else:
            if options.debug:
                print " ACTIONING (older than cutoff)"

        if destination:
            # destination directory may be cycle time dependent
            dest = destination
            dest = re.sub( 'YYYYMMDDHH', matched_ctime, dest )
            dest = re.sub( 'YYYYMMDD', matched_ctime[0:8], dest )
            dest = re.sub( 'YYYYMM', matched_ctime[0:6], dest )
            dest = re.sub( 'MMDD', matched_ctime[4:8], dest )
            dest = re.sub( 'YYYY', matched_ctime[0:4], dest )
            dest = re.sub( 'MM', matched_ctime[8:10], dest )
            dest = re.sub( 'DD', matched_ctime[6:8], dest )
            dest = re.sub( 'HH', matched_ctime[8:10], dest )
    
            if options.debug:
                print " + expanded destination directory:", dest,
    
            if os.path.isfile( dest ):
                print
                raise SystemExit( "Destination directory exists as a file: " + dest )
        
            elif os.path.isdir( dest ):
                if options.debug:
                    print " (exists)"
            else:
                if options.debug:
                    print "(creating)"
                mkdir_p( dest )

            target = os.path.join( dest, entry )
            target_exists = os.path.exists( target )
            if options.delete:
                if options.debug:
                    print " + delete only IF this file exists:", target 
                if not target_exists:
                    msg = "NOT DELETING " + entrypath + " (" + target + " not found)"
                    message( msg, priority='WARNING' ).send()
                    aborted += 1
                    continue

            elif target_exists and not options.force:
                print "NOT", action, entrypath, "-->", target, "(target exists)"
                aborted += 1
                continue
 
        actioned += 1

        if options.delete:
            print "DELETING ", entrypath
            if os.path.isdir( entrypath ):
                shutil.rmtree( entrypath )
            elif os.path.isfile( entrypath ):
                os.unlink( entrypath )
            continue

        if options.copy:
            print "COPYING " + entrypath + " --> " + target
            # NOTE: shutils.copytree() does not allow the destination
            # directory to exist beforehand; i.e. it won't add files to an
            # existing directory. So for now we'll do it by executing a
            # shell command.
    
            # construct command to execute
            command = 'cp'
            # subprocess.call() takes a list: [ command, arg1, arg2, ...]
            commandlist = [ command ]
            commandlist.append( '-r')
            commandlist.append( entrypath )
            commandlist.append( dest )
            execute( commandlist )
    
        elif options.move:
            print "MOVING " + entrypath + " --> " + target
            # shutil.move() is SAFE, docs say:
            #   Recursively move a file or directory to another location.
            #   If the destination is on the current filesystem, then simply
            #   use rename. Otherwise, copy src (with copy2()) to the dst
            #   and then remove src.
    
            shutil.move( entrypath, dest )
    
        else:
            # will not be reached due to the check above
            raise SystemExit( "No operation chosen (delete,move,copy)")
    
    did = re.sub( 'YING', 'IED', action )
    did = re.sub( 'ING', 'ED', did )

    print
    print right_justify( str(actioned), str(total) ) + "/" + str( total ), "\t" + did
    print right_justify( str(aborted),  str(total) ) + "/" + str( total ), "\tNOT", did 
    print right_justify( str(ignored),  str(total) )+ "/" + str( total ), "\tnot matched"
