To Do

* TASK FAMILIES:
  + --include and --exclude with task families
  + configure should check for consistency of MEMBER and MEMBER_OF
  + %OWNER should not be required with families (no %COMMAND).
  + currently have to specify %HOURS, which (a) should be
  checked for consistency with family members, or (b) should not be
  necessary (get it from members).

* suite_config.py is now only used for environment vars and job submit
  method => no need for it to be Python source.

* %COMMAND:
    - conditional on HOUR? 
    - allow single quotes in path or commandline

* cylc view
    - 'view -p' crashes nastily on unconfigured suites.
    - exception handling: if user clicks on a task that has just been
      eliminated (test this with quick cycling trivial suite).

* document that simple tasks can be entirely contained in taskdef files,
  via a simple wrapped commandline and %SCRIPTING.

* could make $(CYCLE_TIME) implicit in messages except where reference
  to *other* cycles are required?

* allow $(CYCLE_HOUR) etc. in output and prereq messages (needed if
  anyone insists on using actual filenames in messages). 

* userguide suite: check-env.sh should check task run-length var is
  defined, in case user overwrote the suite config file.

* configure should check INHERIT targets actually exist.  At the moment
  this causes an exception early on at run time.

* make task-specific logs optional, esp for large suites.

* document new use of 'TaskID failed' as an output: added on the fly as
  a new output if failure occurs, then removed from the output list on
  reset.

* if chooser is clicked just as target suite shuts down, failure to
  connect error breaks the app, requiring use of 'kill'.

* lockserver errors to a logfile (e.g. if it is killed it silently 
  fails to restart due to existing Pyro nameserver entry).

* cylc ping hangs if cylc is killed without cleaning up: needs timeout.

* long-running (almost 1 day) dummy mode oper run (started via vnc for
  ministerial opening demo) could not be unlocked or stopped (etc.) -
  got remote I/O Error via Pyro?

* cycle-time conditional environment and TASK in taskdefs.

* persistent state for lockserver, in case of crash or restart while
  suites are running. 

* use new cylc_mode class everywhere mode test is required.

* dummy task does not use lockserver

* lockserver: non-user-specific ($HOME-relative) pid file required, so
  user-specific .cylcrc is not the right place to store this information
  (multiple users need to be able to access the lockserver, but perhaps not
   start and stop it).  MAYBE $CYLC_DIR/.cylcrc IS REQUIRED?

* submit --scheduler: task state resets to 'running' but all messages
  are ignored.

* task stdout and stderr for remote tasks!

* consider how task timeout alerts might be incorporated into cylc? 

* extreme task elimination method - extrapolate forward in time to see
  if a finished task will ever be needed, otherwise delete?

* iteration over dictionary items: DO NOT USE
  = for item in dict:
  =    (operation that adds or removes items from dict)
  -> RuntimeError: dictionary changed size during iteration

  Instead use
  = for item in dict.keys():
  which must build a temporary list?

  CHECK MY USE OF DICTIONARY ITERATION THROUGHOUT THE CODE

* Record stopping time in state dump in case suite shutdown and
  restarted before all tasks reach the stop time is reached? (currently
  at restart those that did reach the stop time will be finished and
  unspawned, while those that didn't will carry on as if there was no
  stop time).

* catch obscure errors, such as attempting to restart when one or more 
  tasks has been commented out of the task list.

* src/which.py, like the shell command, searches only for executable
  files. The ll_raw job submit classes use which to find task scripts
  that don't have a full path supplied in the taskdef; these need
  to check that which returns a result before continuing (e.g. if 
  the task script has not been set executable). 

* DOCUMENT: daemon and asynchronous task

* task groups defined in suite_config cause abort if any of the tasks
  therein are not defined (e.g. if commented out of the task list!)

* parse "HH:mm" for contact delay times etc.

* message command (command line usage only!!!) needs lock and practice mode?

* finish off the connection exception handling in manager class.

* consider reset --no-spawn (Bernard tried to reset a waiting unspawned
  task to finished, which made it spawn ... is this the desired
  behaviour?)

* insert may need a no-spawn option?

* consider restart messages for split tasks that actually use the same 
  restart files: e.g. nzlam_long (06,18Z) and nzlam_short (00,12Z). 
  Currently must combine this into one task with conditionals, OR 
  register (and report) restart messages explicitly because the
  automatic restart messages will not have the right task name.

* check that practice mode suites initialise with the same clock time
  as the original suite!

* DOCUMENT or CHANGE: cotemporal peers of failed tasks are not deleted
  automatically because they we USED TO restart with failed tasks in the 
  'waiting' state (not 'ready') - thus the aforementioned peers may be
  required to satisfy the failed task's prerequisites post resetting.

* Consider the effect of "# uncomment for earliest NON-FAILED" (x2) in
  manager.py - and test with dummy mode failout tasks.  For failed F in
  userguide example suite, it allows some intermediate finished cycles
  to be deleted, but this does not affect the delay due to max runahead.

* consider task proc loop invocation - could we separate summary update
  vs task processing (e.g. when a task fails we have to run pointlessly
  (?) through the loop in order to update the summary immediately for
  monitoring.

* warn about consequences of deleting a task: suite may move on so that
  a reinserted task will not get its prerequisites satisfied.

* task generator should look for mispelled $(CYLCE_TIME)

* is taskdef HOURS sorted for order?

* optionally allow a pyro request handling (or main loop?) timeout.
  (this is not needed now that the stalling problem is solved?)

* consistent suite exit strategy: 
   -sys.exit(1), 
   -raise SystemExit(message)
   -custom exceptions

* all error messages should go to stderr: print >> sys.stderr, 'message'

* allow cylc task proxies to kill their real external tasks at shutdown
  (and otherwise)?

* make sure that no remote operation, other than 'stop', can bring a
  suite down (exception handling on all remote switches).

* when there are multiple finished tasks that can satisfy a new task's
  restart prerequisites, the one that actually satisfies the new task
  will be an essentially random choice (the first one that comes along). 
  This is OK because the only thing that matters is that at least one
  task can satisfy the restart dependency, then the new task calls the
  prerequisite satisfied. However, we could get tasks to record the ID
  of the satisfier task as well, for each prerequisite, and also to
  choose the latest task as satisfier if more than one can do it.

* the task-generator script should check that the user-defined task
  names do not clash with parent class or attribute names.

* when remote killing all waiting tasks at a ref time, check that (a)
  the suite has moved on passed that time, and (b) none of the waiting
  tasks are contact tasks whose time has not come up yet.

* tasks with HOUR-conditional outputs may have trouble with the "keep
  one finished task of each kind" procedure in kill_spent_tasks(). Best
  to have multiple tasks instead? 

* detect when taskdef files are newer than task_classes file, and warn
  that use of configure may be required.

* use the custom clock everywhere (it knows about dummy mode).

* clean up the clock class with respect to dummy vs real time, and move
  it into task manager?

* do we need non-interpolation of single-quoted strings in taskdef
  environment, scripting, command? (implement in job_submit.py)?

* see To Do comment in broker.negotiate() - priority low.

====================================
FUZZY PREREQUISITES (only for infrequent 'advanced' usage - e.g. hourly
TopNet in EcoConnect)

* allow mixed fuzzy and non-fuzzy prerequisites (currently have to 
  set identical fuzzy bounds to simulate the non-fuzzy case; see
  topnet.py).

* FUZZY MATCHING CURRENTLY ASSUMES AT MOST ONE COMPATIBLE OLDER FINISHED
  VERSION OF THE UPSTREAM TASK IS PRESENT, otherwise the match occurs
  with the first one found, whichever it is. This can fail if a suite
  problem puts a hold on spent task deletion! E.g.: topnet and oper
  interface go on ahead when topnet_vis has failed (unlikely to happen
  though!)

* just before a task runs, try to re-satisfy fuzzy prerequisites in case
  a more up-to-date satisfier has shown up while the task was waiting
  for other prerequisites to be satisfied ... OR (better?!) don't try to
  satisfy fuzzy prerequistes until after all non-fuzzy ones have been
  satsified. 

* WILL_SATSIFY_ME() REQUIRED FOR FUZZY and LOOSE PREREQUISITES?
  (else purge will fail if involving these tasks).
