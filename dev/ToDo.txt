_______
GENERAL

* temporary job submission filenames should contain the suite name
  so that automated cleanup processes can distinguish between suites.

* check use of re m.group() and m.groups(): 

    m.group(0)  # entire match
    m.group(1)  # first parenthesised sub-group
                # ...

    m.groups()  # tuple of parenthesised sub-groups


* task ID should not be needed in message strings (?); it can be supplied 
  automatically by access methods (for started, finished, etc.)

* cycle-dependent number of restarts: this can cause problems because
  only the most recent finished task is retained to satisfy
  prerequisites. If a task alternately does short and long forecasts
  with accordingly few and many restart outputs, we must retain *both*
  previously finished short and long versions of the task when currently
  only the short one would be retained. THE CYLC TASK ELIMINATION
  ALGORITHM MUST TASK RESTART OUTPUTS INTO ACCOUNT: Do not eliminate a
  finished task if its restart outputs are still valid.

* merge the config and suiterc modules?

* some kind of internal queuing system as a more flexible alternative to
  the simple max runahead limit?

* commandline option parsing: defaults can be set to int or float, but 
  values read from commandline input are always strings and need to be
  converted.

* dummy mode restart: clock-rate is set by state dump file, so no point 
  in having rate as a commandline option unless it overrides. (and what
  about offset? should it be in the state dump too?).

* a new task type modifier that allows failed "non-critical" tasks to be
  ignored when applying the max runahead limit.

* dot-file graph output assumes that task families are internally
  cotemporal. Is this necessarily the case?

* check all open( file, mode ) statements for mode 'rb' etc.  What is
  'b'? "binary"? if so, is this appropriate for cylc's usage.

* wherever I've used this:
    os.makedirs( os.path.dirname( filename ) )
  check that filename is not just a bare local dir filename like foo.bar
  as opposed to dir/foo.bar, else dirname() will return empty string and 
  makedirs() will fail.  This could happen if the user tries to use
  files in $PWD without specifying the full path.

* VIEWING AND INTERACTING WITH REMOTE SUITES:
  'cylc view --host=foo'               .... works
  'cylc view -u USER --host=foo SUITE' .... fails
  The '-u USER' option does not work for cylc commands when '--host' is
  required (remote machine) because cylc preferences looks for USER's
  home directory locally => WHEN --host IS USED WE CANNOT LOAD PREFS (TO
  PRELOAD THE TASK LIST; HAVE TO GET IT DYNAMICALLY FROM THE RUNNING
  SUITE).  

* example system implementations should always use $USER in temp dir
  paths, to avoid interference between users.

* allow default loadleveler directives for ll_basic etc., to be
  specified in suite.rc?

* allow insertion of tasks in 'spawned already' state, for oneoff runs 
  of non-oneoff tasks.

* purge algorithm: see TO DO in the in-method comments: ensure that ALL
  tasks whose prerequisites get satisfied in the virtual system
  evolution that occurs in the purge algorithm, get unsatisfied again at
  the end of it.

* practice mode should be allowed even for exclusive suite locks. 

* stop (without --now) won't cause shutdown if a task family (but not
  it's members!) has just triggered.

* currently, INHERITing tasks must define %OUTPUTS even if empty!

* make incremental configure handle deletion of taskdefs.

* duplicate task name (and short name) check should be done on
  generated task_list.py in addition to the check within configure,
  because the latter check is not always global now that configure is 
  incremental.

* task state at initialization: there's no point in giving initial
  state of "finished" for example, if this does not result in setting
  prerequisites and outputs satisfied and completed, respectively.
  Consolidate this task state resetting code into methods in task.py?

* check effect of 'reset to waiting' on task families - need to reset
  the special finished prerequisites too?

* note that prerequisites are no longer derived from requisites. Change
  documentation in the latter class (and elsewhere?) to reflect this.

* if a job with a stop time has task failures and is then restarted the
  restart should know about the stop time (otherwise the restart has no
  stop time but tasks that previously reached the stop time will not
  respawn -although this can be rectified by task insertion).

* allow ',' or ', ' in "if HOUR in 0,6,12:" taskdef conditionals.

* error trapping on wrapped SCRIPTING-only tasks: auto, or supply your
  own?

* if configure aborts it can leave the suite definition directory in a
  state that appears to be configured at next run, but isn't. So, delete
  the configured/ sub-directory in case of error, before aborting.

* keep a limited number of configured backup directories.

* check all example systems since recent changes.

* consider automatic task-started message as first line of SCRIPTING.

* current method of setting task commands is not very robust: each new
  command in a retry list is set in jobsubmit.py "remotely" from task.py

* --fail=TASKID: check that TASKID exists in the target suite.

* NOTE THAT FAILURE INSIDE RES=$( foo.sh ) DOES NOT TRIGGER THE ERR TRAP!

* consider getting rid of tied tasks and forcing explicit handling of
  restart dependencies? (they're a source of some confusion, and in any
  case explicit output messages are still required for coldstart tasks
  that supply restart dependencies to other tasks, and in some cases
  are not appropriate even for forecast models: e.g. UM in a DA suite
  with sometime reconfiguration of the restart dump. (BUT NOTE: tied 
  tasks also have special spawning behavior - after the first restart 
  output is completed!!!! - otherwise sequential is required.)

* check that the main uses for "oneoff cold start tasks" are documented.

* TASK FAMILIES:
  + --include and --exclude with task families
  + configure should check for consistency of MEMBER and MEMBER_OF
  + %OWNER should not be required with families (no %COMMAND).
  + currently have to specify %HOURS, which (a) should be
  checked for consistency with family members, or (b) should not be
  necessary (get it from members).

* %COMMAND:
    - conditional on HOUR? 
    - SINGLE QUOTES IN PATH OR COMMANDLINE

* could make $(CYCLE_TIME) implicit in messages except where reference
  to *other* cycles are required?

* allow $(CYCLE_HOUR) etc. in output and prereq messages (needed if
  anyone insists on using actual filenames in messages). 

* configure should check INHERIT targets actually exist.  At the moment
  this causes an exception early on at run time.

* make task-specific logs optional, especially for large suites.

* document new use of 'TaskID failed' as an output: added on the fly as
  a new output if failure occurs, then removed from the output list on
  reset.

* if chooser is clicked just as target suite shuts down, failure to
  connect error breaks the app, requiring use of 'kill'.

* cylc ping hangs if cylc is killed without cleaning up: needs timeout.

* long-running (almost 1 day) dummy mode oper run (started via vnc for
  ministerial opening demo) could not be unlocked or stopped (etc.) -
  got remote I/O Error via Pyro?  Is this related to running a suite
  from a VNC (or similar) remote desktop that gets disconnected?

* use new cylc_mode class everywhere mode test is required.

* submit --scheduler: task state resets to 'running' but all messages
  are ignored.

* consider how task timeout alerts might be incorporated into cylc? 

* extreme task elimination method - extrapolate forward in time to see
  if a finished task will ever be needed, otherwise delete?

* iteration over dictionary items: DO NOT USE
  = for item in dict:
  =    (operation that adds or removes items from dict)
  -> RuntimeError: dictionary changed size during iteration

  Instead use
  = for item in dict.keys():
  which must build a temporary list?

  CHECK USE OF DICTIONARY ITERATION THROUGHOUT THE CODE

* Record stopping time in state dump in case suite shutdown and
  restarted before all tasks reach the stop time is reached? (currently
  at restart those that did reach the stop time will be finished and
  unspawned, while those that didn't will carry on as if there was no
  stop time).

* catch obscure errors, such as attempting to restart when one or more 
  tasks has been commented out of the task list.

* src/which.py, like the shell command, searches only for executable
  files. The ll_raw job submit classes use which to find task scripts
  that don't have a full path supplied in the taskdef; these need
  to check that which returns a result before continuing (e.g. if 
  the task script has not been set executable). 

* daemon and asynchronous task: initial tests done, but will need to go
  back, check, and complete, for new versions of cylc.

* task groups defined in suite_config cause abort if any of the tasks
  therein are not defined (e.g. if commented out of the task list!)

* parse "HH:mm" for contact delay times etc.

* message command (command line usage only!!!) needs lock and practice mode?

* finish off the connection exception handling in manager class.

* consider reset --no-spawn (Bernard tried to reset a waiting unspawned
  task to finished, which made it spawn ... is this the desired
  behaviour?)

* insert may need a no-spawn option?

* consider restart messages for split tasks that actually use the same 
  restart files: e.g. nzlam_long (06,18Z) and nzlam_short (00,12Z). 
  Currently must combine this into one task with conditionals, OR 
  register (and report) restart messages explicitly because the
  automatic restart messages will not have the right task name.

* check that practice mode suites initialise with the same clock time
  as the original suite!

* DOCUMENT or CHANGE: cotemporal peers of failed tasks are not deleted
  automatically because they we USED TO restart with failed tasks in the 
  'waiting' state (not 'ready') - thus the aforementioned peers may be
  required to satisfy the failed task's prerequisites post resetting.

* Consider the effect of "# uncomment for earliest NON-FAILED" (x2) in
  manager.py - and test with dummy mode failout tasks.  For failed F in
  userguide example suite, it allows some intermediate finished cycles
  to be deleted, but this does not affect the delay due to max runahead.

* consider task proc loop invocation - could we separate summary update
  vs task processing (e.g. when a task fails we have to run pointlessly
  (?) through the loop in order to update the summary immediately for
  monitoring.

* warn about consequences of deleting a task: suite may move on so that
  a reinserted task will not get its prerequisites satisfied.

* task generator should look for mispelled $(CYLCE_TIME)

* is taskdef HOURS sorted for order?

* optionally allow a pyro request handling (or main loop?) timeout.
  (this is not needed now that the stalling problem is solved?)

* consistent suite exit strategy: 
   -sys.exit(1), 
   -raise SystemExit(message)
   -custom exceptions

* all error messages should go to stderr: print >> sys.stderr, 'message'

* allow cylc task proxies to kill their real external tasks at shutdown
  (and otherwise)?

* make sure that no remote operation, other than 'stop', can bring a
  suite down (exception handling on all remote switches).

* when there are multiple finished tasks that can satisfy a new task's
  restart prerequisites, the one that actually satisfies the new task
  will be an essentially random choice (the first one that comes along). 
  This is OK because the only thing that matters is that at least one
  task can satisfy the restart dependency, then the new task calls the
  prerequisite satisfied. However, we could get tasks to record the ID
  of the satisfier task as well, for each prerequisite, and also to
  choose the latest task as satisfier if more than one can do it.

* the task-generator script should check that the user-defined task
  names do not clash with parent class or attribute names.

* when remote killing all waiting tasks at a ref time, check that (a)
  the suite has moved on passed that time, and (b) none of the waiting
  tasks are contact tasks whose time has not come up yet.

* tasks with HOUR-conditional outputs may have trouble with the "keep
  one finished task of each kind" procedure in kill_spent_tasks(). Best
  to have multiple tasks instead? 

* use the custom clock everywhere (it knows about dummy mode).

* clean up the clock class with respect to dummy vs real time, and move
  it into task manager?

* do we need non-interpolation of single-quoted strings in taskdef
  environment, scripting, command? (implement in job_submit.py)?

* see To Do comment in broker.negotiate() - priority low.

* write a small test program to help understand exactly how Pyro works, 
  particularly with regard to multi-threading.

__________
LOCKSERVER
  (currently no known issues)

______
VIEWER

* task control interface.

* allow to put single tasks on hold / paused. 

* exception handling: if user clicks on a task that has just been
  eliminated (test this with quick-cycling trivial suite).

* access to task stdout and stderr for remote tasks? In fact, more
  generally, current we assume the viewer is running locally.

* more information about tasks to "interrogate" window:
  - HOURS
  - type (and spawning behaviour)



====================================
FUZZY PREREQUISITES (only for infrequent 'advanced' usage - e.g. hourly
TopNet in EcoConnect)

* allow mixed fuzzy and non-fuzzy prerequisites (currently have to 
  set identical fuzzy bounds to simulate the non-fuzzy case; see
  topnet.py).

* FUZZY MATCHING CURRENTLY ASSUMES AT MOST ONE COMPATIBLE OLDER FINISHED
  VERSION OF THE UPSTREAM TASK IS PRESENT, otherwise the match occurs
  with the first one found, whichever it is. This can fail if a suite
  problem puts a hold on spent task deletion! E.g.: topnet and oper
  interface go on ahead when topnet_vis has failed (unlikely to happen
  though!)

* just before a task runs, try to re-satisfy fuzzy prerequisites in case
  a more up-to-date satisfier has shown up while the task was waiting
  for other prerequisites to be satisfied ... OR (better?!) don't try to
  satisfy fuzzy prerequistes until after all non-fuzzy ones have been
  satsified. 
